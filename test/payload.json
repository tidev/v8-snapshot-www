{"v8":"8.8.278.17","script":"'use strict';\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n */\n\n/* eslint-disable quote-props */\n/* globals OS_ANDROID, OS_IOS */\n\n// Add global constants.\nObject.defineProperties(commonjsGlobal, {\n  'OS_ANDROID': {\n    value: true,\n    writable: false\n  },\n  'OS_IOS': {\n    value: false,\n    writable: false\n  },\n  OS_VERSION_MAJOR: {\n    value: Ti.Platform.versionMajor,\n    writable: false\n  },\n  OS_VERSION_MINOR: {\n    value: Ti.Platform.versionMinor,\n    writable: false\n  },\n  OS_VERSION_PATCH: {\n    value: Ti.Platform.versionPatch,\n    writable: false\n  }\n});\n\n// Copyright Node.js contributors. All rights reserved.\nconst kNodeModulesRE = /^(.*)[\\\\/]node_modules[\\\\/]/;\nconst customInspectSymbol = Symbol.for('nodejs.util.inspect.custom');\nconst isBuffer = Symbol.for('titanium.buffer.isBuffer');\nconst colorRegExp = /\\u001b\\[\\d\\d?m/g; // eslint-disable-line no-control-regex\n\nfunction removeColors(str) {\n  return str.replace(colorRegExp, '');\n}\nfunction isError(e) {\n  // An error could be an instance of Error while not being a native error\n  // or could be from a different realm and not be instance of Error but still\n  // be a native error.\n  return isNativeError(e) || e instanceof Error;\n}\nlet getStructuredStack;\nclass StackTraceError extends Error {}\nStackTraceError.prepareStackTrace = (err, trace) => trace;\nStackTraceError.stackTraceLimit = Infinity;\nfunction isInsideNodeModules() {\n  if (getStructuredStack === undefined) {\n    getStructuredStack = () => new StackTraceError().stack;\n  }\n  let stack = getStructuredStack();\n\n  // stack is only an array on v8, try to convert manually if string\n  if (typeof stack === 'string') {\n    const stackFrames = [];\n    const lines = stack.split(/\\n/);\n    for (const line of lines) {\n      const lineInfo = line.match(/(.*)@(.*):(\\d+):(\\d+)/);\n      if (lineInfo) {\n        const filename = lineInfo[2].replace('file://', '');\n        stackFrames.push({\n          getFileName: () => filename\n        });\n      }\n    }\n    stack = stackFrames;\n  }\n\n  // Iterate over all stack frames and look for the first one not coming\n  // from inside Node.js itself:\n  if (Array.isArray(stack)) {\n    for (const frame of stack) {\n      const filename = frame.getFileName();\n      // If a filename does not start with / or contain \\,\n      // it's likely from Node.js core.\n      if (!/^\\/|\\\\/.test(filename)) {\n        continue;\n      }\n      return kNodeModulesRE.test(filename);\n    }\n  }\n  return false;\n}\nfunction join$1(output, separator) {\n  let str = '';\n  if (output.length !== 0) {\n    const lastIndex = output.length - 1;\n    for (let i = 0; i < lastIndex; i++) {\n      // It is faster not to use a template string here\n      str += output[i];\n      str += separator;\n    }\n    str += output[lastIndex];\n  }\n  return str;\n}\nfunction uncurryThis(f) {\n  return function () {\n    return f.call.apply(f, arguments);\n  };\n}\nconst ALL_PROPERTIES$2 = 0;\nconst ONLY_ENUMERABLE$2 = 2;\nconst propertyFilter = {\n  ALL_PROPERTIES: ALL_PROPERTIES$2,\n  ONLY_ENUMERABLE: ONLY_ENUMERABLE$2\n};\nfunction getOwnNonIndexProperties(obj, filter) {\n  const props = [];\n  const keys = filter === ONLY_ENUMERABLE$2 ? Object.keys(obj) : Object.getOwnPropertyNames(obj);\n  for (var i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (!isAllDigits(key)) {\n      props.push(key);\n    }\n  }\n  return props;\n}\nfunction isAllDigits(s) {\n  if (s.length === 0) {\n    return false;\n  }\n  for (var i = 0; i < s.length; ++i) {\n    const code = s.charCodeAt(i);\n    if (code < 48 || code > 57) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Copyright Node.js contributors. All rights reserved.\nconst TypedArrayPrototype$1 = Object.getPrototypeOf(Uint8Array.prototype);\nconst TypedArrayProto_toStringTag = uncurryThis(Object.getOwnPropertyDescriptor(TypedArrayPrototype$1, Symbol.toStringTag).get);\nfunction isObject(value) {\n  return typeof value === 'object';\n}\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\nfunction checkPrototype(value, name) {\n  return Object.prototype.toString.call(value) === `[object ${name}]`;\n}\nfunction isAnyArrayBuffer(value) {\n  if (isArrayBuffer(value)) {\n    return true;\n  }\n  return isSharedArrayBuffer(value);\n}\nfunction isArgumentsObject(value) {\n  return isObject(value) && checkPrototype(value, 'Arguments');\n}\nfunction isArrayBuffer(value) {\n  return isObject(value) && checkPrototype(value, 'ArrayBuffer');\n}\n\n// Cached to make sure no userland code can tamper with it.\nconst isArrayBufferView = ArrayBuffer.isView;\nfunction isAsyncFunction(value) {\n  return isFunction(value) && checkPrototype(value, 'AsyncFunction');\n}\nfunction isBigInt64Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'BigInt64Array';\n}\nfunction isBigUint64Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'BigUint64Array';\n}\nfunction isBooleanObject(value) {\n  return isObject(value) && checkPrototype(value, 'Boolean');\n}\nfunction isBoxedPrimitive(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  return isNumberObject(value) || isStringObject(value) || isBooleanObject(value)\n  // || isBigIntObject(value)\n  || isSymbolObject(value);\n}\nfunction isDataView(value) {\n  return isObject(value) && checkPrototype(value, 'DataView');\n}\nfunction isDate(value) {\n  return isObject(value) && checkPrototype(value, 'Date');\n}\n\n// @todo isExternal\n\nfunction isFloat32Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Float32Array';\n}\nfunction isFloat64Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Float64Array';\n}\nfunction isGeneratorFunction(value) {\n  return isFunction(value) && checkPrototype(value, 'GeneratorFunction');\n}\nfunction isGeneratorObject(value) {\n  return isObject(value) && checkPrototype(value, 'Generator');\n}\nfunction isInt8Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Int8Array';\n}\nfunction isInt16Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Int16Array';\n}\nfunction isInt32Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Int32Array';\n}\nfunction isMap(value) {\n  return isObject(value) && checkPrototype(value, 'Map');\n}\nfunction isMapIterator(value) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  return prototype && prototype[Symbol.toStringTag] === 'Map Iterator';\n}\n\n// @todo isModuleNamespaceObject\n\nfunction isNativeError(value) {\n  // if not an instance of an Error, definitely not a native error\n  if (!(value instanceof Error)) {\n    return false;\n  }\n  if (!value || !value.constructor) {\n    return false;\n  }\n  return ['Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError'].includes(value.constructor.name);\n}\nfunction isNumberObject(value) {\n  return isObject(value) && checkPrototype(value, 'Number');\n}\nfunction isPromise(value) {\n  return isObject(value) && checkPrototype(value, 'Promise');\n}\n\n// @todo isProxy\n\nfunction isRegExp(value) {\n  return isObject(value) && checkPrototype(value, 'RegExp');\n}\nfunction isSet(value) {\n  return isObject(value) && checkPrototype(value, 'Set');\n}\nfunction isSetIterator(value) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  return prototype && prototype[Symbol.toStringTag] === 'Set Iterator';\n}\nfunction isSharedArrayBuffer(value) {\n  if (!global.SharedArrayBuffer) {\n    return false;\n  }\n  return isObject(value) && checkPrototype(value, 'SharedArrayBuffer');\n}\nfunction isStringObject(value) {\n  return isObject(value) && checkPrototype(value, 'String');\n}\nfunction isSymbolObject(value) {\n  return isObject(value) && checkPrototype(value, 'Symbol');\n}\nfunction isTypedArray(value) {\n  const isBuiltInTypedArray = TypedArrayProto_toStringTag(value) !== undefined;\n  if (isBuiltInTypedArray) {\n    return true;\n  }\n  return value[isBuffer] === true;\n}\nfunction isUint8Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Uint8Array';\n}\nfunction isUint8ClampedArray(value) {\n  return TypedArrayProto_toStringTag(value) === 'Uint8ClampedArray';\n}\nfunction isUint16Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Uint16Array';\n}\nfunction isUint32Array(value) {\n  return TypedArrayProto_toStringTag(value) === 'Uint32Array';\n}\nfunction isWeakMap(value) {\n  return isObject(value) && checkPrototype(value, 'WeakMap');\n}\nfunction isWeakSet(value) {\n  return isObject(value) && checkPrototype(value, 'WeakSet');\n}\n\n// @todo isWebAssemblyCompiledModule\n\nvar types = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tisAnyArrayBuffer: isAnyArrayBuffer,\n\tisArgumentsObject: isArgumentsObject,\n\tisArrayBuffer: isArrayBuffer,\n\tisArrayBufferView: isArrayBufferView,\n\tisAsyncFunction: isAsyncFunction,\n\tisBigInt64Array: isBigInt64Array,\n\tisBigUint64Array: isBigUint64Array,\n\tisBooleanObject: isBooleanObject,\n\tisBoxedPrimitive: isBoxedPrimitive,\n\tisDataView: isDataView,\n\tisDate: isDate,\n\tisFloat32Array: isFloat32Array,\n\tisFloat64Array: isFloat64Array,\n\tisGeneratorFunction: isGeneratorFunction,\n\tisGeneratorObject: isGeneratorObject,\n\tisInt8Array: isInt8Array,\n\tisInt16Array: isInt16Array,\n\tisInt32Array: isInt32Array,\n\tisMap: isMap,\n\tisMapIterator: isMapIterator,\n\tisNativeError: isNativeError,\n\tisNumberObject: isNumberObject,\n\tisPromise: isPromise,\n\tisRegExp: isRegExp,\n\tisSet: isSet,\n\tisSetIterator: isSetIterator,\n\tisSharedArrayBuffer: isSharedArrayBuffer,\n\tisStringObject: isStringObject,\n\tisSymbolObject: isSymbolObject,\n\tisTypedArray: isTypedArray,\n\tisUint8Array: isUint8Array,\n\tisUint8ClampedArray: isUint8ClampedArray,\n\tisUint16Array: isUint16Array,\n\tisUint32Array: isUint32Array,\n\tisWeakMap: isWeakMap,\n\tisWeakSet: isWeakSet\n});\n\n// Copyright Node.js contributors. All rights reserved.\nlet error;\nfunction lazyError() {\n  if (!error) {\n    // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?\n    // error = require('./errors').codes.ERR_INTERNAL_ASSERTION;\n    error = codes.ERR_INTERNAL_ASSERTION;\n  }\n  return error;\n}\nfunction assert$1(value, message) {\n  if (!value) {\n    const ERR_INTERNAL_ASSERTION = lazyError();\n    throw new ERR_INTERNAL_ASSERTION(message);\n  }\n}\nfunction fail(message) {\n  const ERR_INTERNAL_ASSERTION = lazyError();\n  throw new ERR_INTERNAL_ASSERTION(message);\n}\nassert$1.fail = fail;\n\n// Copyright Node.js contributors. All rights reserved.\nconst messages = new Map();\nconst codes = {};\n\n// @todo implement this once needed\nclass SystemError extends Error {}\n\n// Utility function for registering the error codes.\nfunction E(sym, val, def, ...otherClasses) {\n  // Special case for SystemError that formats the error message differently\n  // The SystemErrors only have SystemError as their base classes.\n  messages.set(sym, val);\n  if (def === SystemError) {\n    throw new Error('Node compatible SystemError not yet implemented.');\n  } else {\n    def = makeNodeErrorWithCode(def, sym);\n  }\n  if (otherClasses.length !== 0) {\n    otherClasses.forEach(clazz => {\n      def[clazz.name] = makeNodeErrorWithCode(clazz, sym);\n    });\n  }\n  codes[sym] = def;\n}\nfunction makeNodeErrorWithCode(Base, key) {\n  return class NodeError extends Base {\n    constructor(...args) {\n      super();\n      const message = getMessage(key, args, this);\n      Object.defineProperty(this, 'message', {\n        value: message,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      });\n      addCodeToName(this, super.name, key);\n    }\n    get code() {\n      return key;\n    }\n    set code(value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      });\n    }\n    toString() {\n      return `${this.name} [${key}]: ${this.message}`;\n    }\n  };\n}\nfunction getMessage(key, args, self) {\n  const msg = messages.get(key);\n\n  /*\r\n  // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?\r\n  if (assert === undefined) {\r\n  \tassert = require('./internal/assert');\r\n  }\r\n  */\n\n  if (typeof msg === 'function') {\n    assert$1(msg.length <= args.length,\n    // Default options do not count.\n    `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${msg.length}).`);\n    return msg.apply(self, args);\n  }\n  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;\n  assert$1(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${expectedLength}).`);\n  if (args.length === 0) {\n    return msg;\n  }\n  args.unshift(msg);\n  return format$1.apply(null, args);\n  // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?\n  // return lazyInternalUtilInspect().format.apply(null, args);\n}\n\nfunction addCodeToName(err, name, code) {\n  // Add the error code to the name to include it in the stack trace.\n  err.name = `${name} [${code}]`;\n  // Access the stack to generate the error message including the error code\n  // from the name.\n  // @fixme: This only works on V8/Android, iOS/JSC has a different Error structure.\n  // should we try to make errors behave the same across platforms?\n  // eslint-disable-next-line no-unused-expressions\n  err.stack;\n  // Reset the name to the actual name.\n  if (name === 'SystemError') {\n    Object.defineProperty(err, 'name', {\n      value: name,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n  } else {\n    delete err.name;\n  }\n}\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n// Using a default argument here is important so the argument is not counted\n// towards `Function#length`.\n(name = undefined) => {\n  if (name) {\n    return `\"${name}\" is outside of buffer bounds`;\n  }\n  return 'Attempt to access memory outside buffer bounds';\n}, RangeError);\nE('ERR_INTERNAL_ASSERTION', message => {\n  const suffix = 'This is caused by either a bug in Titanium ' + 'or incorrect usage of Titanium internals.\\n' + 'Please open an issue with this stack trace at ' + 'https://jira.appcelerator.org\\n';\n  return message === undefined ? suffix : `${message}\\n${suffix}`;\n}, Error);\nE('ERR_INVALID_ARG_TYPE', (name, expected, actual) => {\n  assert$1(typeof name === 'string', '\\'name\\' must be a string');\n\n  // determiner: 'must be' or 'must not be'\n  let determiner;\n  if (typeof expected === 'string' && expected.startsWith('not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n  let msg;\n  if (name.endsWith(' argument')) {\n    // For cases like 'first argument'\n    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;\n  } else {\n    const type = name.includes('.') ? 'property' : 'argument';\n    msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, 'type')}`;\n  }\n\n  // TODO(BridgeAR): Improve the output by showing `null` and similar.\n  msg += `. Received type ${typeof actual}`;\n  return msg;\n}, TypeError);\nlet maxStack_ErrorName;\nlet maxStack_ErrorMessage;\n/**\r\n * Returns true if `err.name` and `err.message` are equal to engine-specific\r\n * values indicating max call stack size has been exceeded.\r\n * \"Maximum call stack size exceeded\" in V8.\r\n *\r\n * @param {Error} err The error to check\r\n * @returns {boolean}\r\n */\nfunction isStackOverflowError(err) {\n  if (maxStack_ErrorMessage === undefined) {\n    try {\n      function overflowStack() {\n        overflowStack();\n      }\n      overflowStack();\n    } catch (e) {\n      maxStack_ErrorMessage = e.message;\n      maxStack_ErrorName = e.name;\n    }\n  }\n  return err.name === maxStack_ErrorName && err.message === maxStack_ErrorMessage;\n}\nfunction oneOf(expected, thing) {\n  assert$1(typeof thing === 'string', '`thing` has to be of type string');\n  if (Array.isArray(expected)) {\n    const len = expected.length;\n    assert$1(len > 0, 'At least one expected value needs to be specified');\n    expected = expected.map(i => String(i));\n    if (len > 2) {\n      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` + expected[len - 1];\n    } else if (len === 2) {\n      return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n    } else {\n      return `of ${thing} ${expected[0]}`;\n    }\n  } else {\n    return `of ${thing} ${String(expected)}`;\n  }\n}\n\nclass FastBuffer extends Uint8Array {}\n\n/**\r\n * loop over input, every 2 characters, parse as an int\r\n * basically each two characters are a \"byte\" or an 8-bit uint\r\n * we append them all together to form a single buffer holding all the values\r\n * @param {string} value string we're encoding in hex\r\n * @returns {integer[]} array of encoded bytes\r\n */\nfunction stringToHexBytes(value) {\n  const length = value.length / 2;\n  const byteArray = [];\n  for (let i = 0; i < length; i++) {\n    const numericValue = parseInt(value.substr(i * 2, 2), 16);\n    if (!Number.isNaN(numericValue)) {\n      // drop bad hex characters\n      byteArray.push(numericValue);\n    }\n  }\n  return byteArray;\n}\n\n// Use a Proxy to hack array style index accessors\nconst arrayIndexHandler = {\n  get(target, propKey, receiver) {\n    if (typeof propKey === 'string') {\n      const num = Number(propKey);\n      if (Number.isSafeInteger(num)) {\n        return getAdjustedIndex(target, num);\n      }\n    } else if (propKey === isBuffer) {\n      return true;\n    }\n    return Reflect.get(target, propKey, receiver);\n  },\n  set(target, propKey, value, receiver) {\n    if (typeof propKey === 'string') {\n      const num = Number(propKey);\n      if (Number.isSafeInteger(num)) {\n        setAdjustedIndex(target, num, value);\n        return true;\n      }\n    }\n    return Reflect.set(target, propKey, value, receiver);\n  },\n  has(target, key) {\n    if (typeof key === 'string') {\n      const num = Number(key);\n      if (Number.isSafeInteger(num)) {\n        // ensure it's a positive \"safe\" integer within the range of the buffer\n        return num >= 0 && num < target._tiBuffer.length;\n      }\n    }\n    return key in target;\n  }\n};\n\n// This is a special Buffer that wraps Ti.Buffer\n// as a result it is *much* slower to read/write values\n// because we need to go across the JS/Native boundary per-byte!\n// We also need to use a Proxy to handle intercepting set/get of indices to redirect to the underlying Ti.Buffer\nclass SlowBuffer {\n  /**\r\n   * Constructs a new buffer.\r\n   *\r\n   * Primarily used internally in this module together with `newBuffer` to\r\n   * create a new Buffer instance wrapping a Ti.Buffer.\r\n   *\r\n   * Also supports the deprecated Buffer() constructors which are safe\r\n   * to use outside of this module.\r\n   *\r\n   * @param {Ti.Buffer} tiBuffer the underlying data/bytes\r\n   * @param {integer} [start=0] start offset of array/buffer\r\n   * @param {integer} [length] length of the underlying array/buffer to wrap\r\n   */\n  constructor(tiBuffer, start = 0, length = tiBuffer.length - start) {\n    Object.defineProperties(this, {\n      byteOffset: {\n        value: start\n      },\n      length: {\n        value: length\n      },\n      _tiBuffer: {\n        value: tiBuffer\n      }\n    });\n  }\n\n  /**\r\n   * Wraps creation of a Buffer instance inside a Proxy so we can handle array index access\r\n   * @param {Ti.Buffer} tiBuffer the underlying data/bytes\r\n   * @param {integer} [start=0] start offset of array/buffer\r\n   * @param {integer} [length] length of the underlying array/buffer to wrap\r\n   * @returns {Buffer} wrapped inside a Proxy\r\n   */\n  static fromTiBuffer(tiBuffer, start, length) {\n    return new Proxy(new SlowBuffer(tiBuffer, start, length), arrayIndexHandler); // eslint-disable-line security/detect-new-buffer\n  }\n\n  static fromString(value, encoding) {\n    if (!Buffer.isEncoding(encoding)) {\n      throw new TypeError(`Unknown encoding: ${encoding}`);\n    }\n    encoding = encoding.toLowerCase();\n    if (encoding === 'base64') {\n      const blob = Ti.Utils.base64decode(value);\n      const blobStream = Ti.Stream.createStream({\n        source: blob,\n        mode: Ti.Stream.MODE_READ\n      });\n      const buffer = Ti.Stream.readAll(blobStream);\n      blobStream.close();\n      return SlowBuffer.fromTiBuffer(buffer);\n    }\n    if (encoding === 'hex') {\n      const bytes = stringToHexBytes(value);\n      const length = bytes.length;\n      const tiBuffer = Ti.createBuffer({\n        length\n      });\n      for (let i = 0; i < length; i++) {\n        tiBuffer[i] = bytes[i] & 0xFF; // mask to one byte\n      }\n\n      return SlowBuffer.fromTiBuffer(tiBuffer);\n    }\n    const tiBuffer = Ti.createBuffer({\n      value: value,\n      type: getTiCodecCharset(encoding)\n    });\n    return SlowBuffer.fromTiBuffer(tiBuffer);\n  }\n\n  // This is a method we should get by extending Uint8Array, so really should only be overriden on a \"SlowBuffer\" that wraps Ti.Buffer\n  get buffer() {\n    // Get the slice of the array from byteOffset to length\n    return Uint8Array.from(this).buffer;\n  }\n  _slice(offset, length) {\n    return SlowBuffer.fromTiBuffer(this._tiBuffer, offset, length);\n  }\n  _fill(value, offset, end, encoding) {\n    const valueType = typeof value;\n    if (valueType === 'string') {\n      const bufToFillWith = SlowBuffer.fromString(value, encoding);\n      const fillBufLength = bufToFillWith.length;\n      if (fillBufLength === 0) {\n        throw new Error('no valid fill data');\n      }\n      // If the buffer length === 1, we can just do this._tiBuffer.fill(value, offset, end);\n      if (fillBufLength === 1) {\n        this._tiBuffer.fill(bufToFillWith._tiBuffer[0], offset, end);\n        return this;\n      }\n\n      // multiple byte fill!\n      const length = end - offset;\n      for (let i = 0; i < length; i++) {\n        // TODO: Do we need to account for byteOffset here (on `this`, not on the buffer we just created)?\n        const fillChar = bufToFillWith._tiBuffer[i % fillBufLength];\n        this._tiBuffer[i + offset] = fillChar;\n      }\n      return this;\n    }\n\n    // if the value is a number (or a buffer with a single byte) we can use tiBuffer.fill();\n    this._tiBuffer.fill(value, offset, end);\n  }\n  getAdjustedIndex(index) {\n    return getAdjustedIndex(this, index);\n  }\n  setAdjustedIndex(index, value) {\n    return setAdjustedIndex(this, index, value);\n  }\n\n  // This is a method we should get by extending Uint8Array, so really should only be overriden on a \"SlowBuffer\" that wraps Ti.Buffer\n  set(src, offset = 0) {\n    const numBytes = src.length;\n    // check src.length + offset doesn't go beyond our length!\n    // FIXME: Re-enable\n    // checkOffset(this, offset, numBytes);\n    // copy src values into this buffer starting at offset\n    for (let i = 0; i < numBytes; i++) {\n      setAdjustedIndex(this, i + offset, src[i]);\n    }\n  }\n\n  /**\r\n   * Provides a conversion method for interacting with Ti APIs that require a Ti.Buffer\r\n   * @returns {Ti.Buffer} the underlying Ti.Buffer backing this Buffer instance\r\n   */\n  toTiBuffer() {\n    if (this.length === this._tiBuffer.length && this.byteOffset === 0) {\n      return this._tiBuffer;\n    }\n    return this._tiBuffer.clone(this.byteOffset, this.length);\n  }\n}\nfunction getAdjustedIndex(buf, index) {\n  if (index < 0) {\n    return undefined;\n  }\n  // Wrapping Ti.Buffer?\n  if (buf._tiBuffer) {\n    if (index >= buf._tiBuffer.length) {\n      return undefined;\n    }\n    return buf._tiBuffer[index + buf.byteOffset];\n  }\n  // Raw TypedArray/ArrayBuffer\n  // FIXME: do we need to account for byteOffset here?\n  return buf[index];\n}\nfunction setAdjustedIndex(buf, index, value) {\n  if (index < 0) {\n    return;\n  }\n  // Wrapping Ti.Buffer?\n  if (buf._tiBuffer) {\n    if (index < buf._tiBuffer.length) {\n      buf._tiBuffer[index + buf.byteOffset] = value;\n    }\n    return;\n  }\n  // Raw TypedArray/ArrayBuffer\n  // FIXME: do we need to account for byteOffset here?\n  buf[index] = value;\n}\n\n// https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings\nconst TI_CODEC_MAP = new Map();\nTI_CODEC_MAP.set('utf-8', Ti.Codec.CHARSET_UTF8);\nTI_CODEC_MAP.set('utf8', Ti.Codec.CHARSET_UTF8);\nTI_CODEC_MAP.set('utf-16le', Ti.Codec.CHARSET_UTF16LE);\nTI_CODEC_MAP.set('utf16le', Ti.Codec.CHARSET_UTF16LE);\nTI_CODEC_MAP.set('ucs2', Ti.Codec.CHARSET_UTF16LE);\nTI_CODEC_MAP.set('ucs-2', Ti.Codec.CHARSET_UTF16LE);\nTI_CODEC_MAP.set('latin1', Ti.Codec.CHARSET_ISO_LATIN_1);\nTI_CODEC_MAP.set('binary', Ti.Codec.CHARSET_ISO_LATIN_1);\nTI_CODEC_MAP.set('ascii', Ti.Codec.CHARSET_ASCII);\n/**\r\n * @param {string} encoding desired encoding name\r\n * @returns {integer} Ti.Codec constant that maps to the encoding\r\n */\nfunction getTiCodecCharset(encoding) {\n  return TI_CODEC_MAP.get(encoding);\n}\n\n/**\r\n * This implementation of Buffer uses a Ti.Buffer internally to back it.\r\n * This is likley an order of magnitude slower than using a variant that extends Uint8Array!\r\n * I think if we're not already wrapping a Ti.Buffer, it may be better to have two implementations\r\n * and, like browserify, just extend Uint8Array for any Buffers we need to read/write a lot\r\n * and then add a simple conversion method to turn it into a Ti.Buffer when needed.\r\n *\r\n * The Ti.Buffer impl has to go through the binding layer for reading/writing every byte.\r\n * If we anticipate the Buffer staying on the JS side, I'm willing to bet that the Uint8Array\r\n * the JS engine provides would be *way* faster.\r\n *\r\n * Also note that both Ti.Buffer and Node's Buffer were created before the JS engines had typed arrays\r\n * (and Uint8Array in particular) as a means of encapsulating a byte array. We should consider accepting\r\n * a Uint8Array in any of our APIs that take a Ti.Buffer and eventually deprecating/removing Ti.Buffer.\r\n */\nconst {\n  ALL_PROPERTIES: ALL_PROPERTIES$1,\n  ONLY_ENUMERABLE: ONLY_ENUMERABLE$1\n} = propertyFilter;\nconst VALID_ENCODINGS = ['hex', 'utf8', 'utf-8', 'ascii', 'latin1', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le'];\n\n// Used to cheat for read/writes of doubles\nconst doubleArray = new Float64Array(1);\nconst uint8DoubleArray = new Uint8Array(doubleArray.buffer);\n\n// Used to cheat to read/write floats\nconst floatArray = new Float32Array(1);\nconst uint8FloatArray = new Uint8Array(floatArray.buffer);\n\n// Node.js does some very weird stuff here\nFastBuffer.prototype.constructor = Buffer$1; // new FastBuffer() calls Buffer function?\nBuffer$1.prototype = FastBuffer.prototype; // Then it hijacks Buffer's prototype to point at FastBuffer's?!\n// Does this effectively mean Buffer extends Uint8Array, because FastBuffer did? This fails for me\n// How the hell can we make it happy? We really want to extend Uint8Array if we can\n// addBufferPrototypeMethods(Buffer.prototype); // Here's where it hangs some of the methods\n\nBuffer$1.poolSize = 8192;\n\n/**\r\n * Constructs a new buffer.\r\n *\r\n * Primarily used internally in this module together with `newBuffer` to\r\n * create a new Buffer instance wrapping a Ti.Buffer.\r\n *\r\n * Also supports the deprecated Buffer() constructors which are safe\r\n * to use outside of this module.\r\n *\r\n * @param {integer[]|Buffer|integer|string|Ti.Buffer} arg the underlying data/bytes\r\n * @param {string|integer} encodingOrOffset encoding of the string, or start offset of array/buffer\r\n * @param {integer} length length of the underlying array/buffer to wrap\r\n * @returns {Buffer}\r\n */\nfunction Buffer$1(arg, encodingOrOffset, length) {\n  if (arg === undefined) {\n    return;\n  }\n  if (typeof arg !== 'object' || arg.apiName !== 'Ti.Buffer') {\n    showFlaggedDeprecation();\n    if (typeof arg === 'number') {\n      if (typeof encodingOrOffset === 'string') {\n        throw new TypeError(`The \"string\" argument must be of type \"string\". Received type ${typeof arg}`);\n      }\n      return Buffer$1.alloc(arg);\n    }\n    return Buffer$1.from(arg, encodingOrOffset, length);\n  }\n\n  // The slow case - we're wrapping a Ti.Buffer\n  return SlowBuffer.fromTiBuffer(arg, encodingOrOffset, length);\n}\n\n/**\r\n * @param {integer[]|Buffer|string} value value we're wrapping\r\n * @param {string|integer} encodingOrOffset encoding of the string, or start offset of array/buffer\r\n * @param {integer} length length of the underlying array/buffer to wrap\r\n * @returns {Buffer}\r\n */\nBuffer$1.from = function (value, encodingOrOffset, length) {\n  const valueType = typeof value;\n  if (valueType === 'string') {\n    return fromString(value, encodingOrOffset);\n  } else if (valueType === 'object') {\n    if (isAnyArrayBuffer(value)) {\n      return fromArrayBuffer(value, encodingOrOffset, length);\n    }\n    if (Array.isArray(value) || value instanceof Uint8Array) {\n      return fromArray(value);\n    }\n    if (Buffer$1.isBuffer(value)) {\n      return fromBuffer(value);\n    }\n    // We want to limit the use of SlowBuffers to only when we're wrapping a Ti.Buffer, hopefully!\n    if (value.apiName && value.apiName === 'Ti.Buffer') {\n      return SlowBuffer.fromTiBuffer(value);\n    }\n  }\n  throw new TypeError('The \\'value\\' argument must be one of type: \\'string\\', \\'Array\\', \\'Buffer\\', \\'Ti.Buffer\\'');\n};\n\n/**\r\n * @param {ArrayBuffer} obj ArrayBuffer to wrap\r\n * @param {number} [byteOffset=0] byte offste to begin\r\n * @param {number} [length] length to wrap\r\n * @returns {Buffer}\r\n */\nfunction fromArrayBuffer(obj, byteOffset, length) {\n  // Convert byteOffset to integer\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  } else {\n    byteOffset = +byteOffset;\n    if (Number.isNaN(byteOffset)) {\n      byteOffset = 0;\n    }\n  }\n  const maxLength = obj.byteLength - byteOffset;\n  if (maxLength < 0) {\n    throw new codes.ERR_BUFFER_OUT_OF_BOUNDS('offset');\n  }\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    // Convert length to non-negative integer.\n    length = +length;\n    if (length > 0) {\n      if (length > maxLength) {\n        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS('length');\n      }\n    } else {\n      length = 0;\n    }\n  }\n  return new FastBuffer(obj, byteOffset, length);\n}\n\n/**\r\n * @param {string} value value to wrap\r\n * @param {string} [encoding='utf8'] character encoding\r\n * @returns {Buffer}\r\n */\nfunction fromString(value, encoding = 'utf8') {\n  if (!Buffer$1.isEncoding(encoding)) {\n    throw new TypeError(`Unknown encoding: ${encoding}`);\n  }\n  encoding = encoding.toLowerCase();\n  if (encoding === 'base64') {\n    const blob = Ti.Utils.base64decode(value);\n    return new FastBuffer(blob.toArrayBuffer());\n  }\n  if (encoding === 'hex') {\n    return fromArray(stringToHexBytes(value));\n  }\n  // Convert the SlowBuffer to a fast buffer by just copying bytes recursively here\n  return fromBuffer(SlowBuffer.fromString(value, encoding));\n}\n\n/**\r\n * @param {integer[]|Uint8Array|array} value values to wrap\r\n * @returns {Buffer}\r\n */\nfunction fromArray(value) {\n  const length = value.length;\n  if (length === 0) {\n    return new FastBuffer();\n  }\n  return new FastBuffer(value);\n}\n\n/**\r\n * Ideally this should only be used when we're copying a SlowBuffer into a new FastBuffer\r\n * @param {Buffer} value buffer to copy\r\n * @returns {Buffer}\r\n */\nfunction fromBuffer(value) {\n  const length = value.length;\n  if (length === 0) {\n    return new FastBuffer();\n  }\n  const buffer = Buffer$1.allocUnsafe(length);\n  value.copy(buffer, 0, 0, length);\n  return buffer;\n}\nObject.setPrototypeOf(Buffer$1, Uint8Array); // What is this doing?! Making Buffer.prototype point at Uint8Array now\n\n/**\r\n * 0 is returned if target is the same as buf\r\n * 1 is returned if target should come before buf when sorted.\r\n * -1 is returned if target should come after buf when sorted.\r\n * @param {Buffer} target Buffer to compare against\r\n * @param {integer} [targetStart=0] index to start in target\r\n * @param {integer} [targetEnd=target.length] index to end in target\r\n * @param {integer} [sourceStart=0] index to start in this Buffer\r\n * @param {integer} [sourceEnd=this.length] index to end in this Buffer\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.compare = function (target, targetStart, targetEnd, sourceStart, sourceEnd) {\n  if (!Buffer$1.isBuffer(target)) {\n    throw new TypeError(`The \"target\" argument must be one of type Buffer or Uint8Array. Received type ${typeof buf1}`);\n  }\n  if (targetStart === undefined) {\n    targetStart = 0;\n  }\n  if (sourceStart === undefined) {\n    sourceStart = 0;\n  }\n  if (targetEnd === undefined) {\n    targetEnd = target.length;\n  }\n  if (sourceEnd === undefined) {\n    sourceEnd = this.length;\n  }\n\n  // ERR_OUT_OF_RANGE is thrown if targetStart < 0, sourceStart < 0, targetEnd > target.byteLength, or sourceEnd > source.byteLength\n  if (targetStart < 0 || sourceStart < 0 || targetEnd > target.length || sourceEnd > this.length) {\n    throw new RangeError('Index out of range'); // FIXME: set \"code\" to ERR_INDEX_OUT_OF_RANGE\n  }\n\n  // Use slices to make the loop easier\n  const source = this.slice(sourceStart, sourceEnd);\n  const sourceLength = source.length;\n  const dest = target.slice(targetStart, targetEnd);\n  const destLength = dest.length;\n  const length = Math.min(sourceLength, destLength);\n  for (let i = 0; i < length; i++) {\n    const targetValue = dest.getAdjustedIndex(i);\n    const sourceValue = source.getAdjustedIndex(i);\n    if (targetValue !== sourceValue) {\n      // No match! Return 1 or -1 based on what is greater!\n      if (sourceValue < targetValue) {\n        return -1;\n      }\n      return 1;\n    }\n  }\n\n  // sort based on length!\n  if (sourceLength < destLength) {\n    return -1;\n  }\n  if (sourceLength > destLength) {\n    return 1;\n  }\n  return 0;\n};\n\n/**\r\n * Copies from this to target\r\n * @param {Buffer} target destination we're copying into\r\n * @param {integer} [targetStart=0] start index to copy into in destination Buffer\r\n * @param {integer} [sourceStart=0] start index to copy from within `this`\r\n * @param {integer} [sourceEnd=this.length] end index to copy from within `this`\r\n * @returns {integer} number of bytes copied\r\n */\nBuffer$1.prototype.copy = function (target, targetStart, sourceStart, sourceEnd) {\n  if (targetStart === undefined) {\n    targetStart = 0;\n  }\n  if (sourceStart === undefined) {\n    sourceStart = 0;\n  }\n  if (sourceEnd === undefined) {\n    sourceEnd = this.length;\n  }\n  if (sourceStart === sourceEnd) {\n    return 0;\n  }\n  if (target.length === 0 || this.length === 0) {\n    return 0;\n  }\n  // TODO: check for out of bounds?\n  let length = sourceEnd - sourceStart;\n  // Cap length to remaining bytes in target!\n  const remaining = target.length - targetStart;\n  if (length > remaining) {\n    sourceEnd = sourceStart + remaining;\n    length = remaining;\n  }\n  // Determine actual number of bytes we'll copy, constrain by source buffer length as well as target (above)\n  let numBytes = length;\n  const sourceLen = this.length - sourceStart;\n  if (numBytes > sourceLen) {\n    numBytes = sourceLen;\n  }\n\n  // TODO: handle overlap when target === this!\n  // TODO: Do we need to take target byteOffset into account here?\n  let source = this;\n  if (sourceStart !== 0 || sourceEnd < source.length) {\n    source = new Uint8Array(this.buffer, this.byteOffset + sourceStart, numBytes);\n  }\n  target.set(source, targetStart);\n  return numBytes;\n};\n\n/**\r\n * Creates and returns an iterator of [index, byte] pairs from the contents of buf.\r\n * @returns {Iterator}\r\n */\n// TODO: Is this only necessary for SlowBuffer?\nBuffer$1.prototype.entries = function () {\n  const buffer = this;\n  let nextIndex = 0;\n  const end = this.length;\n  const entryIterator = {\n    next: function () {\n      if (nextIndex < end) {\n        const result = {\n          value: [nextIndex, buffer.getAdjustedIndex(nextIndex)],\n          done: false\n        };\n        nextIndex++;\n        return result;\n      }\n      return {\n        value: undefined,\n        done: true\n      };\n    },\n    [Symbol.iterator]: function () {\n      return this;\n    }\n  };\n  return entryIterator;\n};\nBuffer$1.prototype.equals = function (otherBuffer) {\n  if (!Buffer$1.isBuffer(otherBuffer)) {\n    throw new TypeError('argument must be a Buffer');\n  }\n  if (otherBuffer === this) {\n    return true;\n  }\n  return this.compare(otherBuffer) === 0;\n};\n\n/**\r\n * @param {string|Buffer|UInt8Array|integer} value The value with which to fill `buf`.\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to fill `buf`\r\n * @param {integer} [end] Where to stop filling buf (not inclusive). `buf.length` by default\r\n * @param {string} [encoding='utf8'] The encoding for `value` if `value` is a string.\r\n * @returns {this}\r\n */\nBuffer$1.prototype.fill = function (value, offset, end, encoding) {\n  const offsetType = typeof offset;\n  if (offsetType === 'undefined') {\n    // value supplied\n    offset = 0;\n    end = this.length;\n    encoding = 'utf8';\n  } else if (offsetType === 'string') {\n    // value, encoding supplied\n    encoding = offset;\n    offset = 0;\n    end = this.length;\n  } else if (typeof end === 'string') {\n    // value, offset, encoding supplied\n    encoding = end;\n    end = this.length;\n  }\n  this._fill(value, offset, end, encoding);\n  return this;\n};\nconst TypedArrayPrototype = Object.getPrototypeOf(Uint8Array.prototype);\nconst TypedArrayProto_byteLength = Object.getOwnPropertyDescriptor(TypedArrayPrototype, 'byteLength').get;\nconst TypedArrayFill = TypedArrayPrototype.fill;\nBuffer$1.prototype._fill = function (value, offset, end, encoding) {\n  if (typeof value === 'number') {\n    // OOB check\n    const byteLen = TypedArrayProto_byteLength.call(this);\n    const fillLength = end - offset;\n    if (offset > end || fillLength + offset > byteLen) {\n      throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n    TypedArrayFill.call(this, value, offset, end);\n  } else {\n    const bufToFillWith = SlowBuffer.fromString(value, encoding);\n    const fillBufLength = bufToFillWith.length;\n    if (fillBufLength === 0) {\n      throw new Error('no valid fill data');\n    }\n    if (fillBufLength === 1) {\n      TypedArrayFill.call(this, bufToFillWith._tiBuffer[0], offset, end);\n      return this;\n    }\n\n    // multiple byte fill!\n    const length = end - offset;\n    for (let i = 0; i < length; i++) {\n      // TODO: Do we need to account for byteOffset here (on `this`, not on the buffer we just created)?\n      const fillChar = bufToFillWith._tiBuffer[i % fillBufLength];\n      this.setAdjustedIndex(i + offset, fillChar);\n    }\n  }\n};\nBuffer$1.prototype.includes = function (value, byteOffset, encoding) {\n  return this.indexOf(value, byteOffset, encoding) !== -1;\n};\n\n/**\r\n * @param {string|Buffer|integer} value What to search for\r\n * @param {integer} [byteOffset=0] Where to begin searching in buf. If negative, then offset is calculated from the end of buf\r\n * @param {string} [encoding='utf8'] If value is a string, this is the encoding used to determine the binary representation of the string that will be searched for in buf\r\n * @returns {integer} The index of the first occurrence of value in buf, or -1 if buf does not contain value.\r\n */\nBuffer$1.prototype.indexOf = function (value, byteOffset, encoding) {\n  if (this.length === 0) {\n    // empty buffer? can't find anything!\n    return -1;\n  }\n\n  // if byteOffset is undefined, make it 0\n  if (typeof byteOffset === 'undefined') {\n    byteOffset = 0;\n  } else if (typeof byteOffset === 'string') {\n    // if it's a string, that's actually encoding\n    encoding = byteOffset;\n    byteOffset = 0;\n  }\n\n  // if we don't have an encoding yet, use utf8\n  if (typeof encoding !== 'string') {\n    encoding = 'utf8';\n  }\n  if (byteOffset < 0) {\n    // convert negative indices\n    byteOffset = this.length + byteOffset;\n    if (byteOffset < 0) {\n      // still negative? start at 0\n      byteOffset = 0;\n    }\n  } else if (byteOffset >= this.length) {\n    return -1; // can't find past end of buffer!\n  }\n\n  if (typeof value === 'number') {\n    value &= 0xFF; // clamp to 255\n    // This is a simpler case, we have a single byte we need to search for\n    // so just loop through and try to find it\n    return indexOf(this, value, byteOffset);\n  }\n\n  // coerce a string to a Buffer\n  if (typeof value === 'string') {\n    value = fromString(value, encoding);\n  }\n\n  // value is now a Buffer...\n  const matchLength = value.length;\n  if (matchLength === 0) {\n    return -1; // never find empty value!\n  }\n\n  if (matchLength === 1) {\n    // simple case, match one byte!\n    return indexOf(this, value[0], byteOffset);\n  }\n  let currentIndex = byteOffset;\n  const thisLength = this.length;\n  if (matchLength > thisLength) {\n    return -1; // can't match if the value is longer than this Buffer!\n  }\n\n  // FIXME: Can we rewrite this in a less funky way?\n  // FIXME: Can stop earlier based on matchLength!\n  firstMatch: while (currentIndex < thisLength) {\n    // eslint-disable-line no-labels\n    // match first byte!\n    let firstByteMatch = indexOf(this, value[0], currentIndex);\n    if (firstByteMatch === -1) {\n      // couldn't even match the very first byte, so no match overall!\n      return -1;\n    }\n\n    // ok, we found the first byte, now we need to see if the next consecutive bytes match!\n    for (let x = 1; x < matchLength; x++) {\n      if (firstByteMatch + x >= thisLength) {\n        currentIndex = firstByteMatch + 1; // move past our first match\n        continue firstMatch; // eslint-disable-line no-labels\n      }\n\n      if (this[firstByteMatch + x] !== value[x]) {\n        // didn't match!\n        currentIndex = firstByteMatch + 1; // move past our first match\n        continue firstMatch; // eslint-disable-line no-labels\n      }\n    }\n\n    return firstByteMatch; // the rest matched, hurray!\n  }\n\n  return -1;\n};\nBuffer$1.prototype.keys = function () {\n  let nextIndex = 0;\n  const end = this.length;\n  const myIterator = {\n    next: function () {\n      if (nextIndex < end) {\n        const result = {\n          value: nextIndex,\n          done: false\n        };\n        nextIndex++;\n        return result;\n      }\n      return {\n        value: undefined,\n        done: true\n      };\n    },\n    [Symbol.iterator]: function () {\n      return this;\n    }\n  };\n  return myIterator;\n};\n\n/**\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8\r\n * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format\r\n */\nBuffer$1.prototype.readDoubleBE = function (offset = 0) {\n  checkOffset(this, offset, 8);\n\n  // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer\n  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array\n  // FIXME: This assumes LE system byteOrder\n  uint8DoubleArray[7] = this[offset++];\n  uint8DoubleArray[6] = this[offset++];\n  uint8DoubleArray[5] = this[offset++];\n  uint8DoubleArray[4] = this[offset++];\n  uint8DoubleArray[3] = this[offset++];\n  uint8DoubleArray[2] = this[offset++];\n  uint8DoubleArray[1] = this[offset++];\n  uint8DoubleArray[0] = this[offset++];\n  return doubleArray[0];\n};\n\n/**\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8\r\n * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format\r\n */\nBuffer$1.prototype.readDoubleLE = function (offset = 0) {\n  checkOffset(this, offset, 8);\n\n  // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer\n  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array\n  // FIXME: This assumes LE system byteOrder\n  uint8DoubleArray[0] = this[offset++];\n  uint8DoubleArray[1] = this[offset++];\n  uint8DoubleArray[2] = this[offset++];\n  uint8DoubleArray[3] = this[offset++];\n  uint8DoubleArray[4] = this[offset++];\n  uint8DoubleArray[5] = this[offset++];\n  uint8DoubleArray[6] = this[offset++];\n  uint8DoubleArray[7] = this[offset++];\n  return doubleArray[0];\n};\n\n/**\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4\r\n * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format\r\n */\nBuffer$1.prototype.readFloatBE = function (offset = 0) {\n  checkOffset(this, offset, 4);\n\n  // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer\n  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array\n  // FIXME: This assumes LE system byteOrder\n  uint8FloatArray[3] = this[offset++];\n  uint8FloatArray[2] = this[offset++];\n  uint8FloatArray[1] = this[offset++];\n  uint8FloatArray[0] = this[offset++];\n  return floatArray[0];\n};\n\n/**\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4\r\n * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format\r\n */\nBuffer$1.prototype.readFloatLE = function (offset = 0) {\n  checkOffset(this, offset, 4);\n\n  // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer\n  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array\n  // FIXME: This assumes LE system byteOrder\n  uint8FloatArray[0] = this[offset++];\n  uint8FloatArray[1] = this[offset++];\n  uint8FloatArray[2] = this[offset++];\n  uint8FloatArray[3] = this[offset++];\n  return floatArray[0];\n};\n\n/**\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.readInt8 = function (offset = 0) {\n  const unsignedValue = this.readUInt8(offset);\n  return unsignedToSigned(unsignedValue, 1);\n};\n\n/**\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.readInt16BE = function (offset) {\n  const unsignedValue = this.readUInt16BE(offset);\n  return unsignedToSigned(unsignedValue, 2);\n};\n\n/**\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.readInt16LE = function (offset = 0) {\n  const unsignedValue = this.readUInt16LE(offset);\n  return unsignedToSigned(unsignedValue, 2);\n};\n\n/**\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.readInt32BE = function (offset = 0) {\n  const unsignedValue = this.readUInt32BE(offset);\n  return unsignedToSigned(unsignedValue, 4);\n};\n\n/**\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.readInt32LE = function (offset = 0) {\n  const unsignedValue = this.readUInt32LE(offset);\n  return unsignedToSigned(unsignedValue, 4);\n};\n\n/**\r\n * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.\r\n * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.\r\n * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.readIntBE = function (offset, byteLength) {\n  const unsignedValue = this.readUIntBE(offset, byteLength);\n  return unsignedToSigned(unsignedValue, byteLength);\n};\n\n/**\r\n * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.\r\n * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.\r\n * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.readIntLE = function (offset, byteLength) {\n  const unsignedValue = this.readUIntLE(offset, byteLength);\n  return unsignedToSigned(unsignedValue, byteLength);\n};\n\n/**\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.readUInt8 = function (offset = 0) {\n  checkOffset(this, offset, 1);\n  return this[offset];\n};\n\n/**\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.readUInt16BE = function (offset = 0) {\n  checkOffset(this, offset, 2);\n  // first byte shifted and OR'd with second byte\n  return this[offset] << 8 | this[offset + 1];\n};\n\n/**\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.readUInt16LE = function (offset = 0) {\n  checkOffset(this, offset, 2);\n  // first byte OR'd with second byte shifted\n  return this[offset] | this[offset + 1] << 8;\n};\n\n/**\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.readUInt32BE = function (offset = 0) {\n  checkOffset(this, offset, 4);\n  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n  // rather than shifting by << 24, multiply the first byte and add it in so we don't retain the \"sign bit\"\n  // (because bit-wise operators assume a 32-bit number)\n};\n\n/**\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.readUInt32LE = function (offset = 0) {\n  checkOffset(this, offset, 4);\n  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n  // rather than shifting by << 24, multiply the last byte and add it in so we don't retain the \"sign bit\"\n};\n\n/**\r\n * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.\r\n * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.readUIntBE = function (offset, byteLength) {\n  if (byteLength <= 0 || byteLength > 6) {\n    throw new RangeError('Index out of range');\n  }\n  checkOffset(this, offset, byteLength);\n  let result = 0;\n  let multiplier = 1; // we use a multipler for each byte\n  // we're doing the same loop as #readUIntLE, just backwards!\n  for (let i = byteLength - 1; i >= 0; i--) {\n    result += this.getAdjustedIndex(offset + i) * multiplier;\n    multiplier *= 0x100; // move multiplier to next byte\n  }\n\n  return result;\n};\n\n/**\r\n * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.\r\n * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.readUIntLE = function (offset, byteLength) {\n  if (byteLength <= 0 || byteLength > 6) {\n    throw new RangeError('Index out of range');\n  }\n  checkOffset(this, offset, byteLength);\n  let result = 0;\n  let multiplier = 1; // we use a multipler for each byte\n  for (let i = 0; i < byteLength; i++) {\n    result += this.getAdjustedIndex(offset + i) * multiplier;\n    multiplier *= 0x100; // move multiplier to next byte\n  }\n\n  return result;\n};\n\n/**\r\n * @param {integer} [start=0] Where the new `Buffer` will start.\r\n * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.\r\n * @returns {Buffer}\r\n */\nBuffer$1.prototype.slice = function (start, end) {\n  const thisLength = this.length;\n  if (typeof start === 'undefined') {\n    start = 0;\n  } else if (start < 0) {\n    start = thisLength + start;\n    if (start < 0) {\n      // if this is still negative, use 0 (that matches Node)\n      start = 0;\n    }\n  }\n  if (typeof end === 'undefined') {\n    end = thisLength;\n  } else if (end < 0) {\n    end = thisLength + end;\n  }\n  // Specifying end greater than buf.length will return the same result as that of end equal to buf.length.\n  if (end > thisLength) {\n    end = thisLength;\n  }\n  // What if end is less than start?\n  let length = end - start;\n  if (length <= 0) {\n    length = 0; // return empty view of Buffer! retain byte offset, set length to 0\n  }\n  // Wrap the same ArrayBuffer object but specify the start/end to \"crop\" with\n  return this._slice(this.byteOffset + start, length);\n};\nBuffer$1.prototype._slice = function (offset, length) {\n  return new FastBuffer(this.buffer, offset, length);\n};\n\n/**\r\n * @param {integer} [start=0] Where the new `Buffer` will start.\r\n * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.\r\n * @returns {Buffer}\r\n */\nBuffer$1.prototype.subarray = function (start, end) {\n  return this.slice(start, end);\n};\n\n/**\r\n * Interprets buf as an array of unsigned 16-bit integers and swaps the byte order in-place.\r\n * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 2.\r\n * @returns {Buffer}\r\n */\nBuffer$1.prototype.swap16 = function () {\n  const length = this.length;\n  if (length % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits');\n  }\n  for (let i = 0; i < length; i += 2) {\n    const first = this.getAdjustedIndex(i);\n    const second = this.getAdjustedIndex(i + 1);\n    this.setAdjustedIndex(i, second);\n    this.setAdjustedIndex(i + 1, first);\n  }\n  return this;\n};\n\n/**\r\n * Interprets buf as an array of unsigned 32-bit integers and swaps the byte order in-place.\r\n * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 4.\r\n * @returns {Buffer}\r\n */\nBuffer$1.prototype.swap32 = function () {\n  const length = this.length;\n  if (length % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits');\n  }\n  for (let i = 0; i < length; i += 4) {\n    const first = this.getAdjustedIndex(i);\n    const second = this.getAdjustedIndex(i + 1);\n    const third = this.getAdjustedIndex(i + 2);\n    const fourth = this.getAdjustedIndex(i + 3);\n    this.setAdjustedIndex(i, fourth);\n    this.setAdjustedIndex(i + 1, third);\n    this.setAdjustedIndex(i + 2, second);\n    this.setAdjustedIndex(i + 3, first);\n  }\n  return this;\n};\n\n/**\r\n * Interprets buf as an array of unsigned 64-bit integers and swaps the byte order in-place.\r\n * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 8.\r\n * @returns {Buffer}\r\n */\nBuffer$1.prototype.swap64 = function () {\n  const length = this.length;\n  if (length % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits');\n  }\n  for (let i = 0; i < length; i += 8) {\n    const first = this.getAdjustedIndex(i);\n    const second = this.getAdjustedIndex(i + 1);\n    const third = this.getAdjustedIndex(i + 2);\n    const fourth = this.getAdjustedIndex(i + 3);\n    const fifth = this.getAdjustedIndex(i + 4);\n    const sixth = this.getAdjustedIndex(i + 5);\n    const seventh = this.getAdjustedIndex(i + 6);\n    const eighth = this.getAdjustedIndex(i + 7);\n    this.setAdjustedIndex(i, eighth);\n    this.setAdjustedIndex(i + 1, seventh);\n    this.setAdjustedIndex(i + 2, sixth);\n    this.setAdjustedIndex(i + 3, fifth);\n    this.setAdjustedIndex(i + 4, fourth);\n    this.setAdjustedIndex(i + 5, third);\n    this.setAdjustedIndex(i + 6, second);\n    this.setAdjustedIndex(i + 7, first);\n  }\n  return this;\n};\n\n/**\r\n * @returns {object}\r\n */\nBuffer$1.prototype.toJSON = function () {\n  return {\n    type: 'Buffer',\n    // Take advantage of slice working on \"Array-like\" objects (just like `arguments`)\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Array-like_objects\n    data: [].slice.call(this)\n  };\n};\n\n/**\r\n * @param {string} [encoding='utf8'] The character encoding to use\r\n * @param {integer} [start=0] The byte offset to start decoding at\r\n * @param {integer} [end] The byte offset to stop decoding at (not inclusive). `buf.length` default\r\n * @returns {string}\r\n */\nBuffer$1.prototype.toString = function (encoding, start, end) {\n  // fast case of no args\n  if (arguments.length === 0) {\n    return this.toTiBuffer().toString();\n  }\n  const length = this.length;\n  if (start >= length) {\n    return ''; // start is past end of buffer, return empty string\n  }\n\n  if (start < 0 || typeof start !== 'number') {\n    start = 0;\n  }\n  if (end > length || typeof end !== 'number') {\n    // no end specified, or past end of buffer, use length of buffer\n    end = length;\n  } // else keep end as passed in\n\n  if (end <= start) {\n    return ''; // if end is before start return empty string\n  }\n\n  // If start !== 0 and end !== length, maybe we should do a Buffer.subarray/slice over the range and call toString() on that?\n  if (start !== 0 || end !== length) {\n    return this.slice(start, end).toString(encoding);\n  }\n\n  // base case, start is 0, end is length\n  if (encoding === undefined) {\n    encoding = 'utf8';\n  } else {\n    encoding = encoding.toLowerCase();\n    // Throw if bad encoding!\n    if (!Buffer$1.isEncoding(encoding)) {\n      throw new TypeError(`Unknown encoding: ${encoding}`);\n    }\n  }\n  if (encoding === 'utf8' || encoding === 'utf-8') {\n    return this.toTiBuffer().toString(); // we return utf-8 by default natively\n  }\n\n  if (encoding === 'base64') {\n    return Ti.Utils.base64encode(this.toTiBuffer().toBlob()).toString();\n  }\n  if (encoding === 'hex') {\n    return this.hexSlice(0, length);\n  }\n  if (encoding === 'latin1' || encoding === 'binary') {\n    let latin1String = '';\n    for (let i = 0; i < length; i++) {\n      // each one is a \"byte\"\n      latin1String += String.fromCharCode(this.getAdjustedIndex(i));\n    }\n    return latin1String;\n  }\n  if (encoding === 'ascii') {\n    let ascii = '';\n    for (let i = 0; i < length; i++) {\n      // we store bytes (8-bit), but ascii is 7-bit. Node \"masks\" the last bit off, so let's do the same\n      ascii += String.fromCharCode(this.getAdjustedIndex(i) & 0x7F);\n    }\n    return ascii;\n  }\n\n  // UCS2/UTF16\n  return this.ucs2Slice(0, length);\n};\nBuffer$1.prototype.getAdjustedIndex = function (index) {\n  return this[index];\n};\nBuffer$1.prototype.setAdjustedIndex = function (index, value) {\n  return this[index] = value;\n};\nBuffer$1.prototype.hexSlice = function (start, end) {\n  let hexStr = '';\n  for (let i = start; i < end; i++) {\n    // each one is a \"byte\"\n    let hex = (this.getAdjustedIndex(i) & 0xff).toString(16);\n    hex = hex.length === 1 ? '0' + hex : hex;\n    hexStr += hex;\n  }\n  return hexStr;\n};\nBuffer$1.prototype.ucs2Slice = function (start, end) {\n  let out = '';\n  let i = start;\n  while (i < end) {\n    // utf-16/ucs-2 is 2-bytes per character\n    const byte1 = this.getAdjustedIndex(i++);\n    const byte2 = this.getAdjustedIndex(i++);\n    const code_unit = (byte2 << 8) + byte1; // we mash together the two bytes\n    out += String.fromCodePoint(code_unit);\n  }\n  return out;\n};\n\n/**\r\n * Provides a conversion method for interacting with Ti APIs that require a Ti.Buffer\r\n * @returns {Ti.Buffer} the underlying Ti.Buffer backing this Buffer instance\r\n */\nBuffer$1.prototype.toTiBuffer = function () {\n  const tiBuffer = Ti.createBuffer({\n    length: this.length\n  });\n  copyBuffer(this, tiBuffer, 0, this.length);\n  return tiBuffer;\n};\n\n/**\r\n * @param {Buffer} src source Buffer we're copying from\r\n * @param {Ti.Buffer} dest destination Ti.Buffer we're copying into\r\n * @param {integer} offset start offset we're copying to in destination\r\n * @param {integer} length number of bytes to copy\r\n * @returns {integer} actual number of bytes copied\r\n */\nfunction copyBuffer(src, dest, offset, length) {\n  const srcLength = src.length;\n  const destLength = dest.length;\n  let i = 0;\n  for (; i < length; i++) {\n    const destIndex = i + offset;\n    // are we trying to write past end of destination? Or read past end of source? Stop!\n    if (destIndex >= destLength || i >= srcLength) {\n      break;\n    }\n    dest[destIndex] = src[i];\n  }\n  return i;\n}\n\n/**\r\n * Creates and returns an iterator for buf values (bytes)\r\n * @returns {Iterator}\r\n */\n// TODO: Move to SlowBuffer?\nBuffer$1.prototype.values = function () {\n  const buffer = this;\n  let nextIndex = 0;\n  const end = this.length;\n  const myIterator = {\n    next: function () {\n      if (nextIndex < end) {\n        const result = {\n          value: buffer.getAdjustedIndex(nextIndex),\n          done: false\n        };\n        nextIndex++;\n        return result;\n      }\n      return {\n        value: undefined,\n        done: true\n      };\n    },\n    [Symbol.iterator]: function () {\n      return this;\n    }\n  };\n  return myIterator;\n};\n\n/**\r\n * Called when buffer is used in a for..of loop. Delegates to #values()\r\n * @returns {Iterator}\r\n */\n// TODO: Move to SlowBuffer?\nBuffer$1.prototype[Symbol.iterator] = function () {\n  return this.values();\n};\n\n/**\r\n * Writes string to buf at offset according to the character encoding in encoding.\r\n * The length parameter is the number of bytes to write. If buf did not contain enough space to\r\n * fit the entire string, only part of string will be written. However, partially encoded\r\n * characters will not be written.\r\n * @param {string} string String to write to `buf`.\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to write string\r\n * @param {integer} [length=buf.length - offset] Number of bytes to write\r\n * @param {string} [encoding='utf8'] The character encoding of string\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.write = function (string, offset, length, encoding) {\n  if (typeof offset === 'string') {\n    encoding = offset;\n    offset = 0;\n    length = this.length;\n  } else if (typeof length === 'string') {\n    encoding = length;\n    length = this.length - offset;\n  } else {\n    // we cap `length` at the length of our buffer\n    const remaining = this.length - offset;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = encoding || 'utf8';\n  // so we need to convert `remaining` bytes of our string into a byte array/buffer\n  const src = fromString(string, encoding); // FIXME: Can we let it know to only convert `remaining` bytes?\n\n  // then stick that into our buffer starting at `offset`!\n  return src.copy(this, offset, 0, length);\n};\nBuffer$1.prototype.writeDoubleBE = function (value, offset = 0) {\n  checkOffset(this, offset, 8);\n  doubleArray[0] = value;\n  this.setAdjustedIndex(offset++, uint8DoubleArray[7]);\n  this.setAdjustedIndex(offset++, uint8DoubleArray[6]);\n  this.setAdjustedIndex(offset++, uint8DoubleArray[5]);\n  this.setAdjustedIndex(offset++, uint8DoubleArray[4]);\n  this.setAdjustedIndex(offset++, uint8DoubleArray[3]);\n  this.setAdjustedIndex(offset++, uint8DoubleArray[2]);\n  this.setAdjustedIndex(offset++, uint8DoubleArray[1]);\n  this.setAdjustedIndex(offset++, uint8DoubleArray[0]);\n  return offset; // at this point, we should have already added 8 to offset\n};\n\nBuffer$1.prototype.writeDoubleLE = function (value, offset = 0) {\n  checkOffset(this, offset, 8);\n  doubleArray[0] = value;\n  this.setAdjustedIndex(offset++, uint8DoubleArray[0]);\n  this.setAdjustedIndex(offset++, uint8DoubleArray[1]);\n  this.setAdjustedIndex(offset++, uint8DoubleArray[2]);\n  this.setAdjustedIndex(offset++, uint8DoubleArray[3]);\n  this.setAdjustedIndex(offset++, uint8DoubleArray[4]);\n  this.setAdjustedIndex(offset++, uint8DoubleArray[5]);\n  this.setAdjustedIndex(offset++, uint8DoubleArray[6]);\n  this.setAdjustedIndex(offset++, uint8DoubleArray[7]);\n  return offset; // at this point, we should have already added 8 to offset\n};\n\nBuffer$1.prototype.writeFloatBE = function (value, offset = 0) {\n  checkOffset(this, offset, 4);\n  floatArray[0] = value;\n  this.setAdjustedIndex(offset++, uint8FloatArray[3]);\n  this.setAdjustedIndex(offset++, uint8FloatArray[2]);\n  this.setAdjustedIndex(offset++, uint8FloatArray[1]);\n  this.setAdjustedIndex(offset++, uint8FloatArray[0]);\n  return offset; // at this point, we should have already added 4 to offset\n};\n\nBuffer$1.prototype.writeFloatLE = function (value, offset = 0) {\n  checkOffset(this, offset, 4);\n  floatArray[0] = value;\n  this.setAdjustedIndex(offset++, uint8FloatArray[0]);\n  this.setAdjustedIndex(offset++, uint8FloatArray[1]);\n  this.setAdjustedIndex(offset++, uint8FloatArray[2]);\n  this.setAdjustedIndex(offset++, uint8FloatArray[3]);\n  return offset; // at this point, we should have already added 4 to offset\n};\n\n/**\r\n * @param {integer} value Number to be written to buf.\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.writeInt8 = function (value, offset = 0) {\n  checkOffset(this, offset, 1);\n  checkValue(value, -128, 127);\n  if (value >= 0) {\n    // just write it normally\n    this.setAdjustedIndex(offset, value);\n  } else {\n    // convert from signed to 2's complement bits\n    this.setAdjustedIndex(offset, 0xFF + value + 1); // max value, plus the negative number, add one\n  }\n\n  return offset + 1;\n};\n\n/**\r\n * @param {integer} value Number to be written to buf.\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.writeInt16BE = function (value, offset = 0) {\n  checkOffset(this, offset, 2);\n  checkValue(value, -32768, 32767);\n  this.setAdjustedIndex(offset, value >>> 8); // just shift over a byte\n  this.setAdjustedIndex(offset + 1, value & 0xFF); // mask to first byte\n\n  return offset + 2;\n};\n\n/**\r\n * @param {integer} value Number to be written to buf.\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.writeInt16LE = function (value, offset = 0) {\n  checkOffset(this, offset, 2);\n  checkValue(value, -32768, 32767);\n  this.setAdjustedIndex(offset, value & 0xFF);\n  this.setAdjustedIndex(offset + 1, value >>> 8);\n  return offset + 2;\n};\n\n/**\r\n * @param {integer} value Number to be written to buf.\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.writeInt32BE = function (value, offset = 0) {\n  checkOffset(this, offset, 4);\n  checkValue(value, -2147483648, 2147483647);\n  this.setAdjustedIndex(offset, value >>> 24);\n  this.setAdjustedIndex(offset + 1, value >>> 16);\n  this.setAdjustedIndex(offset + 2, value >>> 8);\n  this.setAdjustedIndex(offset + 3, value & 0xFF);\n  return offset + 4;\n};\n\n/**\r\n * @param {integer} value Number to be written to buf.\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.writeInt32LE = function (value, offset = 0) {\n  checkOffset(this, offset, 4);\n  checkValue(value, -2147483648, 2147483647);\n  this.setAdjustedIndex(offset, value & 0xFF);\n  this.setAdjustedIndex(offset + 1, value >>> 8);\n  this.setAdjustedIndex(offset + 2, value >>> 16);\n  this.setAdjustedIndex(offset + 3, value >>> 24);\n  return offset + 4;\n};\n\n/**\r\n * @param {integer} value Number to be written to buf.\r\n * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.\r\n * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.writeIntBE = function (value, offset, byteLength) {\n  if (byteLength <= 0 || byteLength > 6) {\n    throw new RangeError('Index out of range');\n  }\n  checkOffset(this, offset, byteLength);\n  const minMaxBase = Math.pow(2, 8 * byteLength - 1);\n  checkValue(value, -minMaxBase, minMaxBase - 1);\n  if (value < 0) {\n    value = minMaxBase * 2 + value;\n  }\n  let multiplier = 1;\n  for (let i = byteLength - 1; i >= 0; i--) {\n    let byteValue = value / multiplier & 0xFF;\n    this.setAdjustedIndex(offset + i, byteValue);\n    multiplier *= 0x100;\n  }\n  return offset + byteLength;\n};\n\n/**\r\n * @param {integer} value Number to be written to buf.\r\n * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.\r\n * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.writeIntLE = function (value, offset, byteLength) {\n  if (byteLength <= 0 || byteLength > 6) {\n    throw new RangeError('Index out of range');\n  }\n  checkOffset(this, offset, byteLength);\n  const minMaxBase = Math.pow(2, 8 * byteLength - 1);\n  checkValue(value, -minMaxBase, minMaxBase - 1);\n  if (value < 0) {\n    value = minMaxBase * 2 + value;\n  }\n  let multiplier = 1;\n  for (let i = 0; i < byteLength; i++) {\n    let byteValue = value / multiplier & 0xFF;\n    this.setAdjustedIndex(offset + i, byteValue);\n    multiplier *= 0X100;\n  }\n  return offset + byteLength;\n};\n\n/**\r\n * @param {integer} value Number to be written to buf.\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.writeUInt8 = function (value, offset = 0) {\n  checkOffset(this, offset, 1);\n  checkValue(value, 0, 255);\n  this.setAdjustedIndex(offset, value);\n  return offset + 1;\n};\n\n/**\r\n * @param {integer} value Number to be written to buf.\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.writeUInt16BE = function (value, offset = 0) {\n  checkOffset(this, offset, 2);\n  checkValue(value, 0, 65535);\n  this.setAdjustedIndex(offset, value >>> 8);\n  this.setAdjustedIndex(offset + 1, value & 0xff);\n  return offset + 2;\n};\n\n/**\r\n * @param {integer} value Number to be written to buf.\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.writeUInt16LE = function (value, offset = 0) {\n  checkOffset(this, offset, 2);\n  checkValue(value, 0, 65535);\n  this.setAdjustedIndex(offset, value & 0xff);\n  this.setAdjustedIndex(offset + 1, value >>> 8);\n  return offset + 2;\n};\n\n/**\r\n * @param {integer} value Number to be written to buf.\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.writeUInt32BE = function (value, offset = 0) {\n  checkOffset(this, offset, 4);\n  checkValue(value, 0, 4294967295);\n  this.setAdjustedIndex(offset, value >>> 24);\n  this.setAdjustedIndex(offset + 1, value >>> 16);\n  this.setAdjustedIndex(offset + 2, value >>> 8);\n  this.setAdjustedIndex(offset + 3, value & 0xff);\n  return offset + 4;\n};\n\n/**\r\n * @param {integer} value Number to be written to buf.\r\n * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.writeUInt32LE = function (value, offset = 0) {\n  checkOffset(this, offset, 4);\n  checkValue(value, 0, 4294967295);\n  this.setAdjustedIndex(offset, value & 0xff);\n  this.setAdjustedIndex(offset + 1, value >>> 8);\n  this.setAdjustedIndex(offset + 2, value >>> 16);\n  this.setAdjustedIndex(offset + 3, value >>> 24);\n  return offset + 4;\n};\n\n/**\r\n * @param {integer} value Number to be written to buf.\r\n * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.\r\n * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.writeUIntBE = function (value, offset, byteLength) {\n  if (byteLength <= 0 || byteLength > 6) {\n    throw new RangeError('Index out of range');\n  }\n  checkOffset(this, offset, byteLength);\n  checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);\n  let multiplier = 1;\n  for (let i = byteLength - 1; i >= 0; i--) {\n    let byteValue = value / multiplier & 0xFF;\n    this.setAdjustedIndex(offset + i, byteValue);\n    multiplier *= 0X100;\n  }\n  return offset + byteLength;\n};\n\n/**\r\n * @param {integer} value Number to be written to buf.\r\n * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.\r\n * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.\r\n * @returns {integer}\r\n */\nBuffer$1.prototype.writeUIntLE = function (value, offset, byteLength) {\n  if (byteLength <= 0 || byteLength > 6) {\n    throw new RangeError('Index out of range');\n  }\n  checkOffset(this, offset, byteLength);\n  checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);\n  let multiplier = 1;\n  for (let i = 0; i < byteLength; i++) {\n    let byteValue = value / multiplier & 0xFF;\n    this.setAdjustedIndex(offset + i, byteValue);\n    multiplier *= 0X100;\n  }\n  return offset + byteLength;\n};\n\n// TODO: Implement remaining instance methods:\n// buf.lastIndexOf(value[, byteOffset][, encoding])\n// buf.readBigInt64BE([offset])\n// buf.readBigInt64LE([offset])\n// buf.readBigUInt64BE([offset])\n// buf.readBigUInt64LE([offset])\n// buf.writeBigInt64BE(value[, offset])\n// buf.writeBigInt64LE(value[, offset])\n// buf.writeBigUInt64BE(value[, offset])\n// buf.writeBigUInt64LE(value[, offset])\n\n// FIXME: We need to minimize using a backing Ti.Buffer whenever possible, because\n// going back and forth across the bridge for every byte is *very* expensive\n// Ideally we should have a \"SlowBuffer\" that is used when we explicitly wrap a Ti.Buffer\n// So that writes are passed through. Otherwise we should avoid using one at all costs\n// i.e. when we do Buffer.concat and are only doing reads - why do we need a Ti.Buffer?\n// Can we have Ti.Buffer really just wrap a Uint8Array and add it's own methods?\nBuffer$1.allocUnsafe = function (length) {\n  return new FastBuffer(length);\n};\nBuffer$1.allocUnsafeSlow = function (length) {\n  return Buffer$1.allocUnsafe(length);\n};\nBuffer$1.alloc = function (length, fill = 0, encoding = 'utf8') {\n  const buf = Buffer$1.allocUnsafe(length);\n  if (fill !== 0) {\n    buf.fill(fill, encoding);\n  }\n  return buf;\n};\n\n/**\r\n * @param {string|Buffer|TypedArray|DataView|ArrayBuffer|SharedArrayBuffer} string original string\r\n * @param {string} [encoding='utf8'] encoding whose byte length we need to grab\r\n * @returns {integer}\r\n */\nBuffer$1.byteLength = function (string, encoding = 'utf8') {\n  if (typeof string !== 'string') {\n    if (Buffer$1.isBuffer(string)) {\n      return string.length; // return Buffer's length\n    }\n\n    return string.byteLength; // TypedArray, ArrayBuffer, SharedArrayBuffer, DataView\n  }\n\n  let length = string.length;\n  switch (encoding.toLowerCase()) {\n    case 'utf8':\n    case 'utf-8':\n      return utf8ByteLength(string);\n    case 'latin1':\n    case 'binary':\n    case 'ascii':\n      return length;\n    case 'ucs-2':\n    case 'ucs2':\n    case 'utf16le':\n    case 'utf16-le':\n      return 2 * length;\n    case 'hex':\n      return length / 2;\n    case 'base64':\n      // Subtract up to two padding chars from end of string!\n      if (length > 1 && string.charAt(length - 1) === '=') {\n        length--;\n      }\n      if (length > 1 && string.charAt(length - 1) === '=') {\n        length--;\n      }\n      return Math.floor(length * 3 / 4);\n    // drop fractional value\n  }\n\n  return utf8ByteLength(string);\n};\nBuffer$1.compare = function (buf1, buf2) {\n  if (!Buffer$1.isBuffer(buf1)) {\n    throw new TypeError(`The \"buf1\" argument must be one of type Buffer or Uint8Array. Received type ${typeof buf1}`);\n  }\n  // TODO: Wrap UInt8Array args in buffers?\n  return buf1.compare(buf2);\n};\n\n/**\r\n * @param {Buffer[]|UInt8Array[]} list list of Buffers to concatenate\r\n * @param {integer} [totalLength] Total length of the Buffer instances in list when concatenated.\r\n * @returns {Buffer}\r\n */\nBuffer$1.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('list argument must be an Array');\n  }\n  if (list.length === 0) {\n    return new FastBuffer(); // one empty Buffer!\n  }\n  // allocate one Buffer of `totalLength`? Cap at totalLength?\n  if (totalLength === undefined) {\n    totalLength = 0;\n    // generate the total length from each buffer's length?\n    for (let i = 0; i < list.length; i++) {\n      totalLength += list[i].length;\n    }\n  }\n  const result = Buffer$1.allocUnsafe(totalLength);\n  let position = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    buf.copy(result, position);\n    position += buf.length;\n    if (position >= totalLength) {\n      break;\n    }\n  }\n  return result;\n};\n\n/**\r\n * @param {string} encoding possible encoding name\r\n * @returns {boolean}\r\n */\nBuffer$1.isEncoding = function (encoding) {\n  if (typeof encoding !== 'string') {\n    return false;\n  }\n  return VALID_ENCODINGS.includes(encoding.toLowerCase());\n};\n\n/**\r\n * @param {*} obj possible Buffer instance\r\n * @returns {boolean}\r\n */\nBuffer$1.isBuffer = function (obj) {\n  return obj !== null && obj !== undefined && (obj instanceof Buffer$1 || obj[isBuffer] === true);\n};\nlet INSPECT_MAX_BYTES = 50;\n// Override how buffers are presented by util.inspect().\nBuffer$1.prototype[customInspectSymbol] = function (recurseTimes, ctx) {\n  const max = INSPECT_MAX_BYTES;\n  const actualMax = Math.min(max, this.length);\n  const remaining = this.length - max;\n  let str = this.slice(0, actualMax).toString('hex').replace(/(.{2})/g, '$1 ').trim();\n  if (remaining > 0) {\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  }\n  // Inspect special properties as well, if possible.\n  if (ctx) {\n    let extras = false;\n    const filter = ctx.showHidden ? ALL_PROPERTIES$1 : ONLY_ENUMERABLE$1;\n    const obj = getOwnNonIndexProperties(this, filter).reduce((obj, key) => {\n      extras = true;\n      obj[key] = this[key];\n      return obj;\n    }, Object.create(null));\n    if (extras) {\n      if (this.length !== 0) {\n        str += ', ';\n      }\n      // '[Object: null prototype] {'.length === 26\n      // This is guarded with a test.\n      str += inspect(obj, {\n        ...ctx,\n        breakLength: Infinity,\n        compact: true\n      }).slice(27, -2);\n    }\n  }\n  return `<${this.constructor.name} ${str}>`;\n};\nBuffer$1.prototype.inspect = Buffer$1.prototype[customInspectSymbol];\n\n// HACK: ArrayBuffer.isView returns true for Node Buffer, but false for us. Until we can extend Uint8Array, we need to hack this sniffing method\nconst ArrayBufferIsView = ArrayBuffer.isView;\nArrayBuffer.isView = function (thing) {\n  return ArrayBufferIsView(thing) || thing instanceof Buffer$1;\n};\nObject.setPrototypeOf(SlowBuffer.prototype, Buffer$1.prototype);\nObject.setPrototypeOf(SlowBuffer, Buffer$1);\nvar BufferModule = {\n  Buffer: Buffer$1,\n  // TODO: Implement transcode()!\n  transcode: (_source, _fromEncoding, _toEncoding) => {},\n  INSPECT_MAX_BYTES: 50,\n  kMaxLength: 2147483647,\n  kStringMaxLength: 1073741799,\n  constants: {\n    MAX_LENGTH: 2147483647,\n    MAX_STRING_LENGTH: 1073741799\n  }\n};\n\n/**\r\n * Searches a Buffer for the index of a single byte.\r\n * @param {Buffer} buffer buffer to search\r\n * @param {integer} singleByte byte we're looking for\r\n * @param {integer} offset start offset we search at\r\n * @returns {integer}\r\n */\nfunction indexOf(buffer, singleByte, offset) {\n  const length = buffer.length;\n  for (let i = offset; i < length; i++) {\n    if (buffer.getAdjustedIndex(i) === singleByte) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\r\n * This function explicitly avoids bitwise operations because JS assumes 32-bit sequences for those.\r\n * It's possible we may be able to use them when byteLength < 4 if that's faster.\r\n *\r\n * @param {integer} unsignedValue value before converting back to signed\r\n * @param {integer} byteLength number of bytes\r\n * @returns {integer} the signed value that is represented by the unsigned value's bytes\r\n */\nfunction unsignedToSigned(unsignedValue, byteLength) {\n  const bitLength = byteLength * 8;\n  const maxPositiveValue = Math.pow(2, bitLength - 1);\n  if (unsignedValue < maxPositiveValue) {\n    return unsignedValue;\n  }\n  const maxUnsignedValue = Math.pow(2, bitLength);\n  unsignedValue -= maxUnsignedValue;\n  return unsignedValue;\n}\n\n/**\r\n * @param {string} string utf-8 string\r\n * @returns {integer}\r\n */\nfunction utf8ByteLength(string) {\n  // Just convert to a Ti.Buffer and let it tell us the length\n  const buf = Ti.createBuffer({\n    value: string,\n    type: Ti.Codec.CHARSET_UTF8\n  });\n  const length = buf.length;\n  buf.release(); // release the buffer since we just needed the length\n  return length;\n}\n\n/**\r\n * Throws a RangeError if offset is out of bounds\r\n * @param {Buffer} buffer buffer we're operating on\r\n * @param {integer} offset user supplied offset\r\n * @param {integer} byteLength number of bytes needed in range\r\n * @throws {RangeError}\r\n */\nfunction checkOffset(buffer, offset, byteLength) {\n  const endOffset = buffer.length - byteLength;\n  if (offset < 0 || offset > endOffset) {\n    throw new RangeError(`The value of \"offset\" is out of range. It must be >= 0 and <= ${endOffset}. Received ${offset}`);\n  }\n}\n\n/**\r\n * @param {integer} value user-supplied value\r\n * @param {integer} min minimum valid value\r\n * @param {integer} max maximum valid value\r\n * @throws {RangeError}\r\n */\nfunction checkValue(value, min, max) {\n  if (value < min || value > max) {\n    throw new RangeError(`The value of \"value\" is out of range. It must be >= ${min} and <= ${max}. Received ${value}`);\n  }\n}\nlet bufferWarningAlreadyEmitted = false;\nlet nodeModulesCheckCounter = 0;\nconst bufferWarning = 'Buffer() is deprecated due to security and usability ' + 'issues. Please use the Buffer.alloc(), ' + 'Buffer.allocUnsafe(), or Buffer.from() methods instead.';\nfunction showFlaggedDeprecation() {\n  if (bufferWarningAlreadyEmitted || ++nodeModulesCheckCounter > 10000 || isInsideNodeModules()) {\n    // We don't emit a warning, because we either:\n    // - Already did so, or\n    // - Already checked too many times whether a call is coming\n    //   from node_modules and want to stop slowing down things, or\n    // - The code is inside `node_modules`.\n    return;\n  }\n  process.emitWarning(bufferWarning, 'DeprecationWarning', 'DEP0005');\n  bufferWarningAlreadyEmitted = true;\n}\n\n// Copyright Node.js contributors. All rights reserved.\nconst {\n  ALL_PROPERTIES,\n  ONLY_ENUMERABLE\n} = propertyFilter;\nconst BooleanPrototype = Boolean.prototype;\nconst DatePrototype = Date.prototype;\nconst ErrorPrototype = Error.prototype;\nconst NumberPrototype = Number.prototype;\nconst MapPrototype = Map.prototype;\nconst RegExpPrototype = RegExp.prototype;\nconst StringPrototype = String.prototype;\nconst SetPrototype = Set.prototype;\nconst SymbolPrototype = Symbol.prototype;\nconst isIos = ['ipad', 'iphone'].includes(\"android\");\nconst {\n  ERR_INVALID_ARG_TYPE\n} = codes;\nconst hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\nconst propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);\nlet hexSlice = uncurryThis(BufferModule.Buffer.prototype.hexSlice);\nconst builtInObjects = new Set(Object.getOwnPropertyNames(global).filter(e => /^([A-Z][a-z]+)+$/.test(e)));\nconst inspectDefaultOptions = Object.seal({\n  showHidden: false,\n  depth: 2,\n  colors: false,\n  customInspect: true,\n  showProxy: false,\n  maxArrayLength: 100,\n  breakLength: 80,\n  compact: 3,\n  sorted: false,\n  getters: false\n});\nconst kObjectType = 0;\nconst kArrayType = 1;\nconst kArrayExtrasType = 2;\n\n/* eslint-disable no-control-regex */\nconst strEscapeSequencesRegExp = /[\\x00-\\x1f\\x27\\x5c]/;\nconst strEscapeSequencesReplacer = /[\\x00-\\x1f\\x27\\x5c]/g;\nconst strEscapeSequencesRegExpSingle = /[\\x00-\\x1f\\x5c]/;\nconst strEscapeSequencesReplacerSingle = /[\\x00-\\x1f\\x5c]/g;\n/* eslint-enable no-control-regex */\n\nconst keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\nconst numberRegExp = /^(0|[1-9][0-9]*)$/;\nconst nodeModulesRegExp = /[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])/g;\nconst kMinLineLength = 16;\n\n// Constants to map the iterator state.\nconst kWeak = 0;\nconst kIterator = 1;\nconst kMapEntries = 2;\n\n// Escaped special characters. Use empty strings to fill up unused entries.\n/* eslint-disable quotes */\nconst meta = ['\\\\u0000', '\\\\u0001', '\\\\u0002', '\\\\u0003', '\\\\u0004', '\\\\u0005', '\\\\u0006', '\\\\u0007', '\\\\b', '\\\\t', '\\\\n', '\\\\u000b', '\\\\f', '\\\\r', '\\\\u000e', '\\\\u000f', '\\\\u0010', '\\\\u0011', '\\\\u0012', '\\\\u0013', '\\\\u0014', '\\\\u0015', '\\\\u0016', '\\\\u0017', '\\\\u0018', '\\\\u0019', '\\\\u001a', '\\\\u001b', '\\\\u001c', '\\\\u001d', '\\\\u001e', '\\\\u001f', '', '', '', '', '', '', '', \"\\\\'\", '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\\\\\\\\'];\n/* eslint-enable quotes */\n\nfunction getUserOptions(ctx) {\n  const obj = {\n    stylize: ctx.stylize\n  };\n  for (const key of Object.keys(inspectDefaultOptions)) {\n    obj[key] = ctx[key];\n  }\n  if (ctx.userOptions === undefined) {\n    return obj;\n  }\n  return {\n    ...obj,\n    ...ctx.userOptions\n  };\n}\n\n/**\r\n * Echos the value of any input. Tries to print the value out\r\n * in the best way possible given the different types.\r\n *\r\n * @param {any} value The value to print out.\r\n * @param {Object} opts Optional options object that alters the output.\r\n * @return {string} The string representation of `value`\r\n */\nfunction inspect(value, opts) {\n  // Default options\n  const ctx = {\n    budget: {},\n    indentationLvl: 0,\n    seen: [],\n    currentDepth: 0,\n    stylize: stylizeNoColor,\n    showHidden: inspectDefaultOptions.showHidden,\n    depth: inspectDefaultOptions.depth,\n    colors: inspectDefaultOptions.colors,\n    customInspect: inspectDefaultOptions.customInspect,\n    showProxy: inspectDefaultOptions.showProxy,\n    maxArrayLength: inspectDefaultOptions.maxArrayLength,\n    breakLength: inspectDefaultOptions.breakLength,\n    compact: inspectDefaultOptions.compact,\n    sorted: inspectDefaultOptions.sorted,\n    getters: inspectDefaultOptions.getters\n  };\n  if (arguments.length > 1) {\n    // Legacy...\n    if (arguments.length > 2) {\n      if (arguments[2] !== undefined) {\n        ctx.depth = arguments[2];\n      }\n      if (arguments.length > 3 && arguments[3] !== undefined) {\n        ctx.colors = arguments[3];\n      }\n    }\n    // Set user-specified options\n    if (typeof opts === 'boolean') {\n      ctx.showHidden = opts;\n    } else if (opts) {\n      const optKeys = Object.keys(opts);\n      for (const key of optKeys) {\n        // TODO(BridgeAR): Find a solution what to do about stylize. Either make\n        // this function public or add a new API with a similar or better\n        // functionality.\n        if (hasOwnProperty(inspectDefaultOptions, key) || key === 'stylize') {\n          ctx[key] = opts[key];\n        } else if (ctx.userOptions === undefined) {\n          // This is required to pass through the actual user input.\n          ctx.userOptions = opts;\n        }\n      }\n    }\n  }\n  if (ctx.colors) {\n    ctx.stylize = stylizeWithColor;\n  }\n  if (ctx.maxArrayLength === null) {\n    ctx.maxArrayLength = Infinity;\n  }\n  return formatValue(ctx, value, 0);\n}\ninspect.custom = customInspectSymbol;\nObject.defineProperty(inspect, 'defaultOptions', {\n  get() {\n    return inspectDefaultOptions;\n  },\n  set(options) {\n    if (options === null || typeof options !== 'object') {\n      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n    }\n    Object.assign(inspectDefaultOptions, options);\n  }\n});\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = Object.assign(Object.create(null), {\n  bold: [1, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  white: [37, 39],\n  grey: [90, 39],\n  black: [30, 39],\n  blue: [34, 39],\n  cyan: [36, 39],\n  green: [32, 39],\n  magenta: [35, 39],\n  red: [31, 39],\n  yellow: [33, 39]\n});\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = Object.assign(Object.create(null), {\n  special: 'cyan',\n  number: 'yellow',\n  bigint: 'yellow',\n  boolean: 'yellow',\n  undefined: 'grey',\n  null: 'bold',\n  string: 'green',\n  symbol: 'green',\n  date: 'magenta',\n  // \"name\": intentionally not styling\n  regexp: 'red',\n  module: 'underline'\n});\nfunction addQuotes(str, quotes) {\n  if (quotes === -1) {\n    return `\"${str}\"`;\n  }\n  if (quotes === -2) {\n    return `\\`${str}\\``;\n  }\n  return `'${str}'`;\n}\nconst escapeFn = str => meta[str.charCodeAt(0)];\n\n// Escape control characters, single quotes and the backslash.\n// This is similar to JSON stringify escaping.\nfunction strEscape(str) {\n  let escapeTest = strEscapeSequencesRegExp;\n  let escapeReplace = strEscapeSequencesReplacer;\n  let singleQuote = 39;\n\n  // Check for double quotes. If not present, do not escape single quotes and\n  // instead wrap the text in double quotes. If double quotes exist, check for\n  // backticks. If they do not exist, use those as fallback instead of the\n  // double quotes.\n  // eslint-disable-next-line quotes\n  if (str.includes(\"'\")) {\n    // This invalidates the charCode and therefore can not be matched for\n    // anymore.\n    if (!str.includes('\"')) {\n      singleQuote = -1;\n    } else if (!str.includes('`') && !str.includes('${')) {\n      singleQuote = -2;\n    }\n    if (singleQuote !== 39) {\n      escapeTest = strEscapeSequencesRegExpSingle;\n      escapeReplace = strEscapeSequencesReplacerSingle;\n    }\n  }\n\n  // Some magic numbers that worked out fine while benchmarking with v8 6.0\n  if (str.length < 5000 && !escapeTest.test(str)) {\n    return addQuotes(str, singleQuote);\n  }\n  if (str.length > 100) {\n    str = str.replace(escapeReplace, escapeFn);\n    return addQuotes(str, singleQuote);\n  }\n  let result = '';\n  let last = 0;\n  const lastIndex = str.length;\n  for (let i = 0; i < lastIndex; i++) {\n    const point = str.charCodeAt(i);\n    if (point === singleQuote || point === 92 || point < 32) {\n      if (last === i) {\n        result += meta[point];\n      } else {\n        result += `${str.slice(last, i)}${meta[point]}`;\n      }\n      last = i + 1;\n    }\n  }\n  if (last !== lastIndex) {\n    result += str.slice(last);\n  }\n  return addQuotes(result, singleQuote);\n}\nfunction stylizeWithColor(str, styleType) {\n  const style = inspect.styles[styleType];\n  if (style !== undefined) {\n    const color = inspect.colors[style];\n    return `\\u001b[${color[0]}m${str}\\u001b[${color[1]}m`;\n  }\n  return str;\n}\nfunction stylizeNoColor(str) {\n  return str;\n}\n\n// Return a new empty array to push in the results of the default formatter.\nfunction getEmptyFormatArray() {\n  return [];\n}\nfunction getConstructorName(obj, _ctx) {\n  let firstProto;\n  // const tmp = obj;\n  while (obj) {\n    const descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');\n    if (descriptor !== undefined && typeof descriptor.value === 'function' && descriptor.value.name !== '') {\n      return descriptor.value.name;\n    }\n    obj = Object.getPrototypeOf(obj);\n    if (firstProto === undefined) {\n      firstProto = obj;\n    }\n  }\n  if (firstProto === null) {\n    return null;\n  }\n\n  /*\r\n   @todo this calls into native, can we replace this somehow?\r\n  return `${internalGetConstructorName(tmp)} <${inspect(firstProto, {\r\n  \t...ctx,\r\n  \tcustomInspect: false\r\n  })}>`;\r\n  */\n\n  return null;\n}\nfunction getPrefix(constructor, tag, fallback) {\n  if (constructor === null) {\n    if (tag !== '') {\n      return `[${fallback}: null prototype] [${tag}] `;\n    }\n    return `[${fallback}: null prototype] `;\n  }\n  if (tag !== '' && constructor !== tag) {\n    return `${constructor} [${tag}] `;\n  }\n  return `${constructor} `;\n}\n\n// Look up the keys of the object.\nfunction getKeys(value, showHidden) {\n  let keys;\n  const symbols = Object.getOwnPropertySymbols(value);\n  if (showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n    if (symbols.length !== 0) {\n      keys.push(...symbols);\n    }\n  } else {\n    // This might throw if `value` is a Module Namespace Object from an\n    // unevaluated module, but we don't want to perform the actual type\n    // check because it's expensive.\n    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\n    // and modify this logic as needed.\n    try {\n      keys = Object.keys(value);\n    } catch (err) {\n      // @fixme how to du isModuleNamespaceObject?\n      /*\r\n      assert(isNativeError(err) && err.name === 'ReferenceError' &&\r\n      \t\t\t isModuleNamespaceObject(value));\r\n      */\n      keys = Object.getOwnPropertyNames(value);\n    }\n    if (symbols.length !== 0) {\n      keys.push(...symbols.filter(key => propertyIsEnumerable(value, key)));\n    }\n  }\n  return keys;\n}\nfunction getCtxStyle(value, constructor, tag) {\n  let fallback = '';\n  if (constructor === null) {\n    fallback = 'Object';\n  }\n  return getPrefix(constructor, tag, fallback);\n}\nfunction findTypedConstructor(value) {\n  for (const [check, clazz] of [[isUint8Array, Uint8Array], [isUint8ClampedArray, Uint8ClampedArray], [isUint16Array, Uint16Array], [isUint32Array, Uint32Array], [isInt8Array, Int8Array], [isInt16Array, Int16Array], [isInt32Array, Int32Array], [isFloat32Array, Float32Array], [isFloat64Array, Float64Array]]) {\n    if (check(value)) {\n      return clazz;\n    }\n  }\n}\nlet lazyNullPrototypeCache;\n// Creates a subclass and name\n// the constructor as `${clazz} : null prototype`\nfunction clazzWithNullPrototype(clazz, name) {\n  if (lazyNullPrototypeCache === undefined) {\n    lazyNullPrototypeCache = new Map();\n  } else {\n    const cachedClass = lazyNullPrototypeCache.get(clazz);\n    if (cachedClass !== undefined) {\n      return cachedClass;\n    }\n  }\n  class NullPrototype extends clazz {\n    get [Symbol.toStringTag]() {\n      return '';\n    }\n  }\n  Object.defineProperty(NullPrototype.prototype.constructor, 'name', {\n    value: `[${name}: null prototype]`\n  });\n  lazyNullPrototypeCache.set(clazz, NullPrototype);\n  return NullPrototype;\n}\nfunction noPrototypeIterator(ctx, value, recurseTimes) {\n  let newVal;\n  if (isSet(value)) {\n    const clazz = clazzWithNullPrototype(Set, 'Set');\n    newVal = new clazz(SetPrototype.values(value));\n  } else if (isMap(value)) {\n    const clazz = clazzWithNullPrototype(Map, 'Map');\n    newVal = new clazz(MapPrototype.entries(value));\n  } else if (Array.isArray(value)) {\n    const clazz = clazzWithNullPrototype(Array, 'Array');\n    newVal = new clazz(value.length);\n  } else if (isTypedArray(value)) {\n    const constructor = findTypedConstructor(value);\n    const clazz = clazzWithNullPrototype(constructor, constructor.name);\n    newVal = new clazz(value);\n  }\n  if (newVal !== undefined) {\n    Object.defineProperties(newVal, Object.getOwnPropertyDescriptors(value));\n    return formatRaw(ctx, newVal, recurseTimes);\n  }\n}\nfunction formatValue(ctx, value, recurseTimes, typedArray) {\n  // Primitive types cannot have properties.\n  if (typeof value !== 'object' && typeof value !== 'function') {\n    return formatPrimitive(ctx.stylize, value, ctx);\n  }\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n  // Memorize the context for custom inspection on proxies.\n  const context = value;\n  /*\r\n  @fixme check for proxies\r\n  // Always check for proxies to prevent side effects and to prevent triggering\r\n  // any proxy handlers.\r\n  const proxy = getProxyDetails(value);\r\n  if (proxy !== undefined) {\r\n  \tif (ctx.showProxy) {\r\n  \t\treturn formatProxy(ctx, proxy, recurseTimes);\r\n  \t}\r\n  \tvalue = proxy[0];\r\n  }\r\n  */\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it.\n  if (ctx.customInspect) {\n    const maybeCustom = value[customInspectSymbol];\n    if (typeof maybeCustom === 'function'\n    // Filter out the util module, its inspect function is special.\n    && maybeCustom !== inspect\n    // Also filter out any prototype objects using the circular check.\n    && !(value.constructor && value.constructor.prototype === value)) {\n      // This makes sure the recurseTimes are reported as before while using\n      // a counter internally.\n      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;\n      const ret = maybeCustom.call(context, depth, getUserOptions(ctx));\n      // If the custom inspection method returned `this`, don't go into\n      // infinite recursion.\n      if (ret !== context) {\n        if (typeof ret !== 'string') {\n          return formatValue(ctx, ret, recurseTimes);\n        }\n        return ret.replace(/\\n/g, `\\n${' '.repeat(ctx.indentationLvl)}`);\n      }\n    }\n  }\n  // Using an array here is actually better for the average case than using\n  // a Set. `seen` will only check for the depth and will never grow too large.\n  if (ctx.seen.includes(value)) {\n    let index = 1;\n    if (ctx.circular === undefined) {\n      ctx.circular = new Map([[value, index]]);\n    } else {\n      index = ctx.circular.get(value);\n      if (index === undefined) {\n        index = ctx.circular.size + 1;\n        ctx.circular.set(value, index);\n      }\n    }\n    return ctx.stylize(`[Circular *${index}]`, 'special');\n  }\n  return formatRaw(ctx, value, recurseTimes, typedArray);\n}\nfunction formatRaw(ctx, value, recurseTimes, typedArray) {\n  let keys;\n  const constructor = getConstructorName(value);\n  let tag = value[Symbol.toStringTag];\n  // Only list the tag in case it's non-enumerable / not an own property.\n  // Otherwise we'd print this twice.\n  if (typeof tag !== 'string' || tag !== '' && (ctx.showHidden ? hasOwnProperty : propertyIsEnumerable)(value, Symbol.toStringTag)) {\n    tag = '';\n  }\n  let base = '';\n  let formatter = getEmptyFormatArray;\n  let braces;\n  let noIterator = true;\n  let i = 0;\n  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n  let extrasType = kObjectType;\n\n  // Iterators and the rest are split to reduce checks.\n  if (value[Symbol.iterator]) {\n    noIterator = false;\n    if (Array.isArray(value)) {\n      keys = getOwnNonIndexProperties(value, filter);\n      // Only set the constructor for non ordinary (\"Array [...]\") arrays.\n      const prefix = getPrefix(constructor, tag, 'Array');\n      braces = [`${prefix === 'Array ' ? '' : prefix}[`, ']'];\n      if (value.length === 0 && keys.length === 0) {\n        return `${braces[0]}]`;\n      }\n      extrasType = kArrayExtrasType;\n      formatter = formatArray;\n    } else if (isSet(value)) {\n      keys = getKeys(value, ctx.showHidden);\n      const prefix = getPrefix(constructor, tag, 'Set');\n      if (value.size === 0 && keys.length === 0) {\n        return `${prefix}{}`;\n      }\n      braces = [`${prefix}{`, '}'];\n      formatter = formatSet;\n    } else if (isMap(value)) {\n      keys = getKeys(value, ctx.showHidden);\n      const prefix = getPrefix(constructor, tag, 'Map');\n      if (value.size === 0 && keys.length === 0) {\n        return `${prefix}{}`;\n      }\n      braces = [`${prefix}{`, '}'];\n      formatter = formatMap;\n    } else if (isTypedArray(value)) {\n      keys = getOwnNonIndexProperties(value, filter);\n      const prefix = constructor !== null ? getPrefix(constructor, tag) : getPrefix(constructor, tag, findTypedConstructor(value).name);\n      braces = [`${prefix}[`, ']'];\n      if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {\n        return `${braces[0]}]`;\n      }\n      formatter = formatTypedArray;\n      extrasType = kArrayExtrasType;\n    } else if (isMapIterator(value)) {\n      keys = getKeys(value, ctx.showHidden);\n      braces = getIteratorBraces('Map', tag);\n      formatter = formatIterator;\n    } else if (isSetIterator(value)) {\n      keys = getKeys(value, ctx.showHidden);\n      braces = getIteratorBraces('Set', tag);\n      formatter = formatIterator;\n    } else {\n      noIterator = true;\n    }\n  }\n  if (noIterator) {\n    keys = getKeys(value, ctx.showHidden);\n    braces = ['{', '}'];\n    if (constructor === 'Object') {\n      if (isArgumentsObject(value)) {\n        braces[0] = '[Arguments] {';\n      } else if (tag !== '') {\n        braces[0] = `${getPrefix(constructor, tag, 'Object')}{`;\n      }\n      if (keys.length === 0) {\n        return `${braces[0]}}`;\n      }\n    } else if (typeof value === 'function') {\n      base = getFunctionBase(value, constructor, tag);\n      if (keys.length === 0) {\n        return ctx.stylize(base, 'special');\n      }\n    } else if (isRegExp(value)) {\n      // Make RegExps say that they are RegExps\n      // eslint-disable-next-line security/detect-non-literal-regexp\n      const regExp = constructor !== null ? value : new RegExp(value);\n      base = RegExpPrototype.toString.call(regExp);\n      const prefix = getPrefix(constructor, tag, 'RegExp');\n      if (prefix !== 'RegExp ') {\n        base = `${prefix}${base}`;\n      }\n      if (keys.length === 0 || recurseTimes > ctx.depth && ctx.depth !== null) {\n        return ctx.stylize(base, 'regexp');\n      }\n    } else if (isDate(value)) {\n      // Make dates with properties first say the date\n      base = Number.isNaN(DatePrototype.getTime.call(value)) ? DatePrototype.toString.call(value) : DatePrototype.toISOString.call(value);\n      const prefix = getPrefix(constructor, tag, 'Date');\n      if (prefix !== 'Date ') {\n        base = `${prefix}${base}`;\n      }\n      if (keys.length === 0) {\n        return ctx.stylize(base, 'date');\n      }\n    } else if (isError(value)) {\n      base = formatError(value, constructor, tag, ctx);\n      if (keys.length === 0) {\n        return base;\n      } else if (isIos) {\n        const nativeErrorProps = ['line', 'column', 'sourceURL'];\n        if (keys.every(key => nativeErrorProps.includes(key))) {\n          return base;\n        }\n      }\n    } else if (isAnyArrayBuffer(value)) {\n      // Fast path for ArrayBuffer and SharedArrayBuffer.\n      // Can't do the same for DataView because it has a non-primitive\n      // .buffer property that we need to recurse for.\n      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' : 'SharedArrayBuffer';\n      const prefix = getPrefix(constructor, tag, arrayType);\n      if (typedArray === undefined) {\n        formatter = formatArrayBuffer;\n      } else if (keys.length === 0) {\n        return `${prefix}{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;\n      }\n      braces[0] = `${prefix}{`;\n      keys.unshift('byteLength');\n    } else if (isDataView(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'DataView')}{`;\n      // .buffer goes last, it's not a primitive like the others.\n      keys.unshift('byteLength', 'byteOffset', 'buffer');\n    } else if (isPromise(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'Promise')}{`;\n      formatter = formatPromise;\n    } else if (isWeakSet(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'WeakSet')}{`;\n      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\n    } else if (isWeakMap(value)) {\n      braces[0] = `${getPrefix(constructor, tag, 'WeakMap')}{`;\n      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\n      /*\r\n       * @fixme how to do isModuleNamespaceObject?\r\n      } else if (isModuleNamespaceObject(value)) {\r\n      \tbraces[0] = `[${tag}] {`;\r\n      \tformatter = formatNamespaceObject;\r\n      */\n    } else if (isBoxedPrimitive(value)) {\n      base = getBoxedBase(value, ctx, keys, constructor, tag);\n      if (keys.length === 0) {\n        return base;\n      }\n    } else {\n      // The input prototype got manipulated. Special handle these. We have to\n      // rebuild the information so we are able to display everything.\n      if (constructor === null) {\n        const specialIterator = noPrototypeIterator(ctx, value, recurseTimes);\n        if (specialIterator) {\n          return specialIterator;\n        }\n      }\n      if (isMapIterator(value)) {\n        braces = getIteratorBraces('Map', tag);\n        formatter = formatIterator;\n      } else if (isSetIterator(value)) {\n        braces = getIteratorBraces('Set', tag);\n        formatter = formatIterator;\n        // Handle other regular objects again.\n      } else {\n        if (keys.length === 0) {\n          return `${getCtxStyle(value, constructor, tag)}{}`;\n        }\n        braces[0] = `${getCtxStyle(value, constructor, tag)}{`;\n      }\n    }\n  }\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);\n    if (constructor !== null) {\n      constructorName = `[${constructorName}]`;\n    }\n    return ctx.stylize(constructorName, 'special');\n  }\n  recurseTimes += 1;\n  ctx.seen.push(value);\n  ctx.currentDepth = recurseTimes;\n  let output;\n  const indentationLvl = ctx.indentationLvl;\n  try {\n    output = formatter(ctx, value, recurseTimes, keys, braces);\n    for (i = 0; i < keys.length; i++) {\n      output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));\n    }\n  } catch (err) {\n    const constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);\n    return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);\n  }\n  if (ctx.circular !== undefined) {\n    const index = ctx.circular.get(value);\n    if (index !== undefined) {\n      const reference = ctx.stylize(`<ref *${index}>`, 'special');\n      // Add reference always to the very beginning of the output.\n      if (ctx.compact !== true) {\n        base = base === '' ? reference : `${reference} ${base}`;\n      } else {\n        braces[0] = `${reference} ${braces[0]}`;\n      }\n    }\n  }\n  ctx.seen.pop();\n  if (ctx.sorted) {\n    const comparator = ctx.sorted === true ? undefined : ctx.sorted;\n    if (extrasType === kObjectType) {\n      output = output.sort(comparator);\n    } else if (keys.length > 1) {\n      const sorted = output.slice(output.length - keys.length).sort(comparator);\n      output.splice(output.length - keys.length, keys.length, ...sorted);\n    }\n  }\n  const res = reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value);\n  const budget = ctx.budget[ctx.indentationLvl] || 0;\n  const newLength = budget + res.length;\n  ctx.budget[ctx.indentationLvl] = newLength;\n  // If any indentationLvl exceeds this limit, limit further inspecting to the\n  // minimum. Otherwise the recursive algorithm might continue inspecting the\n  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\n  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\n  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\n  // This limit also makes sure that huge objects don't block the event loop\n  // significantly.\n  if (newLength > 2 ** 27) {\n    ctx.depth = -1;\n  }\n  return res;\n}\nfunction getIteratorBraces(type, tag) {\n  if (tag !== `${type} Iterator`) {\n    if (tag !== '') {\n      tag += '] [';\n    }\n    tag += `${type} Iterator`;\n  }\n  return [`[${tag}] {`, '}'];\n}\nfunction getBoxedBase(value, ctx, keys, constructor, tag) {\n  let fn;\n  let type;\n  if (isNumberObject(value)) {\n    fn = NumberPrototype;\n    type = 'Number';\n  } else if (isStringObject(value)) {\n    fn = StringPrototype;\n    type = 'String';\n    // For boxed Strings, we have to remove the 0-n indexed entries,\n    // since they just noisy up the output and are redundant\n    // Make boxed primitive Strings look like such\n    keys.splice(0, value.length);\n  } else if (isBooleanObject(value)) {\n    fn = BooleanPrototype;\n    type = 'Boolean';\n  } else {\n    fn = SymbolPrototype;\n    type = 'Symbol';\n  }\n  let base = `[${type}`;\n  if (type !== constructor) {\n    if (constructor === null) {\n      base += ' (null prototype)';\n    } else {\n      base += ` (${constructor})`;\n    }\n  }\n  base += `: ${formatPrimitive(stylizeNoColor, fn.valueOf(value), ctx)}]`;\n  if (tag !== '' && tag !== constructor) {\n    base += ` [${tag}]`;\n  }\n  if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {\n    return base;\n  }\n  return ctx.stylize(base, type.toLowerCase());\n}\nfunction getFunctionBase(value, constructor, tag) {\n  let type = 'Function';\n  if (isGeneratorFunction(value)) {\n    type = `Generator${type}`;\n  }\n  if (isAsyncFunction(value)) {\n    type = `Async${type}`;\n  }\n  let base = `[${type}`;\n  if (constructor === null) {\n    base += ' (null prototype)';\n  }\n  if (value.name === '') {\n    base += ' (anonymous)';\n  } else {\n    base += `: ${value.name}`;\n  }\n  base += ']';\n  if (constructor !== type && constructor !== null) {\n    base += ` ${constructor}`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  return base;\n}\nfunction formatError(err, constructor, tag, ctx) {\n  let stack = err.stack || ErrorPrototype.toString.call(err);\n  // try to normalize JavaScriptCore stack to match v8\n  if (isIos) {\n    const lines = stack.split('\\n');\n    stack = `${err.name}: ${err.message}`;\n    if (lines.length > 0) {\n      stack += lines.map(stackLine => {\n        const atSymbolIndex = stackLine.indexOf('@');\n        const source = stackLine.slice(atSymbolIndex + 1);\n        const sourcePattern = /(.*):(\\d+):(\\d+)/;\n        let symbolName = 'unknown';\n        if (atSymbolIndex !== -1) {\n          symbolName = stackLine.slice(0, atSymbolIndex);\n        }\n        const sourceMatch = source.match(sourcePattern);\n        if (sourceMatch) {\n          let filePath = sourceMatch[1];\n          const lineNumber = sourceMatch[2];\n          const column = sourceMatch[3];\n          if (filePath.startsWith('file:')) {\n            filePath = filePath.replace(`file://${Ti.Filesystem.resourcesDirectory}`, '');\n          }\n          return `\\n    at ${symbolName} (${filePath}:${lineNumber}:${column})`;\n        } else {\n          return `\\n    at ${symbolName} (${source})`;\n        }\n      }).join('');\n    }\n  }\n\n  // A stack trace may contain arbitrary data. Only manipulate the output\n  // for \"regular errors\" (errors that \"look normal\") for now.\n  const name = err.name || 'Error';\n  let len = name.length;\n  if (constructor === null || name.endsWith('Error') && stack.startsWith(name) && (stack.length === len || stack[len] === ':' || stack[len] === '\\n')) {\n    let fallback = 'Error';\n    if (constructor === null) {\n      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\\]()-]+)(?::|\\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);\n      fallback = start && start[1] || '';\n      len = fallback.length;\n      fallback = fallback || 'Error';\n    }\n    const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);\n    if (name !== prefix) {\n      if (prefix.includes(name)) {\n        if (len === 0) {\n          stack = `${prefix}: ${stack}`;\n        } else {\n          stack = `${prefix}${stack.slice(len)}`;\n        }\n      } else {\n        stack = `${prefix} [${name}]${stack.slice(len)}`;\n      }\n    }\n  }\n\n  // Ignore the error message if it's contained in the stack.\n  let pos = err.message && stack.indexOf(err.message) || -1;\n  if (pos !== -1) {\n    pos += err.message.length;\n  }\n  // Wrap the error in brackets in case it has no stack trace.\n  let stackStart = stack.indexOf('\\n    at', pos);\n  if (stackStart === -1) {\n    stack = `[${stack}]`;\n  } else if (ctx.colors) {\n    // Highlight userland code and node modules.\n    let newStack = stack.slice(0, stackStart);\n    const lines = stack.slice(stackStart + 1).split('\\n');\n    for (const line of lines) {\n      // This adds underscores to all node_modules to quickly identify them.\n      let nodeModule;\n      newStack += '\\n';\n      let pos = 0;\n      while (nodeModule = nodeModulesRegExp.exec(line)) {\n        // '/node_modules/'.length === 14\n        newStack += line.slice(pos, nodeModule.index + 14);\n        newStack += ctx.stylize(nodeModule[1], 'module');\n        pos = nodeModule.index + nodeModule[0].length;\n      }\n      newStack += pos === 0 ? line : line.slice(pos);\n    }\n    stack = newStack;\n  }\n  // The message and the stack have to be indented as well!\n  if (ctx.indentationLvl !== 0) {\n    const indentation = ' '.repeat(ctx.indentationLvl);\n    stack = stack.replace(/\\n/g, `\\n${indentation}`);\n  }\n  return stack;\n}\nfunction formatPromise(ctx, _value, _recurseTimes) {\n  // Node calls into native to get promise details which we can't do\n  return [ctx.stylize('<unknown>', 'special')];\n}\nfunction formatProperty(ctx, value, recurseTimes, key, type) {\n  let name, str;\n  let extra = ' ';\n  const desc = Object.getOwnPropertyDescriptor(value, key) || {\n    value: value[key],\n    enumerable: true\n  };\n  if (desc.value !== undefined) {\n    const diff = type !== kObjectType || ctx.compact !== true ? 2 : 3;\n    ctx.indentationLvl += diff;\n    str = formatValue(ctx, desc.value, recurseTimes);\n    if (diff === 3) {\n      const len = ctx.colors ? removeColors(str).length : str.length;\n      if (ctx.breakLength < len) {\n        extra = `\\n${' '.repeat(ctx.indentationLvl)}`;\n      }\n    }\n    ctx.indentationLvl -= diff;\n  } else if (desc.get !== undefined) {\n    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';\n    const s = ctx.stylize;\n    const sp = 'special';\n    if (ctx.getters && (ctx.getters === true || ctx.getters === 'get' && desc.set === undefined || ctx.getters === 'set' && desc.set !== undefined)) {\n      try {\n        const tmp = value[key];\n        ctx.indentationLvl += 2;\n        if (tmp === null) {\n          str = `${s(`[${label}:`, sp)} ${s('null', 'null')}${s(']', sp)}`;\n        } else if (typeof tmp === 'object') {\n          str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;\n        } else {\n          const primitive = formatPrimitive(s, tmp, ctx);\n          str = `${s(`[${label}:`, sp)} ${primitive}${s(']', sp)}`;\n        }\n        ctx.indentationLvl -= 2;\n      } catch (err) {\n        const message = `<Inspection threw (${err.message})>`;\n        str = `${s(`[${label}:`, sp)} ${message}${s(']', sp)}`;\n      }\n    } else {\n      str = ctx.stylize(`[${label}]`, sp);\n    }\n  } else if (desc.set !== undefined) {\n    str = ctx.stylize('[Setter]', 'special');\n  } else {\n    str = ctx.stylize('undefined', 'undefined');\n  }\n  if (type === kArrayType) {\n    return str;\n  }\n  if (typeof key === 'symbol') {\n    const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);\n    name = `[${ctx.stylize(tmp, 'symbol')}]`;\n  } else if (desc.enumerable === false) {\n    name = `[${key.replace(strEscapeSequencesReplacer, escapeFn)}]`;\n  } else if (keyStrRegExp.test(key)) {\n    name = ctx.stylize(key, 'name');\n  } else {\n    name = ctx.stylize(strEscape(key), 'string');\n  }\n  return `${name}:${extra}${str}`;\n}\nfunction groupArrayElements(ctx, output, value) {\n  let totalLength = 0;\n  let maxLength = 0;\n  let i = 0;\n  let outputLength = output.length;\n  if (ctx.maxArrayLength < output.length) {\n    // This makes sure the \"... n more items\" part is not taken into account.\n    outputLength--;\n  }\n  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.\n  const dataLen = new Array(outputLength);\n  // Calculate the total length of all output entries and the individual max\n  // entries length of all output entries. We have to remove colors first,\n  // otherwise the length would not be calculated properly.\n  for (; i < outputLength; i++) {\n    const len = ctx.colors ? removeColors(output[i]).length : output[i].length;\n    dataLen[i] = len;\n    totalLength += len + separatorSpace;\n    if (maxLength < len) {\n      maxLength = len;\n    }\n  }\n  // Add two to `maxLength` as we add a single whitespace character plus a comma\n  // in-between two entries.\n  const actualMax = maxLength + separatorSpace;\n  // Check if at least three entries fit next to each other and prevent grouping\n  // of arrays that contains entries of very different length (i.e., if a single\n  // entry is longer than 1/5 of all other entries combined). Otherwise the\n  // space in-between small entries would be enormous.\n  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {\n    const approxCharHeights = 2.5;\n    const averageBias = Math.sqrt(actualMax - totalLength / output.length);\n    const biasedMax = Math.max(actualMax - 3 - averageBias, 1);\n    // Dynamically check how many columns seem possible.\n    const columns = Math.min(\n    // Ideally a square should be drawn. We expect a character to be about 2.5\n    // times as high as wide. This is the area formula to calculate a square\n    // which contains n rectangles of size `actualMax * approxCharHeights`.\n    // Divide that by `actualMax` to receive the correct number of columns.\n    // The added bias increases the columns for short entries.\n    Math.round(Math.sqrt(approxCharHeights * biasedMax * outputLength) / biasedMax),\n    // Do not exceed the breakLength.\n    Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax),\n    // Limit array grouping for small `compact` modes as the user requested\n    // minimal grouping.\n    ctx.compact * 4,\n    // Limit the columns to a maximum of fifteen.\n    15);\n    // Return with the original output if no grouping should happen.\n    if (columns <= 1) {\n      return output;\n    }\n    const tmp = [];\n    const maxLineLength = [];\n    for (let i = 0; i < columns; i++) {\n      let lineMaxLength = 0;\n      for (let j = i; j < output.length; j += columns) {\n        if (dataLen[j] > lineMaxLength) {\n          lineMaxLength = dataLen[j];\n        }\n      }\n      lineMaxLength += separatorSpace;\n      maxLineLength[i] = lineMaxLength;\n    }\n    let order = 'padStart';\n    if (value !== undefined) {\n      for (let i = 0; i < output.length; i++) {\n        if (typeof value[i] !== 'number') {\n          order = 'padEnd';\n          break;\n        }\n      }\n    }\n    // Each iteration creates a single line of grouped entries.\n    for (let i = 0; i < outputLength; i += columns) {\n      // The last lines may contain less entries than columns.\n      const max = Math.min(i + columns, outputLength);\n      let str = '';\n      let j = i;\n      for (; j < max - 1; j++) {\n        // Calculate extra color padding in case it's active. This has to be\n        // done line by line as some lines might contain more colors than\n        // others.\n        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];\n        str += `${output[j]}, `[order](padding, ' ');\n      }\n      if (order === 'padStart') {\n        const padding = maxLineLength[j - i] + output[j].length - dataLen[j] - separatorSpace;\n        str += output[j].padStart(padding, ' ');\n      } else {\n        str += output[j];\n      }\n      tmp.push(str);\n    }\n    if (ctx.maxArrayLength < output.length) {\n      tmp.push(output[outputLength]);\n    }\n    output = tmp;\n  }\n  return output;\n}\nfunction handleMaxCallStackSize(ctx, err, constructorName, indentationLvl) {\n  if (isStackOverflowError(err)) {\n    ctx.seen.pop();\n    ctx.indentationLvl = indentationLvl;\n    return ctx.stylize(`[${constructorName}: Inspection interrupted 'prematurely. Maximum call stack size exceeded.]`, 'special');\n  }\n  throw err;\n}\nfunction formatNumber(fn, value) {\n  // Format -0 as '-0'. Checking `value === -0` won't distinguish 0 from -0.\n  return fn(Object.is(value, -0) ? '-0' : `${value}`, 'number');\n}\nfunction formatBigInt(fn, value) {\n  return fn(`${value}n`, 'bigint');\n}\nfunction formatPrimitive(fn, value, ctx) {\n  if (typeof value === 'string') {\n    if (ctx.compact !== true && value.length > kMinLineLength && value.length > ctx.breakLength - ctx.indentationLvl - 4) {\n      return value.split(/\\n/).map(line => fn(strEscape(line), 'string')).join(` +\\n${' '.repeat(ctx.indentationLvl + 2)}`);\n    }\n    return fn(strEscape(value), 'string');\n  }\n  if (typeof value === 'number') {\n    return formatNumber(fn, value);\n  }\n  /*\r\n  if (typeof value === 'bigint') {\r\n  \treturn formatBigInt(fn, value);\r\n  }\r\n  */\n  if (typeof value === 'boolean') {\n    return fn(`${value}`, 'boolean');\n  }\n  if (typeof value === 'undefined') {\n    return fn('undefined', 'undefined');\n  }\n  // es6 symbol primitive\n  return fn(SymbolPrototype.toString.call(value), 'symbol');\n}\n\n// The array is sparse and/or has extra keys\nfunction formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {\n  const keys = Object.keys(value);\n  let index = i;\n  for (; i < keys.length && output.length < maxLength; i++) {\n    const key = keys[i];\n    const tmp = +key;\n    // Arrays can only have up to 2^32 - 1 entries\n    if (tmp > 2 ** 32 - 2) {\n      break;\n    }\n    if (`${index}` !== key) {\n      if (!numberRegExp.test(key)) {\n        break;\n      }\n      const emptyItems = tmp - index;\n      const ending = emptyItems > 1 ? 's' : '';\n      const message = `<${emptyItems} empty item${ending}>`;\n      output.push(ctx.stylize(message, 'undefined'));\n      index = tmp;\n      if (output.length === maxLength) {\n        break;\n      }\n    }\n    output.push(formatProperty(ctx, value, recurseTimes, key, kArrayType));\n    index++;\n  }\n  const remaining = value.length - index;\n  if (output.length !== maxLength) {\n    if (remaining > 0) {\n      const ending = remaining > 1 ? 's' : '';\n      const message = `<${remaining} empty item${ending}>`;\n      output.push(ctx.stylize(message, 'undefined'));\n    }\n  } else if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\nfunction formatArrayBuffer(ctx, value) {\n  const buffer = new Uint8Array(value);\n  /*\r\n  // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?\r\n  if (hexSlice === undefined) {\r\n  \thexSlice = uncurryThis(require('../../buffer').default.Buffer.prototype.hexSlice);\r\n  }\r\n  */\n  let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, '$1 ').trim();\n  const remaining = buffer.length - ctx.maxArrayLength;\n  if (remaining > 0) {\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  }\n  return [`${ctx.stylize('[Uint8Contents]', 'special')}: <${str}>`];\n}\nfunction formatArray(ctx, value, recurseTimes) {\n  const valLen = value.length;\n  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);\n  const remaining = valLen - len;\n  const output = [];\n  for (var i = 0; i < len; i++) {\n    // Special handle sparse arrays.\n    if (!hasOwnProperty(value, i)) {\n      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);\n    }\n    output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));\n  }\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\nfunction formatTypedArray(ctx, value, recurseTimes) {\n  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);\n  const remaining = value.length - maxLength;\n  const output = new Array(maxLength);\n  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ? formatNumber : formatBigInt;\n  for (let i = 0; i < maxLength; ++i) {\n    output[i] = elementFormatter(ctx.stylize, value[i]);\n  }\n  if (remaining > 0) {\n    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\n  }\n  if (ctx.showHidden) {\n    // .buffer goes last, it's not a primitive like the others.\n    ctx.indentationLvl += 2;\n    for (const key of ['BYTES_PER_ELEMENT', 'length', 'byteLength', 'byteOffset', 'buffer']) {\n      const str = formatValue(ctx, value[key], recurseTimes, true);\n      output.push(`[${key}]: ${str}`);\n    }\n    ctx.indentationLvl -= 2;\n  }\n  return output;\n}\nfunction formatSet(ctx, value, recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const v of value) {\n    output.push(formatValue(ctx, v, recurseTimes));\n  }\n  ctx.indentationLvl -= 2;\n  // With `showHidden`, `length` will display as a hidden property for\n  // arrays. For consistency's sake, do the same for `size`, even though this\n  // property isn't selected by Object.getOwnPropertyNames().\n  if (ctx.showHidden) {\n    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);\n  }\n  return output;\n}\nfunction formatMap(ctx, value, recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const [k, v] of value) {\n    output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);\n  }\n  ctx.indentationLvl -= 2;\n  // See comment in formatSet\n  if (ctx.showHidden) {\n    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);\n  }\n  return output;\n}\nfunction formatSetIterInner(ctx, recurseTimes, entries, state) {\n  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);\n  const maxLength = Math.min(maxArrayLength, entries.length);\n  let output = new Array(maxLength);\n  ctx.indentationLvl += 2;\n  for (var i = 0; i < maxLength; i++) {\n    output[i] = formatValue(ctx, entries[i], recurseTimes);\n  }\n  ctx.indentationLvl -= 2;\n  if (state === kWeak && !ctx.sorted) {\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist, we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    output = output.sort();\n  }\n  const remaining = entries.length - maxLength;\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\nfunction formatMapIterInner(ctx, recurseTimes, entries, state) {\n  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);\n  // Entries exist as [key1, val1, key2, val2, ...]\n  const len = entries.length / 2;\n  const remaining = len - maxArrayLength;\n  const maxLength = Math.min(maxArrayLength, len);\n  let output = new Array(maxLength);\n  let i = 0;\n  ctx.indentationLvl += 2;\n  if (state === kWeak) {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      output[i] = `${formatValue(ctx, entries[pos], recurseTimes)}` + ` => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;\n    }\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist, we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    if (!ctx.sorted) {\n      output = output.sort();\n    }\n  } else {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      const res = [formatValue(ctx, entries[pos], recurseTimes), formatValue(ctx, entries[pos + 1], recurseTimes)];\n      output[i] = reduceToSingleString(ctx, res, '', ['[', ']'], kArrayExtrasType, recurseTimes);\n    }\n  }\n  ctx.indentationLvl -= 2;\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\nfunction formatWeakCollection(ctx) {\n  return [ctx.stylize('<items unknown>', 'special')];\n}\nfunction formatWeakSet(ctx, _value, _recurseTimes) {\n  // Node calls into native to get a preview of actual values which we can't do\n  return formatWeakCollection(ctx);\n}\nfunction formatWeakMap(ctx, _value, _recurseTimes) {\n  // Node calls into native to get a preview of actual values which we can't do\n  return formatWeakCollection(ctx);\n}\nfunction formatIterator(ctx, value, recurseTimes, _keys, braces) {\n  const entries = [];\n  let isKeyValue = false;\n  let result = value.next();\n  while (!result.done) {\n    const currentEntry = result.value;\n    entries.push(currentEntry);\n    if (currentEntry[0] !== currentEntry[1]) {\n      isKeyValue = true;\n    }\n    result = value.next();\n  }\n  if (isKeyValue) {\n    // Mark entry iterators as such.\n    braces[0] = braces[0].replace(/ Iterator] {$/, ' Entries] {');\n    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);\n  }\n  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);\n}\nfunction isBelowBreakLength(ctx, output, start, base) {\n  // Each entry is separated by at least a comma. Thus, we start with a total\n  // length of at least `output.length`. In addition, some cases have a\n  // whitespace in-between each other that is added to the total as well.\n  let totalLength = output.length + start;\n  if (totalLength + output.length > ctx.breakLength) {\n    return false;\n  }\n  for (var i = 0; i < output.length; i++) {\n    if (ctx.colors) {\n      totalLength += removeColors(output[i]).length;\n    } else {\n      totalLength += output[i].length;\n    }\n    if (totalLength > ctx.breakLength) {\n      return false;\n    }\n  }\n  // Do not line up properties on the same line if `base` contains line breaks.\n  return base === '' || !base.includes('\\n');\n}\nfunction reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value) {\n  if (ctx.compact !== true) {\n    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {\n      // Memorize the original output length. In case the the output is grouped,\n      // prevent lining up the entries on a single line.\n      const entries = output.length;\n      // Group array elements together if the array contains at least six\n      // separate entries.\n      if (extrasType === kArrayExtrasType && entries > 6) {\n        output = groupArrayElements(ctx, output, value);\n      }\n      // `ctx.currentDepth` is set to the most inner depth of the currently\n      // inspected object part while `recurseTimes` is the actual current depth\n      // that is inspected.\n      //\n      // Example:\n      //\n      // const a = { first: [ 1, 2, 3 ], second: { inner: [ 1, 2, 3 ] } }\n      //\n      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max\n      // depth of 1.\n      //\n      // Consolidate all entries of the local most inner depth up to\n      // `ctx.compact`, as long as the properties are smaller than\n      // `ctx.breakLength`.\n      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {\n        // Line up all entries on a single line in case the entries do not\n        // exceed `breakLength`. Add 10 as constant to start next to all other\n        // factors that may reduce `breakLength`.\n        const start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;\n        if (isBelowBreakLength(ctx, output, start, base)) {\n          return `${base ? `${base} ` : ''}${braces[0]} ${join$1(output, ', ')} ${braces[1]}`;\n        }\n      }\n    }\n    // Line up each entry on an individual line.\n    const indentation = `\\n${' '.repeat(ctx.indentationLvl)}`;\n    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` + `${join$1(output, `,${indentation}  `)}${indentation}${braces[1]}`;\n  }\n  // Line up all entries on a single line in case the entries do not exceed\n  // `breakLength`.\n  if (isBelowBreakLength(ctx, output, 0, base)) {\n    return `${braces[0]}${base ? ` ${base}` : ''} ${join$1(output, ', ')} ` + braces[1];\n  }\n  const indentation = ' '.repeat(ctx.indentationLvl);\n  // If the opening \"brace\" is too large, like in the case of \"Set {\",\n  // we need to force the first item to be on the next line or the\n  // items will not line up correctly.\n  const ln = base === '' && braces[0].length === 1 ? ' ' : `${base ? ` ${base}` : ''}\\n${indentation}  `;\n  // Line up each entry on an individual line.\n  return `${braces[0]}${ln}${join$1(output, `,\\n${indentation}  `)} ${braces[1]}`;\n}\nfunction format$1(...args) {\n  return formatWithOptions(undefined, ...args);\n}\nconst firstErrorLine = error => error.message.split('\\n')[0];\nlet CIRCULAR_ERROR_MESSAGE;\nfunction tryStringify(arg) {\n  try {\n    return JSON.stringify(arg);\n  } catch (err) {\n    // Populate the circular error message lazily\n    if (!CIRCULAR_ERROR_MESSAGE) {\n      try {\n        const a = {};\n        a.a = a;\n        JSON.stringify(a);\n      } catch (e) {\n        CIRCULAR_ERROR_MESSAGE = firstErrorLine(e);\n      }\n    }\n    if (err.name === 'TypeError' && firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {\n      return '[Circular]';\n    }\n    throw err;\n  }\n}\n\n/* eslint-disable max-depth */\nfunction formatWithOptions(inspectOptions, ...args) {\n  const first = args[0];\n  let a = 0;\n  let str = '';\n  let join = '';\n  if (typeof first === 'string') {\n    if (args.length === 1) {\n      return first;\n    }\n    let tempStr;\n    let lastPos = 0;\n    for (var i = 0; i < first.length - 1; i++) {\n      if (first.charCodeAt(i) === 37) {\n        // '%'\n        const nextChar = first.charCodeAt(++i);\n        if (a + 1 !== args.length) {\n          switch (nextChar) {\n            case 115:\n              // 's'\n              const tempArg = args[++a];\n              if (typeof tempArg === 'number') {\n                tempStr = formatNumber(stylizeNoColor, tempArg);\n                /*\r\n                } else if (typeof tempArg === 'bigint') {\r\n                \ttempStr = `${tempArg}n`;\r\n                */\n              } else {\n                let constr;\n                if (typeof tempArg !== 'object' || tempArg === null || typeof tempArg.toString === 'function' && (hasOwnProperty(tempArg, 'toString')\n                // A direct own property on the constructor prototype in\n                // case the constructor is not an built-in object.\n                || (constr = tempArg.constructor) && !builtInObjects.has(constr.name) && constr.prototype && hasOwnProperty(constr.prototype, 'toString'))) {\n                  tempStr = String(tempArg);\n                } else {\n                  tempStr = inspect(tempArg, {\n                    ...inspectOptions,\n                    compact: 3,\n                    colors: false,\n                    depth: 0\n                  });\n                }\n              }\n              break;\n            case 106:\n              // 'j'\n              tempStr = tryStringify(args[++a]);\n              break;\n            case 100:\n              // 'd'\n              const tempNum = args[++a];\n              /*\r\n              if (typeof tempNum === 'bigint') {\r\n              \ttempStr = `${tempNum}n`;\r\n              } else\r\n              */\n              if (typeof tempNum === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumber(stylizeNoColor, Number(tempNum));\n              }\n              break;\n            case 79:\n              // 'O'\n              tempStr = inspect(args[++a], inspectOptions);\n              break;\n            case 111:\n              // 'o'\n              {\n                tempStr = inspect(args[++a], {\n                  ...inspectOptions,\n                  showHidden: true,\n                  showProxy: true,\n                  depth: 4\n                });\n                break;\n              }\n            case 105:\n              // 'i'\n              const tempInteger = args[++a];\n              /*\r\n              if (typeof tempInteger === 'bigint') {\r\n              \ttempStr = `${tempInteger}n`;\r\n              } else */\n              if (typeof tempInteger === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumber(stylizeNoColor, parseInt(tempInteger));\n              }\n              break;\n            case 102:\n              // 'f'\n              const tempFloat = args[++a];\n              if (typeof tempFloat === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumber(stylizeNoColor, parseFloat(tempFloat));\n              }\n              break;\n            case 37:\n              // '%'\n              str += first.slice(lastPos, i);\n              lastPos = i + 1;\n              continue;\n            default:\n              // Any other character is not a correct placeholder\n              continue;\n          }\n          if (lastPos !== i - 1) {\n            str += first.slice(lastPos, i - 1);\n          }\n          str += tempStr;\n          lastPos = i + 1;\n        } else if (nextChar === 37) {\n          str += first.slice(lastPos, i);\n          lastPos = i + 1;\n        }\n      }\n    }\n    if (lastPos !== 0) {\n      a++;\n      join = ' ';\n      if (lastPos < first.length) {\n        str += first.slice(lastPos);\n      }\n    }\n  }\n  while (a < args.length) {\n    const value = args[a];\n    str += join;\n    str += typeof value !== 'string' ? inspect(value, inspectOptions) : value;\n    join = ' ';\n    a++;\n  }\n  return str;\n}\n/* eslint-enable max-depth */\n\nfunction noop$1() {}\nfunction logTime(self, label, logData) {\n  label = `${label}`;\n  const startTime = self._times.get(label);\n  if (!startTime) {\n    process.emitWarning(`Label \"${label}\" does not exist`);\n    return true;\n  }\n  const duration = Date.now() - startTime;\n  if (logData) {\n    self.log(`${label}: ${duration}ms`, ...logData);\n  } else {\n    self.log(`${label}: ${duration}ms`);\n  }\n  return false;\n}\nconst kColorInspectOptions = {\n  colors: true\n};\nconst kNoColorInspectOptions = {};\nlet tableWarned; // boolean flag for one-time warning about console.table not being implemented\n\n// Make a function that can serve as the callback passed to `stream.write()`.\nfunction createWriteErrorHandler(stream) {\n  return err => {\n    // This conditional evaluates to true if and only if there was an error\n    // that was not already emitted (which happens when the _write callback\n    // is invoked asynchronously).\n    if (err !== null && !stream._writableState.errorEmitted) {\n      // If there was an error, it will be emitted on `stream` as\n      // an `error` event. Adding a `once` listener will keep that error\n      // from becoming an uncaught exception, but since the handler is\n      // removed after the event, non-console.* writes won't be affected.\n      // we are only adding noop if there is no one else listening for 'error'\n      if (stream.listenerCount('error') === 0) {\n        stream.once('error', noop$1);\n      }\n    }\n  };\n}\nclass Console {\n  constructor(options, stderr, ignoreErrors) {\n    if (options && options.apiName === 'Ti.API') {\n      // Passing in Ti.API module where we retain log levels\n      this._apiModule = options;\n    } else {\n      // Node.JS streams\n      if (!options || typeof options.write === 'function') {\n        // no args, or first arg is a stream\n        options = {\n          stdout: options,\n          stderr,\n          ignoreErrors\n        };\n      }\n      this._stdout = options.stdout; // TODO: enforce has write function?\n      this._stderr = options.stderr || this._stdout;\n      this._ignoreErrors = options.ignoreErrors !== false;\n      if (this._ignoreErrors) {\n        this._stdoutErrorHandler = createWriteErrorHandler(this._stdout);\n        this._stderrErrorHandler = createWriteErrorHandler(this._stderr);\n      }\n      this._colorMode = options.colorMode || 'auto'; // TODO: enforce boolean or 'auto'\n      this._inspectOptions = options.inspectOptions; // TODO: enforce undefined or typeof 'object'\n    }\n\n    this._times = new Map();\n    this._counts = new Map();\n    this._groupIndent = '';\n  }\n  _writeToConsole(level, string) {\n    if (this._groupIndent.length !== 0) {\n      if (string.includes('\\n')) {\n        string = string.replace(/\\n/g, `\\n${this._groupIndent}`);\n      }\n      string = this._groupIndent + string;\n    }\n\n    // Support wrapping Ti.API (which retains log level)\n    if (this._apiModule) {\n      this._apiModule[level](string);\n    } else {\n      // Support Node.JS streams like stdout/stderr which don't have log levels\n      const useStdErr = level === 'warn' || level === 'error' || level === 'trace';\n      const stream = useStdErr ? this._stderr : this._stdout;\n      if (this._ignoreErrors === false) {\n        return stream.write(string);\n      }\n\n      // There may be an error occurring synchronously (e.g. for files or TTYs\n      // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems), so\n      // handle both situations.\n      try {\n        // Add and later remove a noop error handler to catch synchronous errors.\n        if (stream.listenerCount('error') === 0) {\n          stream.once('error', noop$1);\n        }\n        const errorHandler = useStdErr ? this._stderrErrorHandler : this._stdoutErrorHandler;\n        stream.write(string, errorHandler);\n      } catch (e) {\n        // Console is a debugging utility, so it swallowing errors is not desirable\n        // even in edge cases such as low stack space.\n        if (isStackOverflowError(e)) {\n          throw e;\n        }\n        // Sorry, there's no proper way to pass along the error here.\n      } finally {\n        stream.removeListener && stream.removeListener('error', noop$1);\n      }\n    }\n  }\n  info(...args) {\n    this._writeToConsole('info', formatWithOptions(kColorInspectOptions, ...args));\n  }\n  warn(...args) {\n    this._writeToConsole('warn', formatWithOptions(kNoColorInspectOptions, ...args));\n  }\n  error(...args) {\n    this._writeToConsole('error', formatWithOptions(kNoColorInspectOptions, ...args));\n  }\n  debug(...args) {\n    this._writeToConsole('debug', formatWithOptions(kColorInspectOptions, ...args));\n  }\n  trace(...args) {\n    this._writeToConsole('trace', formatWithOptions(kColorInspectOptions, ...args));\n  }\n  clear() {} // no-op\n\n  group(...data) {\n    if (data.length > 0) {\n      this.log(...data);\n    }\n    this._groupIndent += '  ';\n  }\n  groupEnd() {\n    this._groupIndent = this._groupIndent.slice(0, this._groupIndent.length - 2);\n  }\n  dir(obj, options) {\n    this._writeToConsole('info', inspect(obj, {\n      customInspect: false,\n      ...options\n    }));\n  }\n  assert(value, ...args) {\n    if (!value) {\n      args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;\n      this.warn(...args); // The arguments will be formatted in warn() again\n    }\n  }\n\n  count(label = 'default') {\n    // Ensures that label is a string, and only things that can be\n    // coerced to strings. e.g. Symbol is not allowed\n    label = `${label}`;\n    let count = this._counts.get(label);\n    if (count === undefined) {\n      count = 1;\n    } else {\n      count++;\n    }\n    this._counts.set(label, count);\n    this.log(`${label}: ${count}`);\n  }\n  countReset(label = 'default') {\n    if (!this._counts.has(label)) {\n      process.emitWarning(`Count for '${label}' does not exist`);\n      return;\n    }\n    this._counts.delete(`${label}`);\n  }\n  time(label = 'default') {\n    label = `${label}`;\n    if (this._times.has(label)) {\n      process.emitWarning(`Label ${label}\" already exists`);\n      return;\n    }\n    this._times.set(label, Date.now());\n  }\n  timeEnd(label = 'default') {\n    const warned = logTime(this, label);\n    if (!warned) {\n      this._times.delete(label);\n    }\n  }\n  timeLog(label = 'default', ...logData) {\n    logTime(this, label, logData);\n  }\n\n  // TODO: implement console.table()\n  table() {\n    if (!tableWarned) {\n      tableWarned = true;\n      process.emitWarning('\"console.table\" is not yet implemented in Titanium!');\n    }\n  }\n}\nConsole.prototype.log = Console.prototype.info; // Treat log as alias to info\nConsole.prototype.dirxml = Console.prototype.log; // Treat dirxml as alias to log\nConsole.prototype.groupCollapsed = Console.prototype.group;\nconst globalConsole = new Console(Ti.API);\nglobalConsole.Console = Console;\nglobal.console = globalConsole;\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n */\n/* globals OS_ANDROID */\n\n{\n  Date.prototype.toLocaleDateString = function () {\n    const properties = Intl.DateTimeFormat._makeTiCreationPropertiesFrom(arguments);\n    const oldOptions = properties.options;\n    if (!oldOptions || !oldOptions.dateStyle && !oldOptions.month && !oldOptions.day && !oldOptions.year) {\n      const defaultOptions = {\n        month: 'numeric',\n        day: 'numeric',\n        year: 'numeric'\n      };\n      properties.options = Object.assign(defaultOptions, oldOptions);\n    }\n    const formatter = new Intl.DateTimeFormat(properties.locale, properties.options);\n    return formatter.format(this);\n  };\n  Date.prototype.toLocaleTimeString = function () {\n    const properties = Intl.DateTimeFormat._makeTiCreationPropertiesFrom(arguments);\n    const oldOptions = properties.options;\n    if (!oldOptions || !oldOptions.timeStyle && !oldOptions.hour && !oldOptions.minute && !oldOptions.second) {\n      const defaultOptions = {\n        hour: 'numeric',\n        minute: 'numeric',\n        second: 'numeric'\n      };\n      properties.options = Object.assign(defaultOptions, oldOptions);\n    }\n    const formatter = new Intl.DateTimeFormat(properties.locale, properties.options);\n    return formatter.format(this);\n  };\n  Date.prototype.toLocaleString = function () {\n    const properties = Intl.DateTimeFormat._makeTiCreationPropertiesFrom(arguments);\n    const oldOptions = properties.options;\n    let hasOption = false;\n    if (oldOptions) {\n      hasOption = !!oldOptions.dateStyle || !!oldOptions.timeStyle || !!oldOptions.weekday || !!oldOptions.month || !!oldOptions.day || !!oldOptions.year || !!oldOptions.hour || !!oldOptions.minute || !!oldOptions.second;\n    }\n    if (!hasOption) {\n      const defaultOptions = {\n        month: 'numeric',\n        day: 'numeric',\n        year: 'numeric',\n        hour: 'numeric',\n        minute: 'numeric',\n        second: 'numeric'\n      };\n      properties.options = Object.assign(defaultOptions, oldOptions);\n    }\n    const formatter = new Intl.DateTimeFormat(properties.locale, properties.options);\n    return formatter.format(this);\n  };\n}\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n */\n\n// Add a toJSON() method to all Error objects needed to output non-enumerable properties.\n// The JSON.stringify() will automatically call this method if it exists to provide custom output.\n// Notes:\n// - In V8, all Error properties are not enumerable. We need this or else stringify() will return \"{}\".\n// - In JavaScriptCore, only the \"stack\" property is not enumerable. We want to reveal this.\nif (typeof Error.prototype.toJSON !== 'function') {\n  Error.prototype.toJSON = function () {\n    var properties = {};\n    Object.getOwnPropertyNames(this).forEach(function (name) {\n      properties[name] = this[name];\n    }, this);\n    return properties;\n  };\n}\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n */\n\n/* globals OS_ANDROID */\n\n/**\r\n * Generates a \"creation\" properties dictionary for Titanium's Collator, DateTimeFormat, and NumberFormat proxies\r\n * from the given Intl type's constructor arguments.\r\n * @param {Object[]} args\r\n * The arguments array that was passed into Intl Collator, DateTimeFormat, or NumberFormat type's constructor.\r\n * @param {Function} supportedFormatLocalesFunction Reference to a supportedLocalesOf() function.\r\n * @return {Object} Returns a properties dictionary to be passed into a Titanium proxy's constructor.\r\n */\nfunction makeTiFormatCreationPropertiesFrom(args, supportedFormatLocalesFunction) {\n  const properties = {};\n  if (args.length >= 1) {\n    if (typeof args[0] === 'string') {\n      properties.locale = args[0];\n    } else if (Array.isArray(args[0])) {\n      const supportedLocales = supportedFormatLocalesFunction(args[0]);\n      if (supportedLocales.length > 0) {\n        properties.locale = supportedLocales[0];\n      }\n    }\n  }\n  if (args.length >= 2 && typeof args[1] === 'object') {\n    properties.options = args[1];\n  }\n  return properties;\n}\n\n// Add \"Intl\" APIs missing on Android.\n{\n  // Set up an \"Intl.Collator\" type which wraps our undocumented \"Ti.Locale.Collator\" proxy.\n  function TiCollator() {\n    const properties = makeTiFormatCreationPropertiesFrom(arguments, Ti.Locale.getSupportedCollatorLocales);\n    const collator = new Ti.Locale.Collator(properties);\n    collator.compare = collator.compare.bind(collator);\n    return collator;\n  }\n  TiCollator.supportedLocalesOf = Ti.Locale.getSupportedCollatorLocales;\n\n  // Set up an \"Intl.DateTimeFormat\" type which wraps our undocumented \"Ti.Locale.DateTimeFormat\" proxy.\n  function TiDateTimeFormat() {\n    const properties = makeTiFormatCreationPropertiesFrom(arguments, Ti.Locale.getSupportedDateTimeFormatLocales);\n    return new Ti.Locale.DateTimeFormat(properties);\n  }\n  TiDateTimeFormat._makeTiCreationPropertiesFrom = args => {\n    return makeTiFormatCreationPropertiesFrom(args, Ti.Locale.getSupportedDateTimeFormatLocales);\n  };\n  TiDateTimeFormat.supportedLocalesOf = Ti.Locale.getSupportedDateTimeFormatLocales;\n\n  // Set up an \"Intl.NumberFormat\" type which wraps our undocumented \"Ti.Locale.NumberFormat\" proxy.\n  function TiNumberFormat() {\n    const properties = makeTiFormatCreationPropertiesFrom(arguments, Ti.Locale.getSupportedNumberFormatLocales);\n    return new Ti.Locale.NumberFormat(properties);\n  }\n  TiNumberFormat.supportedLocalesOf = Ti.Locale.getSupportedNumberFormatLocales;\n\n  // Make our custom \"Intl\" module available globally.\n  commonjsGlobal.Intl = {\n    Collator: TiCollator,\n    DateTimeFormat: TiDateTimeFormat,\n    NumberFormat: TiNumberFormat,\n    getCanonicalLocales: Ti.Locale.getCanonicalLocales\n  };\n}\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n */\n/* globals OS_ANDROID */\n\n{\n  Number.prototype.toLocaleString = function () {\n    const formatter = new Intl.NumberFormat(...arguments);\n    return formatter.format(this.valueOf());\n  };\n}\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n */\n/* globals OS_ANDROID */\n\n{\n  String.prototype.localeCompare = function (compareString, locales, options) {\n    const collator = new Intl.Collator(locales, options);\n    return collator.compare(this, compareString);\n  };\n  String.prototype.toLocaleLowerCase = function (locale) {\n    return Ti.Locale.makeLowerCase(this, locale);\n  };\n  String.prototype.toLocaleUpperCase = function (locale) {\n    return Ti.Locale.makeUpperCase(this, locale);\n  };\n}\n\n/**\r\n * This file is used to hijack the standard require to allow for JS\r\n * implementations of \"core\" modules.\r\n *\r\n * You add a binding from the \"core\" module id to the under the hood JS\r\n * implementation. We then intercept require calls to handle requests for these modules\r\n * and lazily load the file.\r\n */\n\n/**\r\n * Used by @function bindObjectToCoreModuleId\r\n * @type {map<string, object>}\r\n */\nconst bindings = new Map();\n\n/**\r\n * Used by @function redirectCoreModuleIdToPath\r\n * @type {map<string, string>}\r\n */\nconst redirects = new Map();\n\n/**\r\n * Does the request look like a typical core module? (no '.' or '/' characters)\r\n * @param {string} path original require path/id\r\n * @returns {boolean}\r\n */\nfunction isHijackableModuleId(path) {\n  if (!path || path.length < 1) {\n    return false;\n  }\n  const firstChar = path.charAt(0);\n  return firstChar !== '.' && firstChar !== '/';\n}\n\n// Hack require to point to this as core module \"binding\". (Note that iOS does not have a global require.)\nconst originalRequire = global.require ? global.require : require.main.require.bind(require.main);\n// This works for Windows as-is, and also intercepts the call on Android/iOS for ti.main.js (the first file executed)\nglobal.require = function (moduleId) {\n  if (bindings.has(moduleId)) {\n    return bindings.get(moduleId);\n  }\n  if (redirects.has(moduleId)) {\n    moduleId = redirects.get(moduleId);\n  }\n  return originalRequire(moduleId);\n};\n\n// ... but we still need to hack it when requiring from other files for Android/iOS (due to module.js impl)\nconst originalModuleRequire = global.Module.prototype.require;\nglobal.Module.prototype.require = function (path, context) {\n  if (bindings.has(path)) {\n    return bindings.get(path);\n  }\n  if (redirects.has(path)) {\n    path = redirects.get(path);\n  }\n  return originalModuleRequire.call(this, path, context);\n};\n\n/**\r\n * Registers a binding from a short module id to an already loaded/constructed object/value to export for that core module id\r\n *\r\n * @param {string} moduleId the module id to \"hijack\"\r\n * @param {*} binding an already constructured value/object to return\r\n */\nfunction register(moduleId, binding) {\n  if (!isHijackableModuleId(moduleId)) {\n    throw new Error(`Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ${moduleId})`);\n  }\n  if (redirects.has(moduleId)) {\n    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);\n    redirects.delete(moduleId);\n  } else if (bindings.has(moduleId)) {\n    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);\n  }\n  bindings.set(moduleId, binding);\n}\n\n/**\r\n * Registers a binding from a short module id to the full under the hood filepath if given a string.\r\n * This allows for lazy instantiation of the module on-demand\r\n *\r\n * @param {string} moduleId the module id to \"hijack\"\r\n * @param {string} filepath the full filepath to require under the hood.\r\n *                              This should be an already resolved absolute path,\r\n *                              as otherwise the context of the call could change what gets loaded!\r\n */\nfunction redirect(moduleId, filepath) {\n  if (!isHijackableModuleId(moduleId)) {\n    throw new Error(`Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ${moduleId})`);\n  }\n  if (bindings.has(moduleId)) {\n    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);\n    bindings.delete(moduleId);\n  } else if (redirects.has(moduleId)) {\n    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);\n  }\n  redirects.set(moduleId, filepath);\n}\n\n// FIXME: There's a collision here with global.binding declared in KrollBridge.m on iOS\nif (!global.binding) {\n  global.binding = {};\n}\nglobal.binding.register = register;\nglobal.binding.redirect = redirect;\n\n// Load all JavaScript extensions/polyfills\nregister('console', globalConsole);\n\n/* globals OS_ANDROID */\n{\n  // Avoid circular references in JSON structure\n  Object.defineProperty(Titanium.Activity.prototype, 'toJSON', {\n    value: function () {\n      const keys = Object.keys(this);\n      const keyCount = keys.length;\n      const serialized = {};\n      for (let i = 0; i < keyCount; i++) {\n        const k = keys[i];\n        if (k === 'window' || k === 'intent' || k.charAt(0) === '_') {\n          continue;\n        }\n        serialized[k] = this[k];\n      }\n      return serialized;\n    },\n    enumerable: false\n  });\n}\n\n/* globals OS_ANDROID */\n{\n  const Properties = Titanium.App.Properties;\n  function nullOrDefaultValue(defaultValue) {\n    if (typeof defaultValue === 'undefined') {\n      return null;\n    }\n    return defaultValue;\n  }\n  function propertyGetter(delegate) {\n    return function (key, defaultValue) {\n      if (!Properties.hasProperty(key)) {\n        return nullOrDefaultValue(defaultValue);\n      }\n      return delegate.call(Properties, key);\n    };\n  }\n  ['getBool', 'getDouble', 'getInt', 'getString'].forEach(function (getter) {\n    Properties[getter] = propertyGetter(Properties[getter]);\n  });\n  Properties.getList = Properties.getObject = function (key, defaultValue) {\n    if (!Properties.hasProperty(key)) {\n      return nullOrDefaultValue(defaultValue);\n    }\n    return JSON.parse(Properties.getString(key));\n  };\n  Properties.setList = Properties.setObject = function (key, val) {\n    Properties.setString(key, JSON.stringify(val));\n  };\n}\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2019-Present by Axway, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n */\n/* globals OS_ANDROID, OS_IOS, OS_VERSION_MAJOR */\nconst buffer = Ti.createBuffer({\n  value: ''\n});\nconst blob = buffer.toBlob();\nconst BlobPrototype = Object.getPrototypeOf(blob);\n{\n  // This doesn't \"stick\" for iOS. It is implemented natively.\n  // Web Blob has an arrayBuffer() method that returns a Promise\n  // https://developer.mozilla.org/en-US/docs/Web/API/Blob/arrayBuffer\n  Object.defineProperty(BlobPrototype, 'arrayBuffer', {\n    value: function () {\n      return new Promise((resolve, reject) => {\n        let buf;\n        try {\n          buf = this.toArrayBuffer();\n        } catch (err) {\n          return reject(err);\n        }\n        resolve(buf);\n      });\n    },\n    enumerable: true\n  });\n}\n\n/* globals OS_ANDROID */\n{\n  const Locale = Titanium.Locale;\n  const wrappedGetString = Locale.getString;\n  Locale.getString = function (key, defaultValue) {\n    const defaultValueType = typeof defaultValue;\n    // If the hint/default is not a string, ignore it!\n    if (defaultValueType !== 'string') {\n      return wrappedGetString.call(Locale, key);\n    }\n    return wrappedGetString.call(Locale, key, defaultValue);\n  };\n  commonjsGlobal.L = Locale.getString;\n}\n\n// Keeps an object alive until dispose() is called.\n// This is currently used to keep \"top level\" objects\n// (ex: windows, tab groups) alive until their lifecycle ends.\nfunction PersistentHandle(object) {\n  this.cell = PersistentHandle.lastId++;\n  PersistentHandle.objects[this.cell] = object;\n}\n\n// Objects retained by persistent handles.\n// Each element in this array acts as a storage \"cell\"\n// keeping the object reachable and alive until it is removed.\nPersistentHandle.objects = {};\nPersistentHandle.lastId = 0;\nPersistentHandle.prototype.dispose = function () {\n  if (this.cell === -1) {\n    // This handle has already been disposed.\n    return;\n  }\n  delete PersistentHandle.objects[this.cell];\n  this.cell = -1;\n};\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2013-Present by Appcelerator, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n */\n{\n  const HTTPClient = Titanium.Network.HTTPClient;\n  const _send = HTTPClient.prototype.send;\n  HTTPClient.prototype.send = function (options) {\n    // Retain the httpclient until the request has been finished.\n    const handle = new PersistentHandle(this);\n    this.on('disposehandle', function () {\n      handle.dispose();\n      if (kroll.DBG) {\n        kroll.log('HTTPClient', 'The persistent handle is disposed.');\n      }\n    });\n    _send.call(this, options);\n  };\n}\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2012-Present by Appcelerator, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n */\n/* globals OS_ANDROID */\n\n{\n  function iPhoneConstant(name) {\n    Titanium.API.error('!!!');\n    Titanium.API.error('!!! WARNING : Use of unsupported constant Ti.UI.iPhone.' + name + ' !!!');\n    Titanium.API.error('!!!');\n    return 0;\n  }\n\n  // TODO: Remove me. Only for temporary compatibility\n  Titanium.UI.iPhone = {\n    ActivityIndicatorStyle: {\n      get BIG() {\n        return iPhoneConstant('ActivityIndicatorStyle.BIG');\n      },\n      get DARK() {\n        return iPhoneConstant('ActivityIndicatorStyle.DARK');\n      }\n    },\n    AnimationStyle: {\n      get FLIP_FROM_LEFT() {\n        return iPhoneConstant('AnimationStyle.FLIP_FROM_LEFT');\n      }\n    },\n    ProgressBarStyle: {\n      get SIMPLE() {\n        return iPhoneConstant('ProgressBarStyle.SIMPLE');\n      }\n    },\n    SystemButton: {\n      get FLEXIBLE_SPACE() {\n        return iPhoneConstant('SystemButton.FLEXIBLE_SPACE');\n      },\n      get DISCLOSURE() {\n        return iPhoneConstant('SystemButton.DISCLOSURE');\n      }\n    },\n    SystemButtonStyle: {\n      get BAR() {\n        return iPhoneConstant('SystemButtonStyle.BAR');\n      }\n    },\n    TableViewCellSelectionStyle: {\n      get NONE() {\n        return iPhoneConstant('TableViewCellSelectionStyle.NONE');\n      }\n    },\n    TableViewSeparatorStyle: {\n      get NONE() {\n        return iPhoneConstant('TableViewSeparatorStyle.NONE');\n      }\n    },\n    RowAnimationStyle: {\n      get NONE() {\n        return iPhoneConstant('RowAnimationStyle.NONE');\n      }\n    },\n    TableViewScrollPosition: {\n      get MIDDLE() {\n        return iPhoneConstant('TableViewScrollPosition.MIDDLE');\n      }\n    },\n    TableViewStyle: {\n      get GROUPED() {\n        return iPhoneConstant('TableViewStyle.GROUPED');\n      }\n    }\n  };\n}\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2020-Present by Axway, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n */\n\n/* global OS_ANDROID */\n\n{\n  const ListView = Titanium.UI.ListView;\n  const defaultTemplate = {\n    properties: {\n      height: '45dp'\n    },\n    childTemplates: [{\n      type: 'Ti.UI.Label',\n      bindId: 'title',\n      properties: {\n        left: '6dp',\n        width: '75%'\n      }\n    }, {\n      type: 'Ti.UI.ImageView',\n      bindId: 'image',\n      properties: {\n        right: '25dp',\n        width: '15%'\n      }\n    }]\n  };\n  function createListView(options) {\n    if (!options) {\n      options = {};\n    }\n    options.templates = {\n      [Titanium.UI.LIST_ITEM_TEMPLATE_DEFAULT]: defaultTemplate,\n      ...options.templates\n    };\n    const templates = options.templates;\n    for (const binding in templates) {\n      const currentTemplate = templates[binding];\n      processTemplate(currentTemplate);\n      processChildTemplates(currentTemplate);\n    }\n    return new ListView(options);\n  }\n\n  // Create ListItemProxy, add events, then store it in 'tiProxy' property\n  function processTemplate(properties) {\n    const cellProxy = Titanium.UI.createListItem();\n    const events = properties.events;\n    properties.tiProxy = cellProxy;\n    addEventListeners(events, cellProxy);\n  }\n\n  // Recursive function that process childTemplates and append corresponding proxies to\n  // property 'tiProxy'. I.e: type: \"Titanium.UI.Label\" -> tiProxy: LabelProxy object\n  function processChildTemplates(properties) {\n    if (!Object.prototype.hasOwnProperty.call(properties, 'childTemplates')) {\n      return;\n    }\n    const childProperties = properties.childTemplates;\n    if (!childProperties) {\n      return;\n    }\n    for (let i = 0; i < childProperties.length; i++) {\n      const child = childProperties[i];\n      const proxyType = child.type;\n      if (proxyType) {\n        const creationProperties = child.properties;\n        const creationFunction = lookup(proxyType);\n\n        // Create proxy.\n        let childProxy;\n        if (creationProperties) {\n          childProxy = creationFunction(creationProperties);\n        } else {\n          childProxy = creationFunction();\n        }\n        // Add event listeners.\n        const events = child.events;\n        addEventListeners(events, childProxy);\n\n        // Append proxy to tiProxy property.\n        child.tiProxy = childProxy;\n      }\n      processChildTemplates(child);\n    }\n  }\n\n  // Add event listeners.\n  function addEventListeners(events, proxy) {\n    if (events !== undefined) {\n      for (const eventName in events) {\n        proxy.addEventListener(eventName, events[eventName]);\n      }\n    }\n  }\n  function lookupProxyConstructor(namespace) {\n    const namespaceIndex = namespace.lastIndexOf('.');\n    const proxyName = namespace.slice(namespaceIndex + 1);\n    const parentNamespace = namespace.substring(0, namespaceIndex);\n    const segments = parentNamespace.split('.');\n    let parentProxy = commonjsGlobal;\n    for (let i = 0; i < segments.length; i++) {\n      parentProxy = parentProxy[segments[i]];\n    }\n    if (parentProxy) {\n      const method = parentProxy[`create${proxyName}`];\n      if (method) {\n        return method;\n      }\n    }\n    throw new Error(`Could not lookup constructor for namespace: \"${namespace}\"`);\n  }\n\n  // Convert name of UI elements into a constructor function.\n  // i.e: lookup(\"Titanium.UI.Label\") returns Titanium.UI.createLabel function.\n  function lookup(namespace) {\n    // Handle Titanium widgets.\n    if (/^(Ti|Titanium)/.test(namespace)) {\n      return lookupProxyConstructor(namespace);\n\n      // Handle Alloy widgets.\n    } else {\n      let widget;\n      try {\n        // Attempt to load alloy widget.\n        widget = commonjsGlobal.Module.main.require(`/alloy/widgets/${namespace}/controllers/widget`);\n      } catch (e) {\n        try {\n          // Widget does not exist, attempt to load namespace.\n          widget = commonjsGlobal.Module.main.require(namespace);\n        } catch (err) {\n          // Namespace does not exist, fall back to legacy behaviour.\n          return lookupProxyConstructor(namespace);\n        }\n      }\n      if (widget) {\n        return function (parameters) {\n          const obj = new widget(parameters);\n          return obj.getView();\n        };\n      }\n    }\n  }\n\n  // Overwrite list view constructor function with our own.\n  Titanium.UI.createListView = createListView;\n}\n\n/* globals OS_ANDROID */\n{\n  // Avoid circular references in JSON structure\n  Object.defineProperty(Titanium.UI.NavigationWindow.prototype, 'toJSON', {\n    value: function () {\n      const keys = Object.keys(this);\n      const keyCount = keys.length;\n      const serialized = {};\n      for (let i = 0; i < keyCount; i++) {\n        const k = keys[i];\n        if (k === 'parent' || k === 'window' || k.charAt(0) === '_') {\n          continue;\n        }\n        serialized[k] = this[k];\n      }\n      return serialized;\n    },\n    enumerable: false\n  });\n}\n\n/**\r\n * This script is used at runtime for Ti.UI.fetchSemanticColor - as well as at build time by both iOS/Android.\r\n * It provides a common interface for handling colors and converting to necessary string forms.\r\n */\nconst HEX_3_REGEX = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i; // i.e. #0F3\nconst HEX_4_REGEX = /^#?([a-f\\d])([a-f\\d])([a-f\\d])([a-f\\d])$/i; // i.e. #0F38\nconst HEX_6_REGEX = /^#?([a-f\\d]){6}$/i; // i.e. #00FF33\nconst HEX_8_REGEX = /^#?([a-f\\d]){8}$/i; // i.e. #00FF3388\n\n/**\r\n * @param {number} integer in range of 0-255\r\n * @returns {string} 2-character hex string value\r\n */\nfunction paddedHex(integer) {\n  const str = integer.toString(16);\n  if (str.length === 1) {\n    return `0${str}`;\n  }\n  return str;\n}\nclass Color {\n  /**\r\n   * @param {number} r red value in range 0-255\r\n   * @param {number} g green value in range 0-255\r\n   * @param {number} b blue value in range 0-255\r\n   * @param {number} [a=1.0] alpha value in range 0.0-1.0\r\n   */\n  constructor(r, g, b, a = 1.0) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.alpha = a;\n  }\n\n  /**\r\n   * indicates if this is a fully opaque color (alpha is 1.0 or was undefined)\r\n   * @returns {boolean}\r\n   */\n  isOpaque() {\n    return this.alpha === 1.0;\n  }\n\n  /**\r\n   * Converts the alpha value into equivalent hex string value properly.\r\n   * @returns {string}\r\n   */\n  alphaHex() {\n    // need to round to avoid nonsensical values like '7f.8' for a 0.5 alpha\n    return paddedHex(Math.round(this.alpha * 255.0));\n  }\n\n  /**\r\n   * Discards any alpha value. To be used internally, not external api. Does not provide leading '#' symbol.\r\n   * @returns {string}\r\n   */\n  _toRGBHexString() {\n    return `${paddedHex(this.r)}${paddedHex(this.g)}${paddedHex(this.b)}`;\n  }\n\n  /**\r\n   * Used by CSS.\r\n   * Converts this color to a hex string with leading '#' symbol and 6- or 8-\r\n   * hexadecimal characters (depending on if alpha is 1.0)\r\n   * @returns {string}\r\n   */\n  toRGBAHexString() {\n    if (this.isOpaque()) {\n      return `#${this._toRGBHexString()}`;\n    }\n    return `#${this._toRGBHexString()}${this.alphaHex()}`;\n  }\n\n  /**\r\n   * Used by Android/iOS\r\n   * Converts this color to a hex string with leading '#' symbol and 6- or 8-\r\n   * hexadecimal characters (depending on if alpha is 1.0). Alpha is the first entry (if there is alpha.)\r\n   * @returns {string}\r\n   */\n  toARGBHexString() {\n    if (this.isOpaque()) {\n      return `#${this._toRGBHexString()}`;\n    }\n    return `#${this.alphaHex()}${this._toRGBHexString()}`;\n  }\n\n  /**\r\n   * For commonality with native iOS TiColor proxy. Produces an AARRGGBB (or RRGGBB if full alpha) hex string\r\n   * @returns {string}\r\n   */\n  toHex() {\n    return this.toARGBHexString();\n  }\n\n  /**\r\n   * Converts this color to an rgba expression. This expression is more consistent across platforms.\r\n   * (whereas iOS/Android differ in expectations for hex strings.)\r\n   * @returns {string}\r\n   */\n  toRGBAString() {\n    return `rgba(${this.r}, ${this.g}, ${this.b}, ${this.alpha.toFixed(3)})`;\n  }\n\n  /**\r\n   * @returns {Color}\r\n   */\n  static fallback() {\n    return new Color(0, 0, 0); // return black to match native impl in iOS\n  }\n\n  /**\r\n   * The supplied hex string MUST be in form '#000000' (i.e. leading pound symbol, 6 hex characters after)\r\n   * @param {string} hex hexadecimal color string\r\n   * @param {number} [alpha] alpha value\r\n   * @returns {Color}\r\n   */\n  static fromHex6String(hex, alpha) {\n    const startIndex = hex.startsWith('#') ? 1 : 0;\n    const r = parseInt(hex.substr(startIndex, 2), 16);\n    const g = parseInt(hex.substr(startIndex + 2, 2), 16);\n    const b = parseInt(hex.substr(startIndex + 4, 2), 16);\n    return new Color(r, g, b, alpha);\n  }\n\n  /**\r\n   * The supplied hex string MUST be in form '#00000000' (i.e. leading pound symbol, 8 hex characters after)\r\n   * @param {string} hex hexadecimal color string\r\n   * @returns {Color}\r\n   */\n  static fromHex8String(hex) {\n    const startIndex = hex.startsWith('#') ? 1 : 0;\n    const alpha = parseInt(hex.substr(startIndex, 2), 16); // alpha is now 0-255\n    const r = parseInt(hex.substr(startIndex + 2, 2), 16);\n    const g = parseInt(hex.substr(startIndex + 4, 2), 16);\n    const b = parseInt(hex.substr(startIndex + 6, 2), 16);\n    return new Color(r, g, b, alpha / 255.0); // convert to 0.0-1.0 (percent)\n  }\n\n  /**\r\n   * Note that the hex value can contain alpha, but must follow the CSS standard of #RRGGBBAA (NOT the Android standard of #AARRGGBB)\r\n   * @param {string|object} entry possible hex string or an object\r\n   * @param {string|number} [hex.alpha] alpha value in percent (0.0-100.0) when hex is an object\r\n  \t * @param {string} [hex.color] hex string for the base color when hex is an object\r\n   * @returns {Color}\r\n   * @throws if entry has both an explicit alpha value AND a hex string containing an alpha value\r\n   */\n  static fromSemanticColorsEntry(entry) {\n    let color = entry;\n    let alpha = 1.0;\n    let hadAlpha = false;\n    if (Object.prototype.hasOwnProperty.call(entry, 'alpha')) {\n      alpha = parseFloat(entry.alpha) / 100.0; // convert from 0-100 range to 0-1 range\n      hadAlpha = true;\n      color = entry.color; // if it has an alpha property assume it has a color property too!\n    }\n\n    // expand the shorter hex string forms to 6 or 8 digits\n    if (color.length === 3) {\n      // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n      color = color.replace(HEX_3_REGEX, (m, r, g, b) => r + r + g + g + b + b);\n    } else if (color.length === 4) {\n      // Expand shorthand form (e.g. \"03F8\") to full form (e.g. \"0033FF88\")\n      color = color.replace(HEX_4_REGEX, (m, a, r, g, b) => a + a + r + r + g + g + b + b);\n    }\n    if (HEX_6_REGEX.exec(color)) {\n      return Color.fromHex6String(color, alpha);\n    }\n    if (HEX_8_REGEX.exec(color)) {\n      if (hadAlpha) {\n        throw new Error(`Color ${entry} had an explicit alpha value AND a hex value containing alpha. Use one or the other.`);\n      }\n      return Color.fromHex8String(color);\n    }\n    // uh-oh, something is up!\n    return Color.fallback();\n  }\n}\nvar color = Color;\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2019-2020 by Axway, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n */\n\n// As Android passes a new instance of Ti.UI to every JS file we can't just\n// Ti.UI within this file, we must call kroll.binding to get the Titanium\n// namespace that is passed in with require and that deal with the .UI\n// namespace that is on that directly.\nconst UI = kroll.binding('Titanium').Titanium.UI ;\n\n// Make our read-only constants\n// TODO: Remove in SDK 10, DEPRECATED in 9.1.0\nObject.defineProperty(UI, 'SEMANTIC_COLOR_TYPE_LIGHT', {\n  value: 'light',\n  writable: false\n});\nObject.defineProperty(UI, 'SEMANTIC_COLOR_TYPE_DARK', {\n  value: 'dark',\n  writable: false\n});\nObject.defineProperty(UI, 'semanticColorType', {\n  get: () => {\n    // TODO: Guard against ios < 13 and Android api < 29?\n    // Assume \"light\" mode unless we explicitly know it's dark\n    if (Ti.UI.userInterfaceStyle === Ti.UI.USER_INTERFACE_STYLE_DARK) {\n      return UI.SEMANTIC_COLOR_TYPE_DARK;\n    }\n    return UI.SEMANTIC_COLOR_TYPE_LIGHT;\n  }\n});\n\n// on Android/iOS < 13, we need to roll our own fetchSemanticColor impl\n// on iOS 13+, we have a native version\n{\n  let colorset;\n  UI.fetchSemanticColor = function fetchSemanticColor(colorName) {\n    // Load all semantic colors from JSON if not done already.\n    // Do so via require() in case this file was changed while running LiveView.\n    if (!colorset) {\n      const colorsetFileName = 'semantic.colors.json';\n      try {\n        const colorsetFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, colorsetFileName);\n        if (colorsetFile.exists()) {\n          // eslint-disable-next-line security/detect-non-literal-require\n          colorset = require(`/${colorsetFileName}`);\n        }\n      } catch (error) {\n        console.error(`Failed to load colors file '${colorsetFileName}'`);\n        return color.fallback().toHex();\n      }\n    }\n    try {\n      if (true) {\n        // On Android, use custom string references to be handled by \"TiColorHelper.java\".\n        if (colorset[colorName]) {\n          // Add all theme colors to a single string.\n          // Example: \"ti.semantic.color:dark=<ColorString>;light=<ColorString>\"\n          const colorArray = [];\n          for (const colorType in colorset[colorName]) {\n            const colorObj = color.fromSemanticColorsEntry(colorset[colorName][colorType]);\n            colorArray.push(`${colorType}=${colorObj.toRGBAString()}`);\n          }\n          return 'ti.semantic.color:' + colorArray.join(';');\n        } else if (Ti.Android.R.color[colorName]) {\n          // We're referencing a native \"res\" color entry.\n          return `@color/${colorName}`;\n        }\n      }\n    } catch (error) {\n      console.error(`Failed to lookup color for ${colorName}`);\n    }\n    return color.fallback().toHex();\n  };\n}\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2011-Present by Appcelerator, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n */\n/* globals OS_ANDROID, OS_IOS */\n{\n  const Tab = Titanium.UI.Tab;\n  function createTab(options) {\n    const tab = new Tab(options);\n    if (options) {\n      tab._window = options.window;\n    }\n    return tab;\n  }\n  Titanium.UI.createTab = createTab;\n  Tab.prototype.open = function (window, options) {\n    if (!window) {\n      return;\n    }\n    if (!options) {\n      options = {};\n    }\n\n    // When we open a window using tab.open(win), we treat it as\n    // opening a HW window on top of the tab.\n    options.tabOpen = true;\n    window.open(options);\n  };\n  Tab.prototype.close = function (options) {\n    const window = this.getWindow();\n    if (window) {\n      window.close(options);\n      this.setWindow(null);\n    }\n  };\n  const _setWindow = Tab.prototype.setWindow;\n  Tab.prototype.setWindow = function (window) {\n    this._window = window;\n    _setWindow.call(this, window);\n  };\n\n  // TODO: Remove! This is an undocumented accessor method\n  Tab.prototype.getWindow = function () {\n    return this._window;\n  };\n  Object.defineProperty(Tab.prototype, 'window', {\n    enumerable: true,\n    set: Tab.prototype.setWindow,\n    get: Tab.prototype.getWindow\n  });\n}\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2021 by Axway, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n */\n/* globals OS_ANDROID */\n\n{\n  const TabGroup = Titanium.UI.TabGroup;\n\n  // Avoid circular loops in toJSON()\n  Object.defineProperty(TabGroup.prototype, 'toJSON', {\n    value: function () {\n      const keys = Object.keys(this);\n      const keyCount = keys.length;\n      const serialized = {};\n      for (let i = 0; i < keyCount; i++) {\n        const k = keys[i];\n        if (k === 'activity' || k.charAt(0) === '_') {\n          continue;\n        }\n        serialized[k] = this[k];\n      }\n      return serialized;\n    },\n    enumerable: false\n  });\n  Object.defineProperty(Titanium.UI.Tab.prototype, 'toJSON', {\n    value: function () {\n      const keys = Object.keys(this);\n      const keyCount = keys.length;\n      const serialized = {};\n      for (let i = 0; i < keyCount; i++) {\n        const k = keys[i];\n        if (k === 'window' || k === 'tabGroup' || k.charAt(0) === '_') {\n          continue;\n        }\n        serialized[k] = this[k];\n      }\n      return serialized;\n    },\n    enumerable: false\n  });\n}\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2015-Present by Appcelerator, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n */\n/* globals OS_ANDROID */\n\n{\n  const View = Titanium.UI.View;\n  const _add = View.prototype.add;\n  View.prototype.add = function (child) {\n    if (child instanceof Titanium.TiWindow) {\n      throw new Error('Cannot add window/tabGroup to a view.');\n    }\n    this._children = this._children || [];\n    _add.call(this, child);\n    // The children have to be retained by the view in the Javascript side\n    // in order to let V8 know the relationship between children and the view.\n    // Therefore, as long as its window is open, all its children won't be detached\n    // or garbage collected and V8 will recoganize the closures and retain all\n    // the related proxies.\n    this._children.push(child);\n  };\n  const _remove = View.prototype.remove;\n  View.prototype.remove = function (child) {\n    _remove.call(this, child);\n\n    // Remove the child in the Javascript side so it can be detached and garbage collected.\n    const children = this._children || [];\n    const childIndex = children.indexOf(child);\n    if (childIndex !== -1) {\n      children.splice(childIndex, 1);\n    }\n  };\n\n  // Do not serialize the parent view. Doing so will result\n  // in a circular reference loop.\n  Object.defineProperty(Titanium.TiView.prototype, 'toJSON', {\n    value: function () {\n      const keys = Object.keys(this);\n      const keyCount = keys.length;\n      const serialized = {};\n      for (let i = 0; i < keyCount; i++) {\n        const k = keys[i];\n        if (k === 'parent' || k.charAt(0) === '_') {\n          continue;\n        }\n        serialized[k] = this[k];\n      }\n      return serialized;\n    },\n    enumerable: false\n  });\n}\n\n/* globals OS_ANDROID */\n{\n  const createWebView = Titanium.UI.createWebView;\n  function createWebViewWrapper(...args) {\n    const webView = createWebView.apply(this, args);\n    webView.onCreateWindow = function (e) {\n      if (!e.isUserGesture) {\n        return null;\n      }\n      const win = Titanium.UI.createWindow({}, {\n        fullscreen: false // Force new activity.\n      });\n\n      const newWebView = Titanium.UI.createWebView();\n      win.add(newWebView);\n      win.open();\n      return newWebView;\n    };\n    return webView;\n  }\n  Titanium.UI.createWebView = createWebViewWrapper;\n}\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2011-Present by Appcelerator, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n */\n{\n  const TAG = 'Window';\n  const Script = kroll.binding('evals').Script; // Android-specific way to grab binding, hangs off 'script' on iOS\n  const Window = Titanium.UI.Window;\n  Window.prototype._cachedActivityProxy = null;\n  function createWindow(options) {\n    const window = new Window(options);\n    window._children = [];\n    return window;\n  }\n  Titanium.UI.createWindow = createWindow;\n\n  // Activity getter (account for scenario when heavy weight window's activity is not created yet)\n  function activityProxyGetter() {\n    const activityProxy = this._getWindowActivityProxy();\n    if (activityProxy) {\n      return activityProxy;\n    }\n    if (this._cachedActivityProxy == null) {\n      // eslint-disable-line\n      this._cachedActivityProxy = {};\n    }\n    return this._cachedActivityProxy;\n  }\n  Window.prototype.getActivity = activityProxyGetter;\n  Object.defineProperty(Window.prototype, 'activity', {\n    get: activityProxyGetter\n  });\n  const _open = Window.prototype.open;\n  Window.prototype.open = function (options) {\n    // Retain the window until it has closed.\n    const handle = new PersistentHandle(this);\n    const self = this;\n    this.once('close', function (e) {\n      if (e._closeFromActivityForcedToDestroy) {\n        if (kroll.DBG) {\n          kroll.log(TAG, 'Window is closed because the activity is forced to destroy by Android OS.');\n        }\n        return;\n      }\n\n      // Dispose the URL context if the window's activity is destroyed.\n      if (self._urlContext) {\n        Script.disposeContext(self._urlContext);\n        self._urlContext = null;\n      }\n      handle.dispose();\n      if (kroll.DBG) {\n        kroll.log(TAG, 'Window is closed normally.');\n      }\n    });\n    return _open.call(this, options);\n  };\n  const _add = Window.prototype.add;\n  Window.prototype.add = function (child) {\n    if (child instanceof Titanium.TiWindow) {\n      throw new Error('Cannot add window/tabGroup to another window/tabGroup.');\n    }\n    _add.call(this, child);\n\n    // The children have to be retained by the window in the Javascript side\n    // in order to let V8 know the relationship between children and the window.\n    // Therefore, as long as the window is open, all its children won't be detached\n    // or garbage collected and V8 will recoganize the closures and retain all\n    // the related proxies.\n    this._children.push(child);\n  };\n  const _remove = Window.prototype.remove;\n  Window.prototype.remove = function (child) {\n    _remove.call(this, child);\n\n    // Remove the child in the Javascript side so it can be detached and garbage collected.\n    const children = this._children;\n    if (children) {\n      const childIndex = children.indexOf(child);\n      if (childIndex !== -1) {\n        children.splice(childIndex, 1);\n      }\n    }\n  };\n  Window.prototype.postWindowCreated = function () {\n    if (kroll.DBG) {\n      kroll.log(TAG, 'Checkpoint: postWindowCreated()');\n    }\n    if (this._cachedActivityProxy) {\n      this._internalActivity.extend(this._cachedActivityProxy);\n    }\n  };\n}\n\n/**\r\n * @param {EventEmitter} emitter the EventEmitter instance to use to register for it's events\r\n * @param {string} eventName the name of the event to register for\r\n * @param {function} listener the listener callback/function to invoke when the event is emitted\r\n * @param {boolean} prepend whether to prepend or append the listener\r\n * @returns {EventEmitter}\r\n */\nfunction _addListener(emitter, eventName, listener, prepend) {\n  if (!emitter._eventsToListeners) {\n    // no events/listeners registered\n    emitter._eventsToListeners = {}; // initialize it\n  }\n  // if there's someone listening to 'newListener' events, emit that **before** we add the listener (to avoid infinite recursion)\n  if (emitter._eventsToListeners.newListener) {\n    emitter.emit('newListener', eventName, listener);\n  }\n  const eventListeners = emitter._eventsToListeners[eventName] || [];\n  if (prepend) {\n    eventListeners.unshift(listener);\n  } else {\n    eventListeners.push(listener);\n  }\n  emitter._eventsToListeners[eventName] = eventListeners;\n\n  // Check max listeners and spit out warning if >\n  const max = emitter.getMaxListeners();\n  const length = eventListeners.length;\n  if (max > 0 && length > max) {\n    const w = new Error(`Possible EventEmitter memory leak detected. ${length} ${eventName} listeners added. Use emitter.setMaxListeners() to increase limit`);\n    w.name = 'MaxListenersExceededWarning';\n    w.emitter = emitter;\n    w.type = eventName;\n    w.count = length;\n    process.emitWarning(w);\n  }\n  return emitter;\n}\nfunction onceWrap(emitter, eventName, listener) {\n  function wrapper(...args) {\n    this.emitter.removeListener(this.eventName, this.wrappedFunc); // remove ourselves\n    this.listener.apply(this.emitter, args); // then forward the event callback\n  }\n  // we have to use bind with a custom 'this', because events fire with 'this' pointing at the emitter\n  const wrapperThis = {\n    emitter,\n    eventName,\n    listener\n  };\n  const bound = wrapper.bind(wrapperThis); // bind to force \"this\" to refer to our custom object tracking the wrapper/emitter/listener\n  bound.listener = listener; // have to add listener property for \"unwrapping\"\n  wrapperThis.wrappedFunc = bound;\n  return bound;\n}\n\n// many consumers make use of this via util.inherits, which does not chain constructor calls!\n// so we need to be aware that _eventsToListeners maye be null/undefined on instances, and check in methods before accessing it\nclass EventEmitter {\n  constructor() {\n    this._eventsToListeners = {};\n    this._maxListeners = undefined;\n  }\n  addListener(eventName, listener) {\n    return _addListener(this, eventName, listener, false);\n  }\n  on(eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n  prependListener(eventName, listener) {\n    return _addListener(this, eventName, listener, true);\n  }\n  once(eventName, listener) {\n    this.on(eventName, onceWrap(this, eventName, listener));\n  }\n  prependOnceListener(eventName, listener) {\n    this.prependListener(eventName, onceWrap(this, eventName, listener));\n  }\n  removeListener(eventName, listener) {\n    if (!this._eventsToListeners) {\n      // no events/listeners registered\n      return this;\n    }\n    const eventListeners = this._eventsToListeners[eventName] || [];\n    const length = eventListeners.length;\n    let foundIndex = -1;\n    let unwrappedListener;\n    // Need to search LIFO, and need to handle wrapped functions (once wrappers)\n    for (let i = length - 1; i >= 0; i--) {\n      if (eventListeners[i] === listener || eventListeners[i].listener === listener) {\n        foundIndex = i;\n        unwrappedListener = eventListeners[i].listener;\n        break;\n      }\n    }\n    if (foundIndex !== -1) {\n      if (length === 1) {\n        // length was 1 and we want to remove last entry, so delete the event type from our listener mapping now!\n        delete this._eventsToListeners[eventName];\n      } else {\n        // we had 2+ listeners, so store array without this given listener\n        eventListeners.splice(foundIndex, 1); // modifies in place, no need to assign to this.listeners[eventName]\n      }\n      // Don't emit if there's no listeners for 'removeListener' type!\n      if (this._eventsToListeners.removeListener) {\n        this.emit('removeListener', eventName, unwrappedListener || listener);\n      }\n    }\n    return this;\n  }\n  off(eventName, listener) {\n    return this.removeListener(eventName, listener);\n  }\n  emit(eventName, ...args) {\n    if (!this._eventsToListeners) {\n      // no events/listeners registered\n      return false;\n    }\n    const eventListeners = this._eventsToListeners[eventName] || [];\n    for (const listener of eventListeners.slice()) {\n      // must operate on copy because listeners ,ay get remove as side-effect of calling\n      listener.call(this, ...args);\n    }\n    return eventListeners.length !== 0;\n  }\n  listenerCount(eventName) {\n    if (!this._eventsToListeners) {\n      // no events/listeners registered\n      return 0;\n    }\n    const eventListeners = this._eventsToListeners[eventName] || [];\n    return eventListeners.length;\n  }\n  eventNames() {\n    return Object.getOwnPropertyNames(this._eventsToListeners || {});\n  }\n  listeners(eventName) {\n    if (!this._eventsToListeners) {\n      // no events/listeners registered\n      return [];\n    }\n    // Need to \"unwrap\" once wrappers!\n    const raw = this._eventsToListeners[eventName] || [];\n    return raw.map(l => l.listener || l); // here we unwrap the once wrapper if there is one or fall back to listener function\n  }\n\n  rawListeners(eventName) {\n    if (!this._eventsToListeners) {\n      // no events/listeners registered\n      return [];\n    }\n    return (this._eventsToListeners[eventName] || []).slice(0); // return a copy\n  }\n\n  getMaxListeners() {\n    return this._maxListeners || EventEmitter.defaultMaxListeners;\n  }\n  setMaxListeners(n) {\n    this._maxListeners = n; // TODO: Type check n, make sure >= 0 (o equals no limit)\n    return this;\n  }\n  removeAllListeners(eventName) {\n    if (!this._eventsToListeners) {\n      // no events/listeners registered\n      this._eventsToListeners = {}; // initialize it\n    }\n\n    if (!this._eventsToListeners.removeListener) {\n      // no need to emit! we can just wipe!\n      if (eventName === undefined) {\n        // remove every type!\n        this._eventsToListeners = {};\n      } else {\n        // remove specific type\n        delete this._eventsToListeners[eventName];\n      }\n      return this;\n    }\n\n    // yuck, we'll have to emit 'removeListener' events as we go\n    if (eventName === undefined) {\n      // Remove all types (but do 'removeListener' last!)\n      const names = Object.keys(this._eventsToListeners).filter(name => name !== 'removeListener');\n      names.forEach(name => this.removeAllListeners(name));\n      this.removeAllListeners('removeListener');\n      this._eventsToListeners = {};\n    } else {\n      // remove listeners for one type, back to front (Last-in, first-out, except where prepend f-ed it up)\n      const listeners = this._eventsToListeners[eventName] || [];\n      for (let i = listeners.length - 1; i >= 0; i--) {\n        this.removeListener(eventName, listeners[i]);\n      }\n    }\n    return this;\n  }\n}\nEventEmitter.defaultMaxListeners = 10;\nEventEmitter.listenerCount = function (emitter, eventName) {\n  return emitter.listenerCount(eventName);\n};\nEventEmitter.EventEmitter = EventEmitter;\n\n/**\r\n * @param  {*} arg passed in argument value\r\n * @param  {string} name name of the argument\r\n * @param  {string} typename i.e. 'string', 'Function' (value is compared to typeof after lowercasing)\r\n * @return {void}\r\n * @throws {TypeError}\r\n */\nfunction assertArgumentType(arg, name, typename) {\n  const type = typeof arg;\n  if (type !== typename.toLowerCase()) {\n    throw new TypeError(`The \"${name}\" argument must be of type ${typename}. Received type ${type}`);\n  }\n}\n\n// Start our process uptime timer immediately!\nconst startTime = Date.now();\n\n/**\r\n * This function 'standardizes' the reported architectures to the equivalents reported by Node.js\r\n * node values: 'arm', 'arm64', 'ia32', 'mips', 'mipsel', 'ppc', 'ppc64', 's390', 's390x', 'x32', and 'x64'.\r\n * iOS values: \"arm64\", \"armv7\", \"x86_64\", \"i386\", \"Unknown\"\r\n * Android values: \"armeabi\", \"armeabi-v7a\", \"arm64-v8a\", \"x86\", \"x86_64\", \"mips\", \"mips64\", \"unknown\"\r\n * Windows values: \"x64\", \"ia64\", \"ARM\", \"x86\", \"unknown\"\r\n * @param {string} original original architecture reported by Ti.Platform\r\n * @returns {string}\r\n */\nfunction standardizeArch(original) {\n  switch (original) {\n    // coerce 'armv7', 'armeabi', 'armeabi-v7a', 'ARM' -> 'arm'\n    // 'armeabi' is a dead ABI for Android, removed in NDK r17\n    case 'armv7':\n    case 'armeabi':\n    case 'armeabi-v7a':\n    case 'ARM':\n      return 'arm';\n\n    // coerce 'arm64-v8a' -> 'arm64'\n    case 'arm64-v8a':\n      return 'arm64';\n\n    // coerce 'i386', 'x86' -> 'ia32'\n    case 'i386':\n    case 'x86':\n      return 'ia32';\n\n    // coerce 'x86_64', 'ia64', 'x64' -> 'x64'\n    case 'x86_64':\n    case 'ia64':\n      return 'x64';\n\n    // coerce 'mips64' -> 'mips' // 'mips' and 'mips64' are dead ABIs for Android, removed in NDK r17\n    case 'mips64':\n      return 'mips';\n\n    // coerce 'Unknown' -> 'unknown'\n    case 'Unknown':\n      return 'unknown';\n    default:\n      return original;\n  }\n}\nconst process$1 = new EventEmitter();\nprocess$1.abort = () => {}; // TODO: Do we have equivalent of forcibly killing the process? We have restart, but I think we just want a no-op stub here\nprocess$1.arch = standardizeArch(Ti.Platform.architecture);\nprocess$1.argv = []; // TODO: What makes sense here? path to titanium cli for first arg? path to ti.main/app.js for second?\nObject.defineProperty(process$1, 'argv0', {\n  value: '',\n  // TODO: Path to .app on iOS?\n  writable: false,\n  enumerable: true,\n  configurable: false\n});\nprocess$1.binding = () => {\n  throw new Error('process.binding is unsupported and not user-facing API');\n};\nprocess$1.channel = undefined;\nprocess$1.chdir = () => {\n  throw new Error('process.chdir is unsupported');\n};\nprocess$1.config = {};\nprocess$1.connected = false;\nprocess$1.cpuUsage = () => {\n  // FIXME: Can we look at OS.cpus to get this data?\n  return {\n    user: 0,\n    system: 0\n  };\n};\nprocess$1.cwd = () => __dirname;\nObject.defineProperty(process$1, 'debugPort', {\n  get: function () {\n    let value = 0; // default to 0\n    try {\n      if (\"android\" === 'android') {\n        const assets = kroll.binding('assets');\n        const json = assets.readAsset('deploy.json');\n        if (json) {\n          const deployData = JSON.parse(json);\n          if (deployData.debuggerPort !== -1) {\n            // -1 means not set (not in debug mode)\n            value = deployData.debuggerPort;\n          }\n        }\n      }\n    } catch (error) {\n      // ignore\n    }\n    // overwrite this getter with static value\n    Object.defineProperty(this, 'debugPort', {\n      value: value,\n      writable: true,\n      enumerable: true,\n      configurable: true\n    });\n    return value;\n  },\n  enumerable: true,\n  configurable: true\n});\nprocess$1.disconnect = () => {}; // no-op\nprocess$1.dlopen = () => {\n  throw new Error('process.dlopen is not supported');\n};\nprocess$1.emitWarning = function (warning, options, code, ctor) {\n  // eslint-disable-line no-unused-vars\n  let type;\n  let detail;\n  if (typeof options === 'string') {\n    type = options;\n  } else if (typeof options === 'object') {\n    type = options.type;\n    code = options.code;\n    detail = options.detail;\n  }\n  if (typeof warning === 'string') {\n    // TODO: make use of `ctor` arg for limiting stack traces? Can only really be used on V8\n    // set stack trace limit to 0, then call Error.captureStackTrace(warning, ctor);\n    warning = new Error(warning);\n    warning.name = type || 'Warning';\n    if (code !== undefined) {\n      warning.code = code;\n    }\n    if (detail !== undefined) {\n      warning.detail = detail;\n    }\n  }\n  // TODO: Throw TypeError if not an instanceof Error at this point!\n  const isDeprecation = warning.name === 'DeprecationWarning';\n  if (isDeprecation && process$1.noDeprecation) {\n    return; // ignore\n  }\n\n  if (isDeprecation && process$1.throwDeprecation) {\n    throw warning;\n  }\n  this.emit('warning', warning);\n};\nfunction loadEnvJson() {\n  try {\n    const jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, '_env_.json');\n    if (jsonFile.exists()) {\n      return JSON.parse(jsonFile.read().text);\n    }\n  } catch (error) {\n    Ti.API.error(`Failed to read \"_env_.json\". Reason: ${error.message}`);\n  }\n  return {};\n}\nObject.defineProperty(process$1, 'env', {\n  get: function () {\n    delete this.env;\n    return this.env = loadEnvJson();\n  },\n  enumerable: true,\n  configurable: true\n});\nprocess$1.execArgv = [];\nprocess$1.execPath = ''; // FIXME: What makes sense here? Path to titanium CLI here?\nprocess$1.exit = () => {\n  throw new Error('process.exit is not supported');\n};\nprocess$1.exitCode = undefined;\nprocess$1.noDeprecation = false;\nprocess$1.pid = 0;\n// FIXME: Should we try and adopt 'ipad'/'iphone' to 'darwin'? or 'ios'?\nprocess$1.platform = \"android\";\nprocess$1.ppid = 0;\n// TODO: Add release property (Object)\n// TODO: Can we expose stdout/stderr/stdin natively?\n// Don't wrap console.log/error because technically global console wraps process.stdout/stderr (or should)\nprocess$1.stderr = {\n  isTTY: false,\n  writable: true,\n  write: (chunk, encoding, callback) => {\n    Ti.API.error(chunk);\n    if (callback) {\n      callback();\n    }\n    return true;\n  }\n};\nprocess$1.stdout = {\n  isTTY: false,\n  writable: true,\n  write: (chunk, encoding, callback) => {\n    Ti.API.info(chunk);\n    if (callback) {\n      callback();\n    }\n    return true;\n  }\n};\nprocess$1.title = Ti.App.name;\nprocess$1.throwDeprecation = false;\nprocess$1.traceDeprecation = false;\nprocess$1.umask = () => 0; // just always return 0\nprocess$1.uptime = () => {\n  const diffMs = Date.now() - startTime;\n  return diffMs / 1000.0; // convert to \"seconds\" with fractions\n};\n\nprocess$1.version = \"12.3.0\";\nprocess$1.versions = {\n  modules: '',\n  // TODO: Report module api version (for current platform!)\n  v8: '',\n  // TODO: report android's v8 version (if on Android!)\n  jsc: '' // TODO: report javascriptcore version for iOS/WIndows?\n  // TODO: Report ios/Android/Windows platform versions?\n};\n\nprocess$1[Symbol.toStringTag] = 'process';\nglobal.process = process$1;\n// handle spitting out warnings\nconst WARNING_PREFIX = `(titanium:${process$1.pid}) `;\nprocess$1.on('warning', warning => {\n  const isDeprecation = warning.name === 'DeprecationWarning';\n  // if we're not doing deprecations, ignore!\n  if (isDeprecation && process$1.noDeprecation) {\n    return;\n  }\n  // TODO: Check process.traceDeprecation and if set, include stack trace in message!\n  let msg = WARNING_PREFIX;\n  if (warning.code !== undefined) {\n    msg += `[${warning.code}] `;\n  }\n  if (warning.toString) {\n    msg += warning.toString();\n  }\n  if (warning.detail) {\n    msg += `\\n${warning.detail}`;\n  }\n  console.error(msg);\n});\nlet uncaughtExceptionCallback = null;\nprocess$1.hasUncaughtExceptionCaptureCallback = () => uncaughtExceptionCallback !== null;\nprocess$1.setUncaughtExceptionCaptureCallback = fn => {\n  if (fn === null) {\n    uncaughtExceptionCallback = null;\n    return;\n  }\n  assertArgumentType(fn, 'fn', 'function');\n  if (uncaughtExceptionCallback !== null) {\n    throw new Error('`process.setUncaughtExceptionCaptureCallback()` was called while a capture callback was already active');\n  }\n  uncaughtExceptionCallback = fn;\n};\nTi.App.addEventListener('uncaughtException', function (event) {\n  // Create an Error instance that wraps the data from the event\n  // ideally we'd just forward along the original Error!\n  const error = new Error(event.message);\n  error.stack = event.backtrace;\n  error.fileName = event.sourceName;\n  error.lineNumber = event.line;\n  error.columnNumber = event.lineOffset;\n  if (process$1.hasUncaughtExceptionCaptureCallback()) {\n    return uncaughtExceptionCallback(error);\n  }\n  // otherwise forward the event!\n  process$1.emit('uncaughtException', error);\n});\n\n// Use a nice predictable class/structure for our Immediate/Tick \"timers\"\n// JS engine should be able to optimize easier\nclass CallbackWithArgs {\n  constructor(func, args) {\n    this.func = func;\n    this.args = args;\n  }\n  run() {\n    if (this.args) {\n      this.func.apply(null, this.args);\n    } else {\n      this.fun();\n    }\n  }\n}\n// nextTick vs setImmediate should be handled in a semi-smart way\n// Basically nextTick needs to drain the full queue (and can cause infinite loops if nextTick callback calls nextTick!)\n// Then we should go through the \"immediate\" queue\n// http://plafer.github.io/2015/09/08/nextTick-vs-setImmediate/\nconst tickQueue = [];\nconst immediateQueue = [];\nlet drainingTickQueue = false;\nlet drainQueuesTimeout = null;\n\n/**\r\n * Iteratively runs all \"ticks\" until there are no more.\r\n * This can cause infinite recursion if a tick schedules another forever.\r\n */\nfunction drainTickQueue() {\n  if (drainingTickQueue) {\n    return;\n  }\n  drainingTickQueue = true;\n  while (tickQueue.length) {\n    const tick = tickQueue.shift();\n    tick.run();\n  }\n  drainingTickQueue = false;\n}\nfunction drainQueues() {\n  // drain the full tick queue first...\n  drainTickQueue();\n  // tick queue should be empty!\n  const immediatesRemaining = processImmediateQueue();\n  if (immediatesRemaining !== 0) {\n    // re-schedule draining our queues, as we have at least one more \"immediate\" to handle\n    drainQueuesTimeout = setTimeout(drainQueues, 0);\n  } else {\n    drainQueuesTimeout = null;\n  }\n}\n\n/**\r\n * Attempts to process \"immediates\" (in a much more leisurely way than ticks)\r\n * We give a 100ms window to run them in before re-scheduling the timeout to process them again.\r\n * If any ticks are added during invocation of immediate, we drain the tick queue fully before\r\n * proceeding to next immediate (if we still have time in our window).\r\n * @returns {number} number of remaining immediates to be processed\r\n */\nfunction processImmediateQueue() {\n  const immediateDeadline = Date.now() + 100; // give us up to 100ms to process immediates\n  while (immediateQueue.length && Date.now() < immediateDeadline) {\n    const immediate = immediateQueue.shift();\n    immediate.run();\n    if (tickQueue.length > 0) {\n      // they added a tick! drain the tick queue before we do anything else (this *may* eat up our deadline/window to process any more immediates)\n      drainTickQueue();\n    }\n  }\n  return immediateQueue.length;\n}\nprocess$1.nextTick = function (callback, ...args) {\n  assertArgumentType(callback, 'callback', 'function');\n  tickQueue.push(new CallbackWithArgs(callback, args));\n  if (!drainQueuesTimeout) {\n    drainQueuesTimeout = setTimeout(drainQueues, 0);\n  }\n};\nglobal.setImmediate = function (callback, ...args) {\n  assertArgumentType(callback, 'callback', 'function');\n  const immediate = new CallbackWithArgs(callback, args);\n  immediateQueue.push(immediate);\n  if (!drainQueuesTimeout) {\n    drainQueuesTimeout = setTimeout(drainQueues, 0);\n  }\n  return immediate;\n};\nglobal.clearImmediate = function (immediate) {\n  const index = immediateQueue.indexOf(immediate);\n  if (index !== -1) {\n    immediateQueue.splice(index, 1);\n  }\n};\n\nconst FORWARD_SLASH = 47; // '/'\nconst BACKWARD_SLASH = 92; // '\\\\'\n\n/**\r\n * Is this [a-zA-Z]?\r\n * @param  {number}  charCode value from String.charCodeAt()\r\n * @return {Boolean}          [description]\r\n */\nfunction isWindowsDeviceName(charCode) {\n  return charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122;\n}\n\n/**\r\n * [isAbsolute description]\r\n * @param  {boolean} isPosix whether this impl is for POSIX or not\r\n * @param  {string} filepath   input file path\r\n * @return {Boolean}          [description]\r\n */\nfunction isAbsolute(isPosix, filepath) {\n  assertArgumentType(filepath, 'path', 'string');\n  const length = filepath.length;\n  // empty string special case\n  if (length === 0) {\n    return false;\n  }\n  const firstChar = filepath.charCodeAt(0);\n  if (firstChar === FORWARD_SLASH) {\n    return true;\n  }\n  // we already did our checks for posix\n  if (isPosix) {\n    return false;\n  }\n  // win32 from here on out\n  if (firstChar === BACKWARD_SLASH) {\n    return true;\n  }\n  if (length > 2 && isWindowsDeviceName(firstChar) && filepath.charAt(1) === ':') {\n    const thirdChar = filepath.charAt(2);\n    return thirdChar === '/' || thirdChar === '\\\\';\n  }\n  return false;\n}\n\n/**\r\n * [dirname description]\r\n * @param  {string} separator  platform-specific file separator\r\n * @param  {string} filepath   input file path\r\n * @return {string}            [description]\r\n */\nfunction dirname(separator, filepath) {\n  assertArgumentType(filepath, 'path', 'string');\n  const length = filepath.length;\n  if (length === 0) {\n    return '.';\n  }\n\n  // ignore trailing separator\n  let fromIndex = length - 1;\n  const hadTrailing = filepath.endsWith(separator);\n  if (hadTrailing) {\n    fromIndex--;\n  }\n  const foundIndex = filepath.lastIndexOf(separator, fromIndex);\n  // no separators\n  if (foundIndex === -1) {\n    // handle special case of root windows paths\n    if (length >= 2 && separator === '\\\\' && filepath.charAt(1) === ':') {\n      const firstChar = filepath.charCodeAt(0);\n      if (isWindowsDeviceName(firstChar)) {\n        return filepath; // it's a root windows path\n      }\n    }\n\n    return '.';\n  }\n  // only found root separator\n  if (foundIndex === 0) {\n    return separator; // if it was '/', return that\n  }\n  // Handle special case of '//something'\n  if (foundIndex === 1 && separator === '/' && filepath.charAt(0) === '/') {\n    return '//';\n  }\n  return filepath.slice(0, foundIndex);\n}\n\n/**\r\n * [extname description]\r\n * @param  {string} separator  platform-specific file separator\r\n * @param  {string} filepath   input file path\r\n * @return {string}            [description]\r\n */\nfunction extname(separator, filepath) {\n  assertArgumentType(filepath, 'path', 'string');\n  const index = filepath.lastIndexOf('.');\n  if (index === -1 || index === 0) {\n    return '';\n  }\n  // ignore trailing separator\n  let endIndex = filepath.length;\n  if (filepath.endsWith(separator)) {\n    endIndex--;\n  }\n  return filepath.slice(index, endIndex);\n}\nfunction lastIndexWin32Separator(filepath, index) {\n  for (let i = index; i >= 0; i--) {\n    const char = filepath.charCodeAt(i);\n    if (char === BACKWARD_SLASH || char === FORWARD_SLASH) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\r\n * [basename description]\r\n * @param  {string} separator  platform-specific file separator\r\n * @param  {string} filepath   input file path\r\n * @param  {string} [ext]      file extension to drop if it exists\r\n * @return {string}            [description]\r\n */\nfunction basename(separator, filepath, ext) {\n  assertArgumentType(filepath, 'path', 'string');\n  if (ext !== undefined) {\n    assertArgumentType(ext, 'ext', 'string');\n  }\n  const length = filepath.length;\n  if (length === 0) {\n    return '';\n  }\n  const isPosix = separator === '/';\n  let endIndex = length;\n  // drop trailing separator (if there is one)\n  const lastCharCode = filepath.charCodeAt(length - 1);\n  if (lastCharCode === FORWARD_SLASH || !isPosix && lastCharCode === BACKWARD_SLASH) {\n    endIndex--;\n  }\n\n  // Find last occurence of separator\n  let lastIndex = -1;\n  if (isPosix) {\n    lastIndex = filepath.lastIndexOf(separator, endIndex - 1);\n  } else {\n    // On win32, handle *either* separator!\n    lastIndex = lastIndexWin32Separator(filepath, endIndex - 1);\n    // handle special case of root path like 'C:' or 'C:\\\\'\n    if ((lastIndex === 2 || lastIndex === -1) && filepath.charAt(1) === ':' && isWindowsDeviceName(filepath.charCodeAt(0))) {\n      return '';\n    }\n  }\n\n  // Take from last occurrence of separator to end of string (or beginning to end if not found)\n  const base = filepath.slice(lastIndex + 1, endIndex);\n\n  // drop trailing extension (if specified)\n  if (ext === undefined) {\n    return base;\n  }\n  return base.endsWith(ext) ? base.slice(0, base.length - ext.length) : base;\n}\n\n/**\r\n * The `path.normalize()` method normalizes the given path, resolving '..' and '.' segments.\r\n *\r\n * When multiple, sequential path segment separation characters are found (e.g.\r\n * / on POSIX and either \\ or / on Windows), they are replaced by a single\r\n * instance of the platform-specific path segment separator (/ on POSIX and \\\r\n * on Windows). Trailing separators are preserved.\r\n *\r\n * If the path is a zero-length string, '.' is returned, representing the\r\n * current working directory.\r\n *\r\n * @param  {string} separator  platform-specific file separator\r\n * @param  {string} filepath  input file path\r\n * @return {string} [description]\r\n */\nfunction normalize(separator, filepath) {\n  assertArgumentType(filepath, 'path', 'string');\n  if (filepath.length === 0) {\n    return '.';\n  }\n\n  // Windows can handle '/' or '\\\\' and both should be turned into separator\n  const isWindows = separator === '\\\\';\n  if (isWindows) {\n    filepath = filepath.replace(/\\//g, separator);\n  }\n  const hadLeading = filepath.startsWith(separator);\n  // On Windows, need to handle UNC paths (\\\\host-name\\\\resource\\\\dir) special to retain leading double backslash\n  const isUNC = hadLeading && isWindows && filepath.length > 2 && filepath.charAt(1) === '\\\\';\n  const hadTrailing = filepath.endsWith(separator);\n  const parts = filepath.split(separator);\n  const result = [];\n  for (const segment of parts) {\n    if (segment.length !== 0 && segment !== '.') {\n      if (segment === '..') {\n        result.pop(); // FIXME: What if this goes above root? Should we throw an error?\n      } else {\n        result.push(segment);\n      }\n    }\n  }\n  let normalized = hadLeading ? separator : '';\n  normalized += result.join(separator);\n  if (hadTrailing) {\n    normalized += separator;\n  }\n  if (isUNC) {\n    normalized = '\\\\' + normalized;\n  }\n  return normalized;\n}\n\n/**\r\n * [assertSegment description]\r\n * @param  {*} segment [description]\r\n * @return {void}         [description]\r\n */\nfunction assertSegment(segment) {\n  if (typeof segment !== 'string') {\n    throw new TypeError(`Path must be a string. Received ${segment}`);\n  }\n}\n\n/**\r\n * The `path.join()` method joins all given path segments together using the\r\n * platform-specific separator as a delimiter, then normalizes the resulting path.\r\n * Zero-length path segments are ignored. If the joined path string is a zero-\r\n * length string then '.' will be returned, representing the current working directory.\r\n * @param  {string} separator platform-specific file separator\r\n * @param  {string[]} paths [description]\r\n * @return {string}       The joined filepath\r\n */\nfunction join(separator, paths) {\n  const result = [];\n  // naive impl: just join all the paths with separator\n  for (const segment of paths) {\n    assertSegment(segment);\n    if (segment.length !== 0) {\n      result.push(segment);\n    }\n  }\n  return normalize(separator, result.join(separator));\n}\n\n/**\r\n * The `path.resolve()` method resolves a sequence of paths or path segments into an absolute path.\r\n *\r\n * @param  {string} separator platform-specific file separator\r\n * @param  {string[]} paths [description]\r\n * @return {string}       [description]\r\n */\nfunction resolve(separator, paths) {\n  let resolved = '';\n  let hitRoot = false;\n  const isPosix = separator === '/';\n  // go from right to left until we hit absolute path/root\n  for (let i = paths.length - 1; i >= 0; i--) {\n    const segment = paths[i];\n    assertSegment(segment);\n    if (segment.length === 0) {\n      continue; // skip empty\n    }\n\n    resolved = segment + separator + resolved; // prepend new segment\n    if (isAbsolute(isPosix, segment)) {\n      // have we backed into an absolute path?\n      hitRoot = true;\n      break;\n    }\n  }\n  // if we didn't hit root, prepend cwd\n  if (!hitRoot) {\n    resolved = (global.process ? process.cwd() : '/') + separator + resolved;\n  }\n  const normalized = normalize(separator, resolved);\n  if (normalized.charAt(normalized.length - 1) === separator) {\n    // FIXME: Handle UNC paths on Windows as well, so we don't trim trailing separator on something like '\\\\\\\\host-name\\\\resource\\\\'\n    // Don't remove trailing separator if this is root path on windows!\n    if (!isPosix && normalized.length === 3 && normalized.charAt(1) === ':' && isWindowsDeviceName(normalized.charCodeAt(0))) {\n      return normalized;\n    }\n    // otherwise trim trailing separator\n    return normalized.slice(0, normalized.length - 1);\n  }\n  return normalized;\n}\n\n/**\r\n * The `path.relative()` method returns the relative path `from` from to `to` based\r\n * on the current working directory. If from and to each resolve to the same\r\n * path (after calling `path.resolve()` on each), a zero-length string is returned.\r\n *\r\n * If a zero-length string is passed as `from` or `to`, the current working directory\r\n * will be used instead of the zero-length strings.\r\n *\r\n * @param  {string} separator platform-specific file separator\r\n * @param  {string} from [description]\r\n * @param  {string} to   [description]\r\n * @return {string}      [description]\r\n */\nfunction relative(separator, from, to) {\n  assertArgumentType(from, 'from', 'string');\n  assertArgumentType(to, 'to', 'string');\n  if (from === to) {\n    return '';\n  }\n  from = resolve(separator, [from]);\n  to = resolve(separator, [to]);\n  if (from === to) {\n    return '';\n  }\n\n  // we now have two absolute paths,\n  // lets \"go up\" from `from` until we reach common base dir of `to`\n  // const originalFrom = from;\n  let upCount = 0;\n  let remainingPath = '';\n  while (true) {\n    if (to.startsWith(from)) {\n      // match! record rest...?\n      remainingPath = to.slice(from.length);\n      break;\n    }\n    // FIXME: Break/throw if we hit bad edge case of no common root!\n    from = dirname(separator, from);\n    upCount++;\n  }\n  // remove leading separator from remainingPath if there is any\n  if (remainingPath.length > 0) {\n    remainingPath = remainingPath.slice(1);\n  }\n  return ('..' + separator).repeat(upCount) + remainingPath;\n}\n\n/**\r\n * The `path.parse()` method returns an object whose properties represent\r\n * significant elements of the path. Trailing directory separators are ignored,\r\n * see `path.sep`.\r\n *\r\n * The returned object will have the following properties:\r\n *\r\n * - dir <string>\r\n * - root <string>\r\n * - base <string>\r\n * - name <string>\r\n * - ext <string>\r\n * @param  {string} separator platform-specific file separator\r\n * @param  {string} filepath [description]\r\n * @return {object}\r\n */\nfunction parse(separator, filepath) {\n  assertArgumentType(filepath, 'path', 'string');\n  const result = {\n    root: '',\n    dir: '',\n    base: '',\n    ext: '',\n    name: ''\n  };\n  const length = filepath.length;\n  if (length === 0) {\n    return result;\n  }\n\n  // Cheat and just call our other methods for dirname/basename/extname?\n  result.base = basename(separator, filepath);\n  result.ext = extname(separator, result.base);\n  const baseLength = result.base.length;\n  result.name = result.base.slice(0, baseLength - result.ext.length);\n  const toSubtract = baseLength === 0 ? 0 : baseLength + 1;\n  result.dir = filepath.slice(0, filepath.length - toSubtract); // drop trailing separator!\n  const firstCharCode = filepath.charCodeAt(0);\n  // both win32 and POSIX return '/' root\n  if (firstCharCode === FORWARD_SLASH) {\n    result.root = '/';\n    return result;\n  }\n  // we're done with POSIX...\n  if (separator === '/') {\n    return result;\n  }\n  // for win32...\n  if (firstCharCode === BACKWARD_SLASH) {\n    // FIXME: Handle UNC paths like '\\\\\\\\host-name\\\\resource\\\\file_path'\n    // need to retain '\\\\\\\\host-name\\\\resource\\\\' as root in that case!\n    result.root = '\\\\';\n    return result;\n  }\n  // check for C: style root\n  if (length > 1 && isWindowsDeviceName(firstCharCode) && filepath.charAt(1) === ':') {\n    if (length > 2) {\n      // is it like C:\\\\?\n      const thirdCharCode = filepath.charCodeAt(2);\n      if (thirdCharCode === FORWARD_SLASH || thirdCharCode === BACKWARD_SLASH) {\n        result.root = filepath.slice(0, 3);\n        return result;\n      }\n    }\n    // nope, just C:, no trailing separator\n    result.root = filepath.slice(0, 2);\n  }\n  return result;\n}\n\n/**\r\n * The `path.format()` method returns a path string from an object. This is the\r\n * opposite of `path.parse()`.\r\n *\r\n * @param  {string} separator platform-specific file separator\r\n * @param  {object} pathObject object of format returned by `path.parse()`\r\n * @param  {string} pathObject.dir directory name\r\n * @param  {string} pathObject.root file root dir, ignored if `pathObject.dir` is provided\r\n * @param  {string} pathObject.base file basename\r\n * @param  {string} pathObject.name basename minus extension, ignored if `pathObject.base` exists\r\n * @param  {string} pathObject.ext file extension, ignored if `pathObject.base` exists\r\n * @return {string}\r\n */\nfunction format(separator, pathObject) {\n  assertArgumentType(pathObject, 'pathObject', 'object');\n  const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`;\n\n  // append base to root if `dir` wasn't specified, or if\n  // dir is the root\n  if (!pathObject.dir || pathObject.dir === pathObject.root) {\n    return `${pathObject.root || ''}${base}`;\n  }\n  // combine dir + / + base\n  return `${pathObject.dir}${separator}${base}`;\n}\n\n/**\r\n * On Windows systems only, returns an equivalent namespace-prefixed path for\r\n * the given path. If path is not a string, path will be returned without modifications.\r\n * See https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#namespaces\r\n * @param  {string} filepath [description]\r\n * @return {string}          [description]\r\n */\nfunction toNamespacedPath(filepath) {\n  if (typeof filepath !== 'string') {\n    return filepath;\n  }\n  if (filepath.length === 0) {\n    return '';\n  }\n  const resolvedPath = resolve('\\\\', [filepath]);\n  const length = resolvedPath.length;\n  if (length < 2) {\n    // need '\\\\\\\\' or 'C:' minimum\n    return filepath;\n  }\n  const firstCharCode = resolvedPath.charCodeAt(0);\n  // if start with '\\\\\\\\', prefix with UNC root, drop the slashes\n  if (firstCharCode === BACKWARD_SLASH && resolvedPath.charAt(1) === '\\\\') {\n    // return as-is if it's an aready long path ('\\\\\\\\?\\\\' or '\\\\\\\\.\\\\' prefix)\n    if (length >= 3) {\n      const thirdChar = resolvedPath.charAt(2);\n      if (thirdChar === '?' || thirdChar === '.') {\n        return filepath;\n      }\n    }\n    return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.slice(2);\n  } else if (isWindowsDeviceName(firstCharCode) && resolvedPath.charAt(1) === ':') {\n    return '\\\\\\\\?\\\\' + resolvedPath;\n  }\n  return filepath;\n}\nconst Win32Path = {\n  sep: '\\\\',\n  delimiter: ';',\n  basename: function (filepath, ext) {\n    return basename(this.sep, filepath, ext);\n  },\n  normalize: function (filepath) {\n    return normalize(this.sep, filepath);\n  },\n  join: function (...paths) {\n    return join(this.sep, paths);\n  },\n  extname: function (filepath) {\n    return extname(this.sep, filepath);\n  },\n  dirname: function (filepath) {\n    return dirname(this.sep, filepath);\n  },\n  isAbsolute: function (filepath) {\n    return isAbsolute(false, filepath);\n  },\n  relative: function (from, to) {\n    return relative(this.sep, from, to);\n  },\n  resolve: function (...paths) {\n    return resolve(this.sep, paths);\n  },\n  parse: function (filepath) {\n    return parse(this.sep, filepath);\n  },\n  format: function (pathObject) {\n    return format(this.sep, pathObject);\n  },\n  toNamespacedPath: toNamespacedPath\n};\nconst PosixPath = {\n  sep: '/',\n  delimiter: ':',\n  basename: function (filepath, ext) {\n    return basename(this.sep, filepath, ext);\n  },\n  normalize: function (filepath) {\n    return normalize(this.sep, filepath);\n  },\n  join: function (...paths) {\n    return join(this.sep, paths);\n  },\n  extname: function (filepath) {\n    return extname(this.sep, filepath);\n  },\n  dirname: function (filepath) {\n    return dirname(this.sep, filepath);\n  },\n  isAbsolute: function (filepath) {\n    return isAbsolute(true, filepath);\n  },\n  relative: function (from, to) {\n    return relative(this.sep, from, to);\n  },\n  resolve: function (...paths) {\n    return resolve(this.sep, paths);\n  },\n  parse: function (filepath) {\n    return parse(this.sep, filepath);\n  },\n  format: function (pathObject) {\n    return format(this.sep, pathObject);\n  },\n  toNamespacedPath: function (filepath) {\n    return filepath; // no-op\n  }\n};\n\nconst path = PosixPath;\npath.win32 = Win32Path;\npath.posix = PosixPath;\n\nconst PosixConstants = {\n  UV_UDP_REUSEADDR: 4,\n  dlopen: {},\n  errno: {\n    E2BIG: 7,\n    EACCES: 13,\n    EADDRINUSE: 48,\n    EADDRNOTAVAIL: 49,\n    EAFNOSUPPORT: 47,\n    EAGAIN: 35,\n    EALREADY: 37,\n    EBADF: 9,\n    EBADMSG: 94,\n    EBUSY: 16,\n    ECANCELED: 89,\n    ECHILD: 10,\n    ECONNABORTED: 53,\n    ECONNREFUSED: 61,\n    ECONNRESET: 54,\n    EDEADLK: 11,\n    EDESTADDRREQ: 39,\n    EDOM: 33,\n    EDQUOT: 69,\n    EEXIST: 17,\n    EFAULT: 14,\n    EFBIG: 27,\n    EHOSTUNREACH: 65,\n    EIDRM: 90,\n    EILSEQ: 92,\n    EINPROGRESS: 36,\n    EINTR: 4,\n    EINVAL: 22,\n    EIO: 5,\n    EISCONN: 56,\n    EISDIR: 21,\n    ELOOP: 62,\n    EMFILE: 24,\n    EMLINK: 31,\n    EMSGSIZE: 40,\n    EMULTIHOP: 95,\n    ENAMETOOLONG: 63,\n    ENETDOWN: 50,\n    ENETRESET: 52,\n    ENETUNREACH: 51,\n    ENFILE: 23,\n    ENOBUFS: 55,\n    ENODATA: 96,\n    ENODEV: 19,\n    ENOENT: 2,\n    ENOEXEC: 8,\n    ENOLCK: 77,\n    ENOLINK: 97,\n    ENOMEM: 12,\n    ENOMSG: 91,\n    ENOPROTOOPT: 42,\n    ENOSPC: 28,\n    ENOSR: 98,\n    ENOSTR: 99,\n    ENOSYS: 78,\n    ENOTCONN: 57,\n    ENOTDIR: 20,\n    ENOTEMPTY: 66,\n    ENOTSOCK: 38,\n    ENOTSUP: 45,\n    ENOTTY: 25,\n    ENXIO: 6,\n    EOPNOTSUPP: 102,\n    EOVERFLOW: 84,\n    EPERM: 1,\n    EPIPE: 32,\n    EPROTO: 100,\n    EPROTONOSUPPORT: 43,\n    EPROTOTYPE: 41,\n    ERANGE: 34,\n    EROFS: 30,\n    ESPIPE: 29,\n    ESRCH: 3,\n    ESTALE: 70,\n    ETIME: 101,\n    ETIMEDOUT: 60,\n    ETXTBSY: 26,\n    EWOULDBLOCK: 35,\n    EXDEV: 18\n  },\n  signals: {\n    SIGHUP: 1,\n    SIGINT: 2,\n    SIGQUIT: 3,\n    SIGILL: 4,\n    SIGTRAP: 5,\n    SIGABRT: 6,\n    SIGIOT: 6,\n    SIGBUS: 10,\n    SIGFPE: 8,\n    SIGKILL: 9,\n    SIGUSR1: 30,\n    SIGSEGV: 11,\n    SIGUSR2: 31,\n    SIGPIPE: 13,\n    SIGALRM: 14,\n    SIGTERM: 15,\n    SIGCHLD: 20,\n    SIGCONT: 19,\n    SIGSTOP: 17,\n    SIGTSTP: 18,\n    SIGTTIN: 21,\n    SIGTTOU: 22,\n    SIGURG: 16,\n    SIGXCPU: 24,\n    SIGXFSZ: 25,\n    SIGVTALRM: 26,\n    SIGPROF: 27,\n    SIGWINCH: 28,\n    SIGIO: 23,\n    SIGINFO: 29,\n    SIGSYS: 12\n  },\n  priority: {\n    PRIORITY_LOW: 19,\n    PRIORITY_BELOW_NORMAL: 10,\n    PRIORITY_NORMAL: 0,\n    PRIORITY_ABOVE_NORMAL: -7,\n    PRIORITY_HIGH: -14,\n    PRIORITY_HIGHEST: -20\n  }\n};\n\n// default implementations\nconst OS = {\n  EOL: '\\n',\n  arch: () => process.arch,\n  constants: PosixConstants,\n  cpus: () => {\n    const count = Ti.Platform.processorCount;\n    const array = [];\n    for (let i = 0; i < count; i++) {\n      array.push({\n        model: 'unknown',\n        speed: 0,\n        times: {\n          user: 0,\n          nice: 0,\n          sys: 0,\n          idle: 0,\n          irq: 0\n        }\n      });\n    }\n    return array;\n  },\n  endianness: () => {\n    // TODO: Cache the value!\n    const result = Ti.Codec.getNativeByteOrder();\n    if (result === Ti.Codec.LITTLE_ENDIAN) {\n      return 'LE';\n    }\n    return 'BE';\n  },\n  freemem: () => Ti.Platform.availableMemory,\n  getPriority: () => 0,\n  // fake it\n  homedir: () => Ti.Filesystem.applicationDataDirectory,\n  // fake it\n  hostname: () => Ti.Platform.address,\n  // fake it\n  loadavg: () => [0, 0, 0],\n  // fake it\n  networkInterfaces: () => {},\n  // FIXME: What do we do here? We might be able to piece some of this together using Ti.Platform.netmask, Ti.Platform.address\n  platform: () => process.platform,\n  release: () => Ti.Platform.version,\n  setPriority: () => {},\n  // no-op, fake it\n  /**\r\n   * The `os.tmpdir()` method returns a string specifying the operating system's default directory for temporary files.\r\n   * @return {string} [description]\r\n   */\n  tmpdir: () => Ti.Filesystem.tempDirectory,\n  /**\r\n   * The `os.totalmem()` method returns the total amount of system memory in bytes as an integer.\r\n   * @return {integer} [description]\r\n   */\n  totalmem: () => Ti.Platform.totalMemory,\n  type: () => 'Unknown',\n  // overridden per-platform at bottom\n  /**\r\n   * The `os.uptime()` method returns the system uptime in number of seconds.\r\n   * @return {integer} [description]\r\n   */\n  uptime: () => Ti.Platform.uptime,\n  userInfo: () => {\n    // fake it!\n    return {\n      uid: -1,\n      gid: -1,\n      username: Ti.Platform.username,\n      homedir: Ti.Filesystem.applicationDataDirectory,\n      shell: null\n    };\n  }\n};\n\n// On specific platforms, override implementations because we don't have them\n// yet and need to fake it, or to hack them\n// I'm also doing this in blocks to assign implementations that don't need to consult platform\n// type at runtime (hopefully speeding up execution at runtime)\n{\n  OS.cpus = () => Ti.Platform.cpus();\n  OS.type = () => 'Linux';\n}\n\nconst tty = {\n  isatty: () => false,\n  ReadStream: () => {\n    throw new Error('tty.ReadStream is not implemented');\n  },\n  WriteStream: () => {\n    throw new Error('tty.WriteStream is not implemented');\n  }\n};\n\nconst MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\nconst util = {\n  format: format$1,\n  formatWithOptions,\n  inspect,\n  isArray: Array.isArray,\n  isBoolean: value => typeof value === 'boolean',\n  isBuffer: BufferModule.Buffer.isBuffer,\n  isFunction: value => typeof value === 'function',\n  isNull: value => value === null,\n  isNullOrUndefined: value => value === undefined || value === null,\n  isNumber: value => typeof value === 'number',\n  isObject: value => value !== null && typeof value === 'object',\n  isPrimitive: value => typeof value !== 'object' && typeof value !== 'function' || value === null,\n  isString: value => typeof value === 'string',\n  isSymbol: value => typeof value === 'symbol',\n  isUndefined: value => value === undefined,\n  isRegExp: isRegExp,\n  isDate: isDate,\n  isError: e => Object.prototype.toString.call(e) === '[object Error]' || e instanceof Error,\n  log: string => {\n    const date = new Date();\n    const time = `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`;\n    // Produces output like: \"21 Feb 10:04:23 - message\"\n    console.log(`${date.getDate()} ${MONTHS[date.getMonth()]} ${time} - ${string}`);\n  },\n  print: (...args) => console.log(args.join('')),\n  // FIXME: Shouldn't add trailing newline like console.log does!\n  puts: (...args) => console.log(args.join('\\n')),\n  error: (...args) => console.error(args.join('\\n')),\n  debug: string => console.error(`DEBUG: ${string}`),\n  types\n};\n\n/**\r\n * @param {Function} constructor subclass\r\n * @param {Function} superConstructor base class\r\n * @returns {void}\r\n */\nutil.inherits = function (constructor, superConstructor) {\n  assertArgumentType(constructor, 'constructor', 'Function');\n  assertArgumentType(superConstructor, 'superConstructor', 'Function');\n  assertArgumentType(superConstructor.prototype, 'superConstructor.prototype', 'Object');\n  Object.defineProperty(constructor, 'super_', {\n    value: superConstructor\n  });\n  Object.setPrototypeOf(constructor.prototype, superConstructor.prototype);\n};\n\n/**\r\n * @param {Function} original original function to wrap which is expected to have a final callback argument\r\n * @returns {Function} function that returns a Promise\r\n */\nutil.promisify = function (original) {\n  assertArgumentType(original, 'original', 'Function');\n  function wrapped(...args) {\n    return new Promise((resolve, reject) => {\n      original.call(this, ...args, (err, result) => {\n        if (err) {\n          return reject(err);\n        }\n        return resolve(result);\n      });\n    });\n  }\n  // TODO: Copy properties from original to wrapped\n  // TODO: hook prototype chain up from wrapped to original\n  // TODO: Support custom promisify hooks\n  return wrapped;\n};\n\n/**\r\n * @param {Function} original original function to convert from async/Promise return value to a callback style\r\n * @returns {Function} wrapped function\r\n */\nutil.callbackify = function (original) {\n  assertArgumentType(original, 'original', 'Function');\n  function wrapped(...args) {\n    const callback = args.pop();\n    const promise = original.apply(this, args);\n    promise.then(result => {\n      // eslint-disable-line promise/always-return\n      callback(null, result); // eslint-disable-line promise/no-callback-in-promise\n    }).catch(err => {\n      if (!err) {\n        const wrappedError = new Error('Promise was rejected with falsy value');\n        wrappedError.reason = err;\n        err = wrappedError;\n      }\n      callback(err); // eslint-disable-line promise/no-callback-in-promise\n    });\n  }\n\n  return wrapped;\n};\n\n/**\r\n * @param {Function} func function to deprecate/wrap\r\n * @param {string} string message to give when deprecation warning is emitted\r\n * @param {string} code deprecation code to use to group warnings\r\n * @returns {Function} wrapped function\r\n */\nutil.deprecate = function (func, string, code) {\n  // eslint-disable-line no-unused-vars\n  if (process.noDeprecation) {\n    return func; // skip the wrapping!\n  }\n  // TODO: Support `code` argument by tracking a map of codes we've warned about\n  function wrapped(...args) {\n    let warned = false;\n    if (!warned) {\n      process.emitWarning(string, 'DeprecationWarning');\n      warned = true;\n    }\n    return func.apply(this, args);\n  }\n  return wrapped;\n};\n// TODO: Support debuglog? What is our equivalent of process.env('NODE_DEBUG')?\nconst noop = () => {};\nutil.debuglog = () => {\n  return noop;\n};\n\nconst DEFAULT_MESSAGES = {\n  deepStrictEqual: 'Expected values to be strictly deep-equal:',\n  strictEqual: 'Expected values to be strictly equal:',\n  deepEqual: 'Expected values to be loosely deep-equal:',\n  equal: 'Expected values to be loosely equal:',\n  notDeepStrictEqual: 'Expected \"actual\" not to be strictly deep-equal to:',\n  notStrictEqual: 'Expected \"actual\" to be strictly unequal to:',\n  notDeepEqual: 'Expected \"actual\" not to be loosely deep-equal to:',\n  notEqual: 'Expected \"actual\" to be loosely unequal to:'\n};\n\n// Fake enums to use internally\nconst COMPARE_TYPE = {\n  Object: 0,\n  Map: 1,\n  Set: 2\n};\nconst STRICTNESS = {\n  Strict: 0,\n  Loose: 1\n};\nclass AssertionError extends Error {\n  constructor(options) {\n    let {\n      actual,\n      expected,\n      message,\n      operator\n    } = options;\n    if (!message) {\n      // FIXME: Generate the rest of the message with diff of actual/expected!\n      message = `${DEFAULT_MESSAGES[operator]}\\n\\n`;\n    }\n    super(message);\n    this.actual = actual;\n    this.expected = expected;\n    this.operator = operator;\n    this.generatedMessage = !message;\n    this.name = 'AssertionError [ERR_ASSERTION]';\n    this.code = 'ERR_ASSERTION';\n  }\n}\n\n// TODO: Can we define AssertStrict and AssertLoose as subclasses of a base Assert class\n// that class holds impls for shared methods, subclasses override specific\n// comparisons used (Object.is vs ===)?\n\nconst assert = (value, message) => assert.ok(value, message);\nassert.AssertionError = AssertionError;\nassert.ok = (...args) => {\n  const value = args[0];\n  if (value) {\n    return;\n  }\n  let message = args[1];\n  let generatedMessage = false;\n\n  // Check if value (1st arg) was not supplied!\n  // Have to use ugly hack on args definition to do so\n  if (args.length === 0) {\n    message = 'No value argument passed to `assert.ok()`';\n    generatedMessage = true;\n  } else if (message == null) {\n    // eslint-disable-line no-eq-null,eqeqeq\n    // TODO: generate rest of the message. Node actually reads the input file! The hacked browserify does not do this\n    // It treates ok failing like `value == true` failing\n    message = 'The expression evaluated to a falsy value:\\n\\n';\n    generatedMessage = true;\n  } else if (message instanceof Error) {\n    throw message;\n  }\n  const err = new AssertionError({\n    actual: value,\n    expected: true,\n    message,\n    operator: '=='\n  });\n  err.generatedMessage = generatedMessage;\n  throw err;\n};\nfunction throwError(obj) {\n  // If message is an Error object, throw that instead!\n  if (obj.message instanceof Error) {\n    throw obj.message;\n  }\n  throw new AssertionError(obj);\n}\nassert.equal = (actual, expected, message) => {\n  if (actual == expected) {\n    // eslint-disable-line eqeqeq\n    return;\n  }\n  throwError({\n    actual,\n    expected,\n    message,\n    operator: 'equal'\n  });\n};\nassert.strictEqual = (actual, expected, message) => {\n  if (Object.is(actual, expected)) {\n    // provides SameValue comparison for us\n    return;\n  }\n  throwError({\n    actual,\n    expected,\n    message,\n    operator: 'strictEqual'\n  });\n};\nassert.notEqual = (actual, expected, message) => {\n  if (actual != expected) {\n    // eslint-disable-line eqeqeq\n    return;\n  }\n  throwError({\n    actual,\n    expected,\n    message,\n    operator: 'notEqual'\n  });\n};\nassert.notStrictEqual = (actual, expected, message) => {\n  if (!Object.is(actual, expected)) {\n    // provides SameValue comparison for us\n    return;\n  }\n  throwError({\n    actual,\n    expected,\n    message,\n    operator: 'notStrictEqual'\n  });\n};\nconst isPrimitive = value => {\n  return typeof value !== 'object' && typeof value !== 'function' || value === null;\n};\n\n/**\r\n * @param {Map} actual map we are comparing\r\n * @param {Map} expected map we're comparing against\r\n * @param {STRICTNESS.Loose|strictness.Strict} strictness how to compare\r\n * @param {object} references memoized references to objects in the deepEqual hierarchy\r\n * @returns {boolean}\r\n */\nfunction compareMaps(actual, expected, strictness, references) {\n  const looseChecks = new Set(); // keep track of objects we need to test more extensively than using #get()/#has()\n  for (const [key, value] of actual) {\n    if (typeof key === 'object' && key !== null) {\n      // non-null object. We need to do our own checking, not use get()/has()\n      looseChecks.add(key);\n    } else {\n      // handle \"primitives\"\n      if (expected.has(key) && deepEqual(value, expected.get(key), strictness, references)) {\n        // yay! a nice easy match - both key and value matched exactly - move on\n        continue;\n      }\n      if (strictness === STRICTNESS.Strict) {\n        // if we didn't match key/value perfectly in strict mode, fail right away\n        return false;\n      }\n\n      // ok, so it didn't match key/value perfectly - but we're in loose mode, so fall back to try again\n      looseChecks.add(key);\n    }\n  }\n  if (looseChecks.size === 0) {\n    // no loose ends to tie up, everything matched\n    return true;\n  }\n\n  // only go through the second Map once!\n  for (const [expectedKey, expectedValue] of expected) {\n    // if it's not a non-null object in strict mode, fail!\n    // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)\n    // Note that this shouldn't ever happen since we should be returning false immediately above\n    if (strictness === STRICTNESS.Strict && !(typeof expectedKey === 'object' && expectedKey !== null)) {\n      return false;\n    }\n\n    // otherwise, test it // TODO: Wish we could use #find() like on an Array, but Set doesn't have it!\n    let found = false;\n    for (const key of looseChecks) {\n      // if both key and value matches\n      if (deepEqual(key, expectedKey, strictness, references) && deepEqual(actual.get(key), expectedValue, strictness, references)) {\n        found = true;\n        looseChecks.delete(key); // remove from our looseChecks Set since we already matched it\n        break;\n      }\n    }\n    // if not found, we failed to match\n    if (!found) {\n      return false;\n    }\n  }\n  // did we leave un-matched keys? if so, fail\n  return looseChecks.size === 0;\n}\n\n/**\r\n * @param {Set} actual map we are comparing\r\n * @param {Set} expected map we're comparing against\r\n * @param {strictness.Loose|strictness.Strict} strictness how to compare\r\n * @param {object} references memoized references to objects in the deepEqual hierarchy\r\n * @returns {boolean}\r\n */\nfunction compareSets(actual, expected, strictness, references) {\n  const looseChecks = new Set(); // keep track of values we need to test more extensively than using #has()\n  for (const value of actual) {\n    if (typeof value === 'object' && value !== null) {\n      // non-null object. We need to do our own checking, not use has()\n      looseChecks.add(value);\n    } else if (!expected.has(value)) {\n      // FIXME: has does \"same-value-zero\" check, which is like Object.is except for -0/+0 being considered equal\n      // so may need to special case that here, that'd have to be in an else below (since has will return true here)\n\n      if (strictness === STRICTNESS.Strict) {\n        // failed \"same-value\" match for primitive in strict mode, so fail right away\n        return false;\n      }\n\n      // When doing loose check, we need to fall back to looser check than #has(), so we can't just return false immediately here\n      // add to set of values to check more thoroughly\n      looseChecks.add(value);\n    }\n  }\n  if (looseChecks.size === 0) {\n    // no loose ends to tie up, everything matched\n    return true;\n  }\n\n  // Try to whittle down the loose checks set to be empty...\n  // only go through the second Set once!\n  for (const expectedValue of expected) {\n    // if it's not a non-null object in strict mode, fail!\n    // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)\n    // Note that this shouldn't ever happen since we should be returning false immediately above\n    if (strictness === STRICTNESS.Strict && !(typeof expectedValue === 'object' && expectedValue !== null)) {\n      return false;\n    }\n    let found = false;\n    for (const object of looseChecks) {\n      if (deepEqual(object, expectedValue, strictness, references)) {\n        found = true; // found a match!\n        looseChecks.delete(object); // remove from our looseChecks Set since we matched it\n        break;\n      }\n    }\n    // if not found, we failed to match\n    if (!found) {\n      return false;\n    }\n  }\n\n  // did we leave un-matched values? if so, fail\n  return looseChecks.size === 0;\n}\n\n/**\r\n * @param {*} actual value we are comparing\r\n * @param {*} expected values we're comparing against\r\n * @param {STRICTNESS.Strict|STRICTNESS.Loose} strictness how strict a comparison to do\r\n * @param {object} [references] optional object to keep track of circular references in the hierarchy\r\n * @param {Map<object,number>} [references.actual] mapping from objects visited (on `actual`) to their depth\r\n * @param {Map<object,number>} [references.expected] mapping from objects visited (on `expected`) to their depth\r\n * @param {number} [references.depth] The current depth of the hierarchy\r\n * @returns {boolean}\r\n */\nfunction deepEqual(actual, expected, strictness, references) {\n  // if primitives, compare using Object.is\n  // This handles: null, undefined, number, string, boolean\n  if (isPrimitive(actual) && isPrimitive(expected)) {\n    if (strictness === STRICTNESS.Strict) {\n      return Object.is(actual, expected);\n    } else {\n      return actual == expected; // eslint-disable-line eqeqeq\n    }\n  }\n\n  // Now we have various objects/functions:\n  // Date, Error, RegExp, Array, Map, Set, Object, Function, Arrow functions, WeakMap, DataView, ArrayBuffer, WeakSet, typed arrays\n  // notably, this includes \"boxed\" primitives created by new Boolean(false), new String('value'), Symbol('whatever'), etc\n\n  // Type tags of objects should be the same\n  const actualTag = Object.prototype.toString.call(actual);\n  const expectedTag = Object.prototype.toString.call(expected);\n  if (actualTag !== expectedTag) {\n    return false;\n  }\n\n  // [[Prototype]] of objects are compared using the Strict Equality Comparison.\n  if (strictness === STRICTNESS.Strict) {\n    // don't check prototype when doing \"loose\"\n    const actualPrototype = Object.getPrototypeOf(actual);\n    const expectedPrototype = Object.getPrototypeOf(expected);\n    if (actualPrototype !== expectedPrototype) {\n      return false;\n    }\n  }\n  let comparison = COMPARE_TYPE.Object;\n  if (util.types.isRegExp(actual)) {\n    // RegExp source and flags should match\n    if (!util.types.isRegExp(expected) || actual.flags !== expected.flags || actual.source !== expected.source) {\n      return false;\n    }\n    // continue on to check properties...\n  } else if (util.types.isDate(actual)) {\n    // Date's underlying time should match\n    if (!util.types.isDate(expected) || actual.getTime() !== expected.getTime()) {\n      return false;\n    }\n    // continue on to check properties...\n  } else if (actual instanceof Error) {\n    // Error's name and message must match\n    if (!(expected instanceof Error) || actual.name !== expected.name || actual.message !== expected.message) {\n      return false;\n    }\n    // continue on to check properties...\n  } else if (Array.isArray(actual)) {\n    // if array lengths differ, quick fail\n    if (!Array.isArray(expected) || actual.length !== expected.length) {\n      return false;\n    }\n    // continue on to check properties...\n  } else if (util.types.isBoxedPrimitive(actual)) {\n    if (!util.types.isBoxedPrimitive(expected)) {\n      return false;\n    }\n    // check that they're the same type of wrapped primitive and then call the relevant valueOf() for that type to compare them!\n    if (util.types.isNumberObject(actual) && (!util.types.isNumberObject(expected) || !Object.is(Number.prototype.valueOf.call(actual), Number.prototype.valueOf.call(expected)))) {\n      return false;\n    } else if (util.types.isStringObject(actual) && (!util.types.isStringObject(expected) || String.prototype.valueOf.call(actual) !== String.prototype.valueOf.call(expected))) {\n      return false;\n    } else if (util.types.isBooleanObject(actual) && (!util.types.isBooleanObject(expected) || Boolean.prototype.valueOf.call(actual) !== Boolean.prototype.valueOf.call(expected))) {\n      return false;\n      // FIXME: Uncomment when we support BigInt cross-platform!\n      // } else if (util.types.isBigIntObject(actual)\n      // \t&& (!util.types.isBigIntObject(expected)\n      // \t\t|| BigInt.prototype.valueOf.call(actual) !== BigInt.prototype.valueOf.call(expected))) {\n      // \treturn false;\n    } else if (util.types.isSymbolObject(actual) && (!util.types.isSymbolObject(expected) || Symbol.prototype.valueOf.call(actual) !== Symbol.prototype.valueOf.call(expected))) {\n      return false;\n    }\n    // continue on to check properties...\n  } else if (util.types.isSet(actual)) {\n    if (!util.types.isSet(expected) || actual.size !== expected.size) {\n      return false;\n    }\n    comparison = COMPARE_TYPE.Set;\n    // continue on to check properties...\n  } else if (util.types.isMap(actual)) {\n    if (!util.types.isMap(expected) || actual.size !== expected.size) {\n      return false;\n    }\n    comparison = COMPARE_TYPE.Map;\n    // continue on to check properties...\n  }\n\n  // Now iterate over properties and compare them!\n  const actualKeys = Object.keys(actual); // for an array, this will return the indices that have values\n  const expectedKeys = Object.keys(expected); // and it just magically works\n  // Must have same number of properties\n  if (actualKeys.length !== expectedKeys.length) {\n    return false;\n  }\n\n  // Are they the same keys? If one is missing, then no, fail right away\n  if (!actualKeys.every(key => Object.prototype.hasOwnProperty.call(expected, key))) {\n    return false;\n  }\n\n  // Don't check own symbols when doing \"loose\"\n  if (strictness === STRICTNESS.Strict) {\n    const actualSymbols = Object.getOwnPropertySymbols(actual);\n    const expectedSymbols = Object.getOwnPropertySymbols(expected);\n\n    // Must have same number of symbols\n    if (actualSymbols.length !== expectedSymbols.length) {\n      return false;\n    }\n    if (actualSymbols.length > 0) {\n      // Have to filter them down to enumerable symbols!\n      for (const key of actualSymbols) {\n        const actualIsEnumerable = Object.prototype.propertyIsEnumerable.call(actual, key);\n        const expectedIsEnumerable = Object.prototype.propertyIsEnumerable.call(expected, key);\n        if (actualIsEnumerable !== expectedIsEnumerable) {\n          return false; // they differ on whetehr symbol is enumerable, fail!\n        } else if (actualIsEnumerable) {\n          // it's enumerable, add to keys to check\n          actualKeys.push(key);\n          expectedKeys.push(key);\n        }\n      }\n    }\n  }\n\n  // Avoid circular references!\n  // Record map from objects to depth in the hierarchy\n  if (references === undefined) {\n    references = {\n      actual: new Map(),\n      expected: new Map(),\n      depth: 0\n    };\n  } else {\n    // see if we've already recorded these objects.\n    // if so, make sure they refer to same depth in object hierarchy\n    const memoizedActual = references.actual.get(actual);\n    if (memoizedActual !== undefined) {\n      const memoizedExpected = references.expected.get(expected);\n      if (memoizedExpected !== undefined) {\n        return memoizedActual === memoizedExpected;\n      }\n    }\n    references.depth++;\n  }\n  // store the object -> depth mapping\n  references.actual.set(actual, references.depth);\n  references.expected.set(expected, references.depth);\n\n  // When comparing Maps/Sets, compare elements before custom properties\n  let result = true;\n  if (comparison === COMPARE_TYPE.Set) {\n    result = compareSets(actual, expected, strictness, references);\n  } else if (comparison === COMPARE_TYPE.Map) {\n    result = compareMaps(actual, expected, strictness, references);\n  }\n  if (result) {\n    // Now loop over keys and compare them to each other!\n    for (const key of actualKeys) {\n      if (!deepEqual(actual[key], expected[key], strictness, references)) {\n        result = false;\n        break;\n      }\n    }\n  }\n  // wipe the object to depth mapping for these objects now\n  references.actual.delete(actual);\n  references.expected.delete(expected);\n  return result;\n}\nassert.deepStrictEqual = (actual, expected, message) => {\n  if (!deepEqual(actual, expected, STRICTNESS.Strict)) {\n    throwError({\n      actual,\n      expected,\n      message,\n      operator: 'deepStrictEqual'\n    });\n  }\n};\nassert.notDeepStrictEqual = (actual, expected, message) => {\n  if (deepEqual(actual, expected, STRICTNESS.Strict)) {\n    throwError({\n      actual,\n      expected,\n      message,\n      operator: 'notDeepStrictEqual'\n    });\n  }\n};\nassert.deepEqual = (actual, expected, message) => {\n  if (!deepEqual(actual, expected, STRICTNESS.Loose)) {\n    throwError({\n      actual,\n      expected,\n      message,\n      operator: 'deepEqual'\n    });\n  }\n};\nassert.notDeepEqual = (actual, expected, message) => {\n  if (deepEqual(actual, expected, STRICTNESS.Loose)) {\n    throwError({\n      actual,\n      expected,\n      message,\n      operator: 'notDeepEqual'\n    });\n  }\n};\nassert.fail = (message = 'Failed') => throwError({\n  message\n});\nconst NO_EXCEPTION = {};\nfunction execute(fn) {\n  assertArgumentType(fn, 'fn', 'Function');\n  try {\n    fn();\n  } catch (e) {\n    return e;\n  }\n  return NO_EXCEPTION;\n}\nfunction isPromiseLike(fn) {\n  return util.types.isPromise(fn) || fn && typeof fn === 'object' && typeof fn.then === 'function';\n}\nasync function executePromise(fn) {\n  let promise;\n  const fnType = typeof fn;\n  if (fnType === 'function') {\n    promise = fn();\n    if (!isPromiseLike(promise)) {\n      throw new TypeError(`Expected instanceof Promise to be returned from the \"fn\" function but got ${typeof promise}`);\n    }\n  } else {\n    if (!isPromiseLike(fn)) {\n      throw new TypeError(`The \"fn\" argument must be of type Function or Promise. Received type ${fnType}`);\n    }\n    promise = fn;\n  }\n  try {\n    await promise;\n  } catch (e) {\n    return e;\n  }\n  return NO_EXCEPTION;\n}\nassert.throws = (fn, error, message) => {\n  const actual = execute(fn);\n  if (actual === NO_EXCEPTION) {\n    // FIXME: append message if not null\n    throwError({\n      actual: undefined,\n      expected: error,\n      message: 'Missing expected exception.',\n      operator: 'throws'\n    });\n    return;\n  }\n\n  // They didn't specify how to validate, so just roll with it\n  if (!error) {\n    return;\n  }\n  if (!checkError(actual, error, message)) {\n    throw actual; // throw the Error it did generate\n  }\n};\n\nassert.rejects = async function (asyncFn, error, message) {\n  const actual = await executePromise(asyncFn);\n  if (actual === NO_EXCEPTION) {\n    // FIXME: append message if not null\n    throwError({\n      actual: undefined,\n      expected: error,\n      message: 'Missing expected exception.',\n      operator: 'rejects'\n    });\n    return;\n  }\n\n  // They didn't specify how to validate, so just roll with it\n  if (!error) {\n    return;\n  }\n  if (!checkError(actual, error, message)) {\n    throw actual; // throw the Error it did generate\n  }\n};\n\nassert.doesNotThrow = (fn, error, message) => {\n  const actual = execute(fn);\n  // no Error, just return\n  if (actual === NO_EXCEPTION) {\n    return;\n  }\n\n  // They didn't specify how to validate, so just re-throw\n  if (!error) {\n    throw actual;\n  }\n\n  // If error matches expected, throw an AssertionError\n  if (checkError(actual, error)) {\n    throwError({\n      actual,\n      expected: error,\n      operator: 'doesNotThrow',\n      message: `Got unwanted exception${message ? ': ' + message : '.'}`\n    });\n    return;\n  }\n  // doesn't match, re-throw\n  throw actual;\n};\nassert.doesNotReject = async function (fn, error, message) {\n  const actual = await executePromise(fn);\n  // no Error, just return\n  if (actual === NO_EXCEPTION) {\n    return;\n  }\n\n  // They didn't specify how to validate, so just re-throw\n  if (!error) {\n    throw actual;\n  }\n\n  // If error matches expected, throw an AssertionError\n  if (checkError(actual, error)) {\n    throwError({\n      actual,\n      expected: error,\n      operator: 'doesNotThrow',\n      message: `Got unwanted exception${message ? ': ' + message : '.'}`\n    });\n    return;\n  }\n  // doesn't match, re-throw\n  throw actual;\n};\n\n/**\r\n * @param {Error} actual the actual Error generated by the wrapped function/block\r\n * @param {object|RegExp|Function|Error|Class} expected The value to test against the Error\r\n * @param {string} [message] custom message to append\r\n * @returns {boolean} true if the Error matches the expected value/object\r\n */\nfunction checkError(actual, expected, message) {\n  // What we do here depends on what `expected` is:\n  // function - call it to validate\n  // object - test properties against actual\n  // Regexp - test against actual.toString()\n  // Error type - check type matches\n  // Error instance - compare properties\n  if (typeof expected === 'object') {\n    if (util.types.isRegExp(expected)) {\n      return expected.test(actual); // does the error match the RegExp expression? if so, pass\n    }\n\n    // Test properties (`expected` is either a generic Object or an Error instance)\n    const keys = Object.keys(expected);\n    // If we're testing against an instance of an Error, we need to hack in name/message properties.\n    if (expected instanceof Error) {\n      keys.unshift('name', 'message'); // we want to compare name and message, but they're not set as enumerable on Error\n    }\n\n    for (const key of keys) {\n      if (!deepEqual(actual[key], expected[key], STRICTNESS.Strict)) {\n        if (!message) {\n          // generate a meaningful message! Cheat by treating like equality check of values\n          // then steal the message it generated\n          try {\n            throwError({\n              actual: actual[key],\n              expected: expected[key],\n              operator: 'deepStrictEqual'\n            });\n          } catch (err) {\n            message = err.message;\n          }\n        }\n        throwError({\n          actual,\n          expected,\n          message,\n          operator: 'throws'\n        });\n        return false;\n      }\n    }\n    return true; // They all matched, pass!\n  } else if (typeof expected === 'function') {\n    // if `expected` is a \"type\" and actual is an instance of that type, then pass\n    if (expected.prototype != null && actual instanceof expected) {\n      // eslint-disable-line no-eq-null,eqeqeq\n      return true;\n    }\n\n    // If `expected` is a subclass of Error but `actual` wasn't an instance of it (above), fail\n    if (Object.prototype.isPrototypeOf.call(Error, expected)) {\n      return false;\n    }\n\n    // ok, let's assume what's left is that `expected` was a validation function,\n    // so call it with empty `this` and single argument of the actual error we received\n    return expected.call({}, actual);\n  }\n  return false;\n}\nassert.ifError = value => {\n  if (value === null || value === undefined) {\n    return;\n  }\n  throwError({\n    actual: value,\n    expected: null,\n    message: `ifError got unwanted exception: ${value}`,\n    operator: 'ifError'\n  });\n};\n\n// Create \"strict\" copy which overrides \"loose\" methods to call strict equivalents\nassert.strict = (value, message) => assert.ok(value, message);\n// \"Copy\" methods from assert to assert.strict!\nObject.assign(assert.strict, assert);\n// Override the \"loose\" methods to point to the strict ones\nassert.strict.deepEqual = assert.deepStrictEqual;\nassert.strict.notDeepEqual = assert.notDeepStrictEqual;\nassert.strict.equal = assert.strictEqual;\nassert.strict.notEqual = assert.notStrictEqual;\n// hang strict off itself\nassert.strict.strict = assert.strict;\n\n/**\r\n * @param {string} [encoding='utf8'] The character encoding the `StringDecoder` will use.\r\n */\nfunction StringDecoder(encoding = 'utf8') {\n  this.encoding = encoding.toLowerCase();\n  switch (this.encoding) {\n    case 'utf8':\n    case 'utf-8':\n      this._impl = new Utf8StringDecoder();\n      break;\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16-le':\n    case 'utf16le':\n      this._impl = new Utf16StringDecoder();\n      break;\n    case 'base64':\n      this._impl = new Base64StringDecoder();\n      break;\n    default:\n      this._impl = new StringDecoderImpl(this.encoding);\n      break;\n  }\n}\n\n/**\r\n * Returns any remaining input stored in the internal buffer as a string.\r\n * Bytes representing incomplete UTF-8 and UTF-16 characters will be replaced with substitution\r\n * characters appropriate for the character encoding.\r\n *\r\n * If the buffer argument is provided, one final call to stringDecoder.write() is performed before returning the remaining input.\r\n * @param {Buffer} [buffer] containing the bytes to decode.\r\n * @returns {string}\r\n */\nStringDecoder.prototype.end = function end(buffer) {\n  return this._impl.end(buffer);\n};\n\n/**\r\n * Returns a decoded string, ensuring that any incomplete multibyte characters at the end of the Buffer, or\r\n * TypedArray, or DataView are omitted from the returned string and stored in an internal buffer for the\r\n * next call to stringDecoder.write() or stringDecoder.end().\r\n * @param {Buffer|TypedArray|DataView} buffer containing the bytes to decode.\r\n * @returns {string}\r\n */\nStringDecoder.prototype.write = function write(buffer) {\n  if (typeof buffer === 'string') {\n    return buffer;\n  }\n  // empty string for empty buffer\n  if (buffer.length === 0) {\n    return '';\n  }\n  return this._impl.write(buffer);\n};\n\n/**\r\n * This is the base class. We override parts of it for certain encodings. For ascii/hex/binary/latin1 the impl is super-easy\r\n */\nclass StringDecoderImpl {\n  constructor(encoding = 'utf8') {\n    this.encoding = encoding;\n    this.byteCount = 0;\n    this.charLength = 1;\n  }\n\n  // the actual underlying implementation!\n  end(buffer) {\n    if (buffer && buffer.length !== 0) {\n      return this.write(buffer);\n    }\n    return '';\n  }\n  write(buffer) {\n    if (buffer && buffer.length !== 0) {\n      return buffer.toString(this.encoding); // single byte character encodings are a cinch\n    }\n\n    return ''; // no buffer, or empty\n  }\n}\n\n// For multi-byte encodings, let's implement some base logic...\nclass MultiByteStringDecoderImpl extends StringDecoderImpl {\n  constructor(encoding, bytesPerChar) {\n    super(encoding);\n    this.incomplete = Buffer.allocUnsafe(bytesPerChar); // temporary incomplete character buffer\n  }\n\n  /**\r\n   * @typedef {Object} IncompleteCharObject\r\n   * @property {integer} bytesNeeded bytes missing to complete the character\r\n   * @property {integer} charLength bytes expected to complete the character\r\n   * @property {integer} index location in the buffer where the character starts\r\n   */\n\n  /**\r\n   * Given a Buffer, sees if we have an incomplete \"character\" at the end of it.\r\n   * Returns info on that:\r\n   * - bytesNeeded: 0-3, number of bytes still remaining\r\n   * - charLength: expected number of bytes for the incomplete character\r\n   * - index: index in the buffer where the incomplete character begins\r\n   * @param {Buffer} _buffer Buffer we are checking to see if it has an incompelte \"character\" at the end\r\n   */\n  _checkIncompleteBytes(_buffer) {\n    throw new Error('subclasses must override!');\n  }\n  _incompleteEnd() {\n    throw new Error('subclasses must override!');\n  }\n  _incompleteBufferEmptied() {\n    // typically we reset byte count back to 0 and character length to 1\n    this.byteCount = 0;\n    this.charLength = 1;\n  }\n  end(buffer) {\n    let result = super.end(buffer);\n    if (this.byteCount !== 0) {\n      // we have incomplete characters!\n      result += this._incompleteEnd();\n    }\n    this._incompleteBufferEmptied(); // reset our internals to \"wipe\" the incomplete buffer\n    return result;\n  }\n  write(buffer) {\n    // first let's see if we had some multi-byte character we didn't finish...\n    let char = '';\n    if (this.byteCount !== 0) {\n      // we still needed some bytes to finish the character\n      // How many bytes do we still need? charLength - bytes we received\n      const left = this.charLength - this.byteCount; // need 4, have 1? then we have 3 \"left\"\n\n      const bytesCopied = Math.min(left, buffer.length); // copy up to that many bytes\n      // copy bytes from `buffer` to our incomplete buffer\n      buffer.copy(this.incomplete, this.byteCount, 0, bytesCopied);\n      this.byteCount += bytesCopied; // record how many more bytes we copied...\n\n      if (bytesCopied < left) {\n        // still need more bytes to complete!\n        return '';\n      }\n\n      // we were able to complete, yay!\n      // grab the character we completed\n      char = this.incomplete.slice(0, this.charLength).toString(this.encoding);\n      // reset our counters\n      this._incompleteBufferEmptied();\n      // do we have any bytes left in this buffer?\n      if (bytesCopied === buffer.length) {\n        return char; // if not, return the character we finished!\n      }\n      // we still have more bytes, so slice the buffer up\n      buffer = buffer.slice(bytesCopied, buffer.length);\n    }\n\n    // check this buffer to see if it indicates we need more bytes?\n    const incompleteCharData = this._checkIncompleteBytes(buffer);\n    if (incompleteCharData.bytesNeeded === 0) {\n      return char + buffer.toString(this.encoding); // no incomplete bytes, return any character we completed plus the buffer\n    }\n\n    // ok so the buffer holds an incomplete character at it's end\n    this.charLength = incompleteCharData.charLength; // record how many bytes we need for the 'character'\n    const incompleteCharIndex = incompleteCharData.index; // this is the index of the multibyte character that is incomplete\n\n    // copy from index of incomplete character to end of buffer\n    const bytesToCopy = buffer.length - incompleteCharIndex;\n    buffer.copy(this.incomplete, 0, incompleteCharIndex, buffer.length);\n    this.byteCount = bytesToCopy; // record how many bytes we actually copied\n\n    if (bytesToCopy < buffer.length) {\n      // buffer had bytes before the incomplete character\n      // so smush any character we may have completed with any complete characters in the buffer\n      return char + buffer.toString(this.encoding, 0, incompleteCharIndex);\n    }\n    return char; // any now-completed character that was previously incomplete, possibly empty\n  }\n}\n\nclass Utf8StringDecoder extends MultiByteStringDecoderImpl {\n  constructor() {\n    super('utf8', 4);\n  }\n  _checkIncompleteBytes(buffer) {\n    const length = buffer.length;\n    // FIXME: In Node, they check the last character first!\n    // And they rely on Buffer#toString() to handle injecting the '\\ufffd' character for busted multi-byte sequences!\n    // iOS apparently just returns undefined in that special case and\n    // Android differs here because we don't work backwards from the last char\n    // Can we cheat here and...\n    // see https://github.com/nodejs/string_decoder/blob/master/lib/string_decoder.js#L173-L198\n    // - if we see a multi-byte character start, validate the next characters are continuation chars\n    // - if they're not replace the sequence with '\\ufffd', treat like that multi-byte character was \"completed\"\n\n    // Note that even if we do hack this, if there's some invalid multi-byte UTF-8 in the buffer that isn't at the last 3 bytes\n    // then we're at the mercy of the JS engine/platform code for handling that\n    // Here's someone's hack there: https://gist.github.com/oleganza/997155\n\n    // if buffer.length >= 3, check 3rd to last byte\n    if (length >= 3) {\n      let charLength = checkCharLengthForUTF8(buffer[length - 3]);\n      if (charLength === 4) {\n        return {\n          bytesNeeded: 1,\n          // we have 3 last bytes, need 4th\n          index: length - 3,\n          charLength: 4\n        };\n      }\n    }\n    // if buffer.length >= 2, check 2nd to last byte\n    if (length >= 2) {\n      let charLength = checkCharLengthForUTF8(buffer[length - 2]);\n      if (charLength >= 3) {\n        return {\n          bytesNeeded: charLength - 2,\n          // we have 2 bytes of whatever we need\n          index: length - 2,\n          charLength\n        };\n      }\n    }\n    // if buffer.length >= 1, check last byte\n    if (length >= 1) {\n      let charLength = checkCharLengthForUTF8(buffer[length - 1]);\n      if (charLength >= 2) {\n        return {\n          bytesNeeded: charLength - 1,\n          // we have 1 byte of whatever we need\n          index: length - 1,\n          charLength\n        };\n      }\n    }\n    // base case, no bytes needed - ends on complete character\n    return {\n      bytesNeeded: 0,\n      index: length - 1,\n      charLength: 1\n    };\n  }\n  _incompleteEnd() {\n    return '\\ufffd'; // we replace the missing character with a special utf8 char\n  }\n}\n\nclass Utf16StringDecoder extends MultiByteStringDecoderImpl {\n  constructor() {\n    super('utf16le', 4);\n  }\n  _checkIncompleteBytes(buffer) {\n    const length = buffer.length;\n    const modulo = length % 2;\n    // ok, we have a multiple of 2 bytes\n    if (modulo === 0) {\n      // is the last byte a leading/high surrogate?\n      const byte = buffer[buffer.length - 1];\n      if (byte >= 0xD8 && byte <= 0xDB) {\n        return {\n          bytesNeeded: 2,\n          charLength: 4,\n          index: length - 2\n        };\n      }\n\n      // we're good, not a surrogate, so we have our needed 2 bytes\n      return {\n        bytesNeeded: 0,\n        charLength: 2\n      };\n    }\n\n    // ok we have 1 byte left over, assume we need 2 to form the character\n    return {\n      bytesNeeded: 1,\n      index: length - 1,\n      charLength: 2\n    };\n  }\n  _incompleteEnd() {\n    // Just write out the last N bytes, hopefully the engine can handle it for us?\n    return this.incomplete.toString('utf16le', 0, this.byteCount);\n  }\n}\nclass Base64StringDecoder extends MultiByteStringDecoderImpl {\n  constructor() {\n    super('base64', 3);\n    this.charLength = 3; // always 3!\n  }\n\n  _checkIncompleteBytes(buffer) {\n    const length = buffer.length;\n    const modulo = length % 3;\n    // base64 needs 3 bytes always, so if we have that many (or a multiple), we have a complete buffer\n    if (modulo === 0) {\n      return {\n        bytesNeeded: 0,\n        charLength: 3\n      };\n    }\n\n    // ok we have 1 or 2 bytes left over\n    return {\n      bytesNeeded: 3 - modulo,\n      // always need 3, so if we have 1 left over -> need 2\n      index: length - modulo,\n      charLength: 3 // always need 3\n    };\n  }\n\n  _incompleteBufferEmptied() {\n    this.byteCount = 0;\n    this.charLength = 3; // always 3!\n  }\n\n  _incompleteEnd() {\n    // Just write out the last N bytes, it should insert the '=' placeholders\n    // it's not really 'missing'/'incomplete', just needs placeholder insertion\n    return this.incomplete.toString('base64', 0, this.byteCount);\n  }\n}\nfunction checkCharLengthForUTF8(byte) {\n  // 11110XXX => 1110 => 0x1E\n  if (byte >> 3 === 0x1E) {\n    return 4;\n  }\n\n  // 1110XXXX => 1110 => 0x1E\n  if (byte >> 4 === 0x0E) {\n    return 3;\n  }\n\n  // 110XXXXX => 110 => 0x06\n  if (byte >> 5 === 0x06) {\n    return 2;\n  }\n  return 1;\n}\nvar StringDecoder$1 = {\n  StringDecoder\n};\n\n// Keep track of printing out one-time warning messages for unsupported operations/options/arguments\nconst printedWarnings = {};\nfunction oneTimeWarning(key, msg) {\n  if (!printedWarnings[key]) {\n    console.warn(msg);\n    printedWarnings[key] = true;\n  }\n}\n/**\r\n * Prints a one-time warning message that we do not support the given API and performs an effective no-op\r\n * @param {string} moduleName name of the module/object\r\n * @param {string} name name of the function.property we don't support\r\n * @returns {Function} no-op function\r\n */\nfunction unsupportedNoop(moduleName, name) {\n  return () => {\n    const fqn = `${moduleName}.${name}`;\n    oneTimeWarning(fqn, `\"${fqn}\" is not supported yet on Titanium and uses a no-op fallback.`);\n    return undefined;\n  };\n}\n\n/**\r\n * @param {string} moduleName name of the module/object\r\n * @param {string} name name of the function.property we don't support\r\n * @param {Function} callback async callback we call in a quick setTimeout\r\n */\nfunction asyncUnsupportedNoop(moduleName, name, callback) {\n  callback = maybeCallback(callback); // enforce we have a valid callback\n  unsupportedNoop(moduleName, name)();\n  setTimeout(callback, 1);\n}\n\n// Used to choose the buffer/chunk size when pumping bytes during copies\nconst COPY_FILE_CHUNK_SIZE = 8092; // what should we use here?\n\n// Keep track of integer -> FileStream mappings\nconst fileDescriptors = new Map();\nlet fileDescriptorCount = 4; // global counter used to report file descriptor integers\n\n// Map file system access flags to Ti.Filesystem.MODE_* constants\nconst FLAGS_TO_TI_MODE = new Map();\nFLAGS_TO_TI_MODE.set('a', Ti.Filesystem.MODE_APPEND);\nFLAGS_TO_TI_MODE.set('ax', Ti.Filesystem.MODE_APPEND);\nFLAGS_TO_TI_MODE.set('a+', Ti.Filesystem.MODE_APPEND);\nFLAGS_TO_TI_MODE.set('ax+', Ti.Filesystem.MODE_APPEND);\nFLAGS_TO_TI_MODE.set('as+', Ti.Filesystem.MODE_APPEND);\nFLAGS_TO_TI_MODE.set('r', Ti.Filesystem.MODE_READ);\nFLAGS_TO_TI_MODE.set('r+', Ti.Filesystem.MODE_READ);\nFLAGS_TO_TI_MODE.set('rs+', Ti.Filesystem.MODE_READ);\nFLAGS_TO_TI_MODE.set('w', Ti.Filesystem.MODE_WRITE);\nFLAGS_TO_TI_MODE.set('wx', Ti.Filesystem.MODE_WRITE);\nFLAGS_TO_TI_MODE.set('w+', Ti.Filesystem.MODE_WRITE);\nFLAGS_TO_TI_MODE.set('wx+', Ti.Filesystem.MODE_WRITE);\n\n// Common errors\nconst permissionDenied = (syscall, path) => makeError('EACCES', 'permission denied', -13, syscall, path);\nconst noSuchFile = (syscall, path) => makeError('ENOENT', 'no such file or directory', -2, syscall, path);\nconst fileAlreadyExists = (syscall, path) => makeError('EEXIST', 'file already exists', -17, syscall, path);\nconst notADirectory = (syscall, path) => makeError('ENOTDIR', 'not a directory', -20, syscall, path);\nconst directoryNotEmpty = (syscall, path) => makeError('ENOTEMPTY', 'directory not empty', -66, syscall, path);\nconst illegalOperationOnADirectory = (syscall, path) => makeError('EISDIR', 'illegal operation on a directory', -21, syscall, path);\nconst fs = {\n  constants: {\n    O_RDONLY: 0,\n    O_WRONLY: 1,\n    O_RDWR: 2,\n    S_IFMT: 61440,\n    S_IFREG: 32768,\n    S_IFDIR: 16384,\n    S_IFCHR: 8192,\n    S_IFBLK: 24576,\n    S_IFIFO: 4096,\n    S_IFLNK: 40960,\n    S_IFSOCK: 49152,\n    O_CREAT: 512,\n    O_EXCL: 2048,\n    O_NOCTTY: 131072,\n    O_TRUNC: 1024,\n    O_APPEND: 8,\n    O_DIRECTORY: 1048576,\n    O_NOFOLLOW: 256,\n    O_SYNC: 128,\n    O_DSYNC: 4194304,\n    O_SYMLINK: 2097152,\n    O_NONBLOCK: 4,\n    S_IRWXU: 448,\n    S_IRUSR: 256,\n    S_IWUSR: 128,\n    S_IXUSR: 64,\n    S_IRWXG: 56,\n    S_IRGRP: 32,\n    S_IWGRP: 16,\n    S_IXGRP: 8,\n    S_IRWXO: 7,\n    S_IROTH: 4,\n    S_IWOTH: 2,\n    S_IXOTH: 1,\n    F_OK: 0,\n    R_OK: 4,\n    W_OK: 2,\n    X_OK: 1,\n    UV_FS_COPYFILE_EXCL: 1,\n    COPYFILE_EXCL: 1\n  }\n};\nclass Stats {\n  constructor(path) {\n    this._file = null;\n    this.dev = 0;\n    this.ino = 0;\n    this.mode = 0;\n    this.nlink = 0;\n    this.uid = 0;\n    this.gid = 0;\n    this.rdev = 0;\n    this.size = 0;\n    this.blksize = 4096; // FIXME: https://stackoverflow.com/questions/1315311/what-is-the-block-size-of-the-iphone-filesystem\n    this.blocks = 0;\n    this.atimeMs = this.mtimeMs = this.ctimeMs = this.birthtimeMs = 0;\n    this.atime = this.mtime = this.ctime = this.birthtime = new Date(0);\n    if (path) {\n      this._file = getTiFileFromPathLikeValue(path);\n\n      // TODO: use lazy getters here?\n      this.ctime = this.birthtime = this._file.createdAt();\n      this.atime = this.mtime = this._file.modifiedAt();\n      this.atimeMs = this.atime.getTime();\n      this.birthtimeMs = this.birthtime.getTime();\n      this.ctimeMs = this.ctime.getTime();\n      this.mtimeMs = this.mtime.getTime();\n      this.size = this._file.size;\n      this.blocks = Math.ceil(this.size / this.blksize);\n      // TODO: Can we fake out the mode based on the readonly/writable/executable properties?\n    }\n  }\n\n  isFile() {\n    return this._file.isFile();\n  }\n  isDirectory() {\n    return this._file.isDirectory();\n  }\n  isBlockDevice() {\n    return false;\n  }\n  isCharacterDevice() {\n    return false;\n  }\n  isSymbolicLink() {\n    return this._file.symbolicLink;\n  }\n  isFIFO() {\n    return false;\n  }\n  isSocket() {\n    return false;\n  }\n}\nfs.Stats = Stats;\nclass ReadStream {}\nfs.ReadStream = ReadStream;\nclass WriteStream {}\nfs.WriteStream = WriteStream;\n\n/**\r\n * @callback statsCallback\r\n * @param {Error} err - Error if one occurred\r\n * @param {fs.Stats} stats - file stats\r\n */\n\n/**\r\n * @param {string|URL|Buffer} path file path\r\n * @param {integer} [mode=fs.constants.F_OK] accessibility mode/check\r\n * @param {function} callback async callback\r\n */\nfs.access = function (path, mode, callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = fs.constants.F_OK;\n  }\n  callback = maybeCallback(callback);\n  setTimeout(() => {\n    try {\n      fs.accessSync(path, mode);\n    } catch (e) {\n      callback(e);\n      return;\n    }\n    callback();\n  }, 1);\n};\n\n/**\r\n * @param {string|URL|Buffer} path file path\r\n * @param {integer} [mode=fs.constants.F_OK] accessibility mode/check\r\n */\nfs.accessSync = function (path, mode = fs.constants.F_OK) {\n  // F_OK is just whether file exists or not, no permissions check\n  // R_OK is read check\n  // W_OK is write check\n  // X_OK is execute check (acts like F_OK on Windows)\n  const fileHandle = getTiFileFromPathLikeValue(path);\n  if (!fileHandle.exists()) {\n    throw noSuchFile('access', path);\n  }\n\n  // TODO: We have no means of testing if a file is readable. It's assumed all files that exist under the app are?\n  if (mode & fs.constants.W_OK && !fileHandle.writable) {\n    throw permissionDenied('access', path);\n  }\n  if (mode & fs.constants.X_OK && !fileHandle.executable && fileHandle.isFile()) {\n    throw permissionDenied('access', path);\n  }\n};\n\n/**\r\n * Asynchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer.\r\n * @param {string|Buffer|URL|FileStream} file filepath to file\r\n * @param {string|Buffer} data data to append to file\r\n * @param {object|string} [options] options\r\n * @param {string} [options.encoding='utf8'] encoding to use\r\n * @param {integer} [options.mode=0o666] mode to create file, if not created\r\n * @param {string} [options.flag='a'] file system flag\r\n * @param {Function} callback function to call back with error if failed\r\n */\nfs.appendFile = (file, data, options, callback) => {\n  callback = maybeCallback(callback || options);\n  options = mergeDefaultOptions(options, {\n    encoding: 'utf8',\n    mode: 0o666,\n    flag: 'a'\n  });\n  fs.writeFile(file, data, options, callback);\n};\n\n/**\r\n * Synchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer.\r\n * @param {string|Buffer|URL|FileStream} file filepath to file\r\n * @param {string|Buffer} data data to append to file\r\n * @param {object|string} [options] options\r\n * @param {string} [options.encoding='utf8'] encoding to use\r\n * @param {integer} [options.mode=0o666] mode to create file, if not created\r\n * @param {string} [options.flag='a'] file system flag\r\n */\nfs.appendFileSync = (file, data, options) => {\n  options = mergeDefaultOptions(options, {\n    encoding: 'utf8',\n    mode: 0o666,\n    flag: 'a'\n  });\n  fs.writeFileSync(file, data, options);\n  // TODO: Use Ti.Filesystem.File.append() instead?\n};\n\nfs.chmod = (path, mode, callback) => asyncUnsupportedNoop('fs', 'chmod', callback);\nfs.chmodSync = unsupportedNoop('fs', 'chmodSync');\nfs.chown = (path, uid, gid, callback) => asyncUnsupportedNoop('fs', 'chown', callback);\nfs.chownSync = unsupportedNoop('fs', 'chownSync');\n\n/**\r\n * Callback for functions that can only throw errors\r\n *\r\n * @callback errorCallback\r\n * @param {Error} [err] - Error thrown\r\n */\n\n/**\r\n * @param {integer} fd file descriptor\r\n * @param {errorCallback} callback callback function\r\n */\nfs.close = (fd, callback) => {\n  callback = maybeCallback(callback);\n  setTimeout(() => {\n    try {\n      fs.closeSync(fd);\n    } catch (e) {\n      callback(e);\n      return;\n    }\n    callback();\n  }, 1);\n};\n\n/**\r\n * @param {integer} fd file descriptor\r\n */\nfs.closeSync = fd => {\n  const stream = streamForDescriptor(fd);\n  stream.close();\n};\n\n// Rather than use a hack to wrap sync version in setTimeout, use actual async APIs!\n/**\r\n * @param {string|Buffer|URL} src source filename to copy\r\n * @param {string|Buffer|URL} dest destination filename of the copy operation\r\n * @param {number} [flags=0] modifiers for copy operation\r\n * @param {errorCallback} callback callback called at end of operation\r\n */\nfs.copyFile = function (src, dest, flags, callback) {\n  if (typeof flags === 'function') {\n    callback = flags;\n    flags = 0;\n  }\n  callback = maybeCallback(callback);\n\n  // FIXME: I don't know why, but changing this to use Ti.Filesystem.openStream(mode, path) fails (at least on iOS)\n  const srcFile = Ti.Filesystem.getFile(src);\n  const srcStream = srcFile.open(Ti.Filesystem.MODE_READ);\n  const destFile = Ti.Filesystem.getFile(dest);\n  const destStream = destFile.open(Ti.Filesystem.MODE_WRITE);\n  pipe(srcStream, destStream, callback);\n};\n\n/**\r\n * @param {string|Buffer|URL} src source filename to copy\r\n * @param {string|Buffer|URL} dest destination filename of the copy operation\r\n * @param {number} [flags=0] modifiers for copy operation\r\n */\nfs.copyFileSync = function (src, dest, flags = 0) {\n  const srcFile = Ti.Filesystem.getFile(src);\n  if (flags === fs.constants.COPYFILE_EXCL && fs.existsSync(dest)) {\n    throw fileAlreadyExists('copyFile', dest);\n  }\n  if (!srcFile.copy(dest)) {\n    throw new Error(`Unable to copy ${src} to ${dest}`); // FIXME: What error should we give?\n  }\n};\n\n// TODO: fs.createReadStream(path, options)\n// /**\n//  * @param {string|Buffer|URL} path path like\n//  * @param {string|object} [options] options, if a string, it's the encoding\n//  * @param {string} [options.flags='r'] See support of file system flags.\n//  * @param {string} [options.encoding=null] encoding\n//  * @param {integer} [options.fd=null] file descriptor, if specified, `path` is ignored\n//  * @param {integer} [options.mode=0o666] permissions to set if file is created\n//  * @param {boolean} [options.autoClose=true] if false, file descriptor will not be closed; if true even on error it will be closed\n//  * @param {integer} [options.start] start index of range of bytes to read from file\n//  * @param {integer} [options.end=Infinity] end index of range of bytes to read from file\n//  * @param {integer} [options.highWaterMark=64 * 1024]\n//  * @returns {fs.ReadStream}\n//  */\n// fs.createReadStream = (path, options) => {\n// \toptions = mergeDefaultOptions(options, { flags: 'r', encoding: null, fd: null, mode: 0o666, autoClose: true, end: Infinity, highWaterMark: 64 * 1024 });\n\n// \t// FIXME: If options.fd, use that in place of path!\n// \tconst tiFile = getTiFileFromPathLikeValue(path);\n// };\n// TODO: fs.createWriteStream(path, options)\n\n/**\r\n * @callback existsCallback\r\n * @param {boolean} exists - whether path exists\r\n */\n\n/**\r\n * @param {string} path path to check\r\n * @param {existsCallback} callback callback function\r\n * @returns {void}\r\n */\nfs.exists = function (path, callback) {\n  callback = maybeCallback(callback);\n  setTimeout(() => {\n    callback(fs.existsSync(path));\n  }, 1);\n};\n\n/**\r\n * @param {string} path path to check\r\n * @returns {boolean} whether a file or directory exists at that path\r\n */\nfs.existsSync = function (path) {\n  try {\n    fs.accessSync(path);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nfs.fchmod = (fd, mode, callback) => asyncUnsupportedNoop('fs', 'fchmod', callback);\nfs.fchmodSync = unsupportedNoop('fs', 'fchmodSync');\nfs.fchown = (fd, uid, gid, callback) => asyncUnsupportedNoop('fs', 'fchown', callback);\nfs.fchownSync = unsupportedNoop('fs', 'fchownSync');\nfs.fdatasync = (fd, callback) => asyncUnsupportedNoop('fs', 'fdatasync', callback);\nfs.fdatasyncSync = unsupportedNoop('fs', 'fdatasyncSync');\n\n/**\r\n * @param {integer} fd file descriptor\r\n * @param {object} [options] options\r\n * @param {boolean} [options.bigint] whether stat values should be bigint\r\n * @param {function} callback async callback function\r\n */\nfs.fstat = (fd, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = maybeCallback(callback);\n  setTimeout(() => {\n    let stats;\n    try {\n      stats = fs.fstatSync(fd, options);\n    } catch (e) {\n      callback(e);\n      return;\n    }\n    callback(null, stats);\n  }, 1);\n};\n/**\r\n * @param {integer} fd file descriptor\r\n * @param {object} [_options] options\r\n * @param {boolean} [_options.bigint] whether stat values should be bigint\r\n * @returns {fs.Stats} stats for file descriptor\r\n */\nfs.fstatSync = (fd, _options) => {\n  const path = pathForFileDescriptor(fd);\n  return fs.statSync(path);\n};\n\n// TODO: Add versions of these APIs:\n// fs.fsync(fd, callback)\n// fs.fsyncSync(fd)\n// fs.ftruncate(fd[, len], callback)\n// fs.ftruncateSync(fd[, len])\n// fs.futimes(fd, atime, mtime, callback)\n// fs.futimesSync(fd, atime, mtime)\n// fs.lchmod(path, mode, callback)\n// fs.lchmodSync(path, mode)\n// fs.lchown(path, uid, gid, callback)\n// fs.lchownSync(path, uid, gid)\n// fs.link(existingPath, newPath, callback)\n// fs.linkSync(existingPath, newPath)\n\n// FIXME: If symbolic link we need to follow link to target to get stats! Our API doesn't support that!\nfs.lstat = (path, options, callback) => fs.stat(path, options, callback);\nfs.lstatSync = (path, options) => fs.statSync(path, options);\n\n/**\r\n * @param {string|Buffer|URL} path file path\r\n * @param {string|object} [options] options\r\n * @param {boolean} [options.recursive=false] recursivley create dirs?\r\n * @param {integer} [options.mode=0o777] permissions\r\n * @param {errorCallback} callback async callback\r\n */\nfs.mkdir = (path, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {\n      recursive: false,\n      mode: 0o777\n    };\n  }\n  callback = maybeCallback(callback);\n  setTimeout(() => {\n    try {\n      fs.mkdirSync(path, options);\n    } catch (e) {\n      callback(e);\n      return;\n    }\n    callback(null);\n  }, 1);\n};\n\n/**\r\n * @param {string|Buffer|URL} path file path\r\n * @param {string|object} [options] options\r\n * @param {boolean} [options.recursive=false] recursivley create dirs?\r\n * @param {integer} [options.mode=0o777] permissions\r\n */\nfs.mkdirSync = (path, options) => {\n  const tiFile = getTiFileFromPathLikeValue(path);\n  if (typeof options === 'number') {\n    options = {\n      recursive: false,\n      mode: options\n    };\n  } else {\n    options = mergeDefaultOptions(options, {\n      recursive: false,\n      mode: 0o777\n    });\n  }\n  if (!tiFile.createDirectory(options.recursive) && !options.recursive) {\n    if (tiFile.exists()) {\n      // already existed!\n      throw fileAlreadyExists('mkdir', path);\n    }\n    // We failed, probably because we didn't ask for recursive and parent doesn't exist, so reproduce node's error\n    throw noSuchFile('mkdir', path);\n  }\n};\n\n/**\r\n * @callback tempDirCallback\r\n * @param {Error} err - Error if one occurred\r\n * @param {string} folder - generated folder name\r\n */\n\n/**\r\n * @param {string} prefix directory name prefix\r\n * @param {string|object} [options] options\r\n * @param {string} [options.encoding='utf-8'] prefix encoding\r\n * @param {tempDirCallback} callback async callback\r\n */\nfs.mkdtemp = (prefix, options, callback) => {\n  assertArgumentType(prefix, 'prefix', 'string');\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = maybeCallback(callback);\n  options = mergeDefaultOptions(options, {\n    encoding: 'utf-8'\n  });\n\n  // try to be all async\n  const tryMkdtemp = () => {\n    const generated = randomCharacters(6, options.encoding); // generate six random characters\n    const path = `${prefix}${generated}`;\n    fs.mkdir(path, 0o700, err => {\n      if (err) {\n        if (err.code === 'EEXIST') {\n          // retry!\n          setTimeout(tryMkdtemp, 1);\n          return;\n        }\n        // bubble up error\n        callback(err);\n        return;\n      }\n      // succeeded! Hurray!\n      callback(null, path);\n    });\n  };\n  setTimeout(tryMkdtemp, 1);\n};\n\n/**\r\n * Creates a unique temporary directory.\r\n * @param {string} prefix directory name prefix\r\n * @param {string|object} [options] options\r\n * @param {string} [options.encoding='utf-8'] prefix encoding\r\n * @returns {string} path to created directory\r\n */\nfs.mkdtempSync = (prefix, options) => {\n  assertArgumentType(prefix, 'prefix', 'string');\n  options = mergeDefaultOptions(options, {\n    encoding: 'utf-8'\n  });\n  let retryCount = 0;\n  const MAX_RETRIES = 100;\n  while (retryCount < MAX_RETRIES) {\n    const generated = randomCharacters(6, options.encoding); // generate six random characters\n    const path = `${prefix}${generated}`;\n    try {\n      fs.mkdirSync(path, 0o700); // don't try recursive\n      return path;\n    } catch (e) {\n      if (e.code !== 'EEXIST') {\n        throw e; // bubble up error\n      }\n      // name was not unique, so retry\n      retryCount++;\n    }\n  }\n  throw new Error(`Failed to create a unique directory name with prefix ${prefix}`);\n};\n\n/**\r\n * @callback fileDescriptorCallback\r\n * @param {Error} err - Error if one occurred\r\n * @param {integer} fileDescriptor - generated file descriptor\r\n */\n\n/**\r\n * @param {string|Buffer|URL} path path to file\r\n * @param {string} [flags='r'] file system access flags\r\n * @param {integer} [mode=0o666] file mode to use when creating file\r\n * @param {fileDescriptorCallback} callback async callback\r\n */\nfs.open = (path, flags, mode, callback) => {\n  // flags and mode are optional, we need to handle if not supplied!\n  if (typeof flags === 'function') {\n    callback = flags;\n    flags = 'r';\n    mode = 0o666;\n  } else if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0o666;\n  }\n  callback = maybeCallback(callback);\n  setTimeout(() => {\n    let fileDescriptor;\n    try {\n      fileDescriptor = fs.openSync(path, flags, mode);\n    } catch (e) {\n      callback(e);\n      return;\n    }\n    callback(null, fileDescriptor);\n  }, 1);\n};\n\n/**\r\n * @param {string|Buffer|URL} path path to file\r\n * @param {string} [flags='r'] file system access flags\r\n * @param {integer} [_mode=0o666] file mode to use when creating file\r\n * @returns {integer}\r\n */\nfs.openSync = (path, flags = 'r', _mode = 0o666) => {\n  const tiFile = getTiFileFromPathLikeValue(path);\n  if (!tiFile.exists()) {\n    // TODO: Support creating file with specific mode\n    oneTimeWarning('fs.openSync.mode', 'fs.openSync\\'s mode parameter is unsupported in Titanium and will be ignored');\n    if (!tiFile.createFile()) {\n      // Oh crap, we failed to create the file. why?\n      if (!tiFile.parent.exists()) {\n        // parent does not exist!\n        throw noSuchFile('open', path);\n      }\n      throw new Error(`failed to create file at path ${path}`);\n    }\n  } else if (flags) {\n    // file/dir exists...\n    if ((flags.charAt(0) === 'w' || flags.charAt(0) === 'a') && tiFile.isDirectory()) {\n      // If user is trying to write or append and it's a directory, fail\n      throw illegalOperationOnADirectory('open', path);\n    }\n    if (flags.length > 1 && flags.charAt(1) === 'x') {\n      // If user has \"exclusive\" flag on, fail if file already exists\n      throw fileAlreadyExists('open', path);\n    }\n  }\n  const tiMode = FLAGS_TO_TI_MODE.get(flags);\n  if (tiMode === undefined) {\n    // TODO: Make use of common error type/code for this once we have internal/errors.js\n    const err = new TypeError(`The value \"${String(flags)}\" is invalid for option \"flags\"`);\n    err.code = 'ERR_INVALID_OPT_VALUE';\n    throw err;\n  }\n  return createFileDescriptor(path, tiFile.open(tiMode));\n};\n\n/**\r\n * @callback readCallback\r\n * @param {Error} err - Error if one occurred\r\n * @param {integer} bytesRead - number of bytes read\r\n * @param {Buffer} buffer buffer\r\n */\n\n/**\r\n * @param {integer} fd file descriptor\r\n * @param {Buffer|Ti.Buffer} buffer buffer to read into\r\n * @param {integer} offset the offset in the buffer to start writing at.\r\n * @param {integer} length integer specifying the number of bytes to read.\r\n * @param {integer} position where to begin reading from in the file\r\n * @param {readCallback} callback async callback\r\n */\nfs.read = (fd, buffer, offset, length, position, callback) => {\n  callback = maybeCallback(callback);\n  const tiFileStream = streamForDescriptor(fd);\n  if (!Buffer.isBuffer(buffer)) {\n    buffer = Buffer.from(buffer);\n  }\n  // FIXME: Allow using position argument!\n  if (position !== null) {\n    oneTimeWarning('fs.readSync.position', 'fs.readSync\\'s position argument is unsupported by Titanium and will be treated as null');\n  }\n  tiFileStream.read(buffer.toTiBuffer(), offset, length, readObj => {\n    if (!readObj.success) {\n      callback(new Error(readObj.error));\n      return;\n    }\n    callback(null, readObj.bytesProcessed, buffer);\n  });\n};\n\n/**\r\n * @param {integer} fd file descriptor\r\n * @param {Buffer|Ti.Buffer} buffer buffer to read into\r\n * @param {integer} offset the offset in the buffer to start writing at.\r\n * @param {integer} length integer specifying the number of bytes to read.\r\n * @param {integer} _position where to begin reading from in the file\r\n * @returns {integer} bytes read\r\n */\nfs.readSync = (fd, buffer, offset, length, _position) => {\n  const fileStream = streamForDescriptor(fd);\n  if (!Buffer.isBuffer(buffer)) {\n    buffer = Buffer.from(buffer);\n  }\n\n  // FIXME: Allow using position argument!\n  if (_position !== null) {\n    oneTimeWarning('fs.readSync.position', 'fs.readSync\\'s position argument is unsupported by Titanium and will be treated as null');\n  }\n  return fileStream.read(buffer.toTiBuffer(), offset, length);\n};\n\n/**\r\n * @callback filesCallback\r\n * @param {Error} err - Error if one occurred\r\n * @param {string[]|Buffer[]|fs.Dirent[]} files - file listing\r\n */\n\n/**\r\n * @param {string} path directory to list\r\n * @param {string|object} [options] optional options\r\n * @param {string} [options.encoding='utf8'] encoding to use for filenames, if `'buffer'`, returns `Buffer` objects\r\n * @param {boolean} [options.withFileTypes=false] if true, returns `fs.Dirent` objects\r\n * @param {filesCallback} callback async callback\r\n */\nfs.readdir = (path, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = maybeCallback(callback);\n  setTimeout(() => {\n    let result;\n    try {\n      result = fs.readdirSync(path, options);\n    } catch (e) {\n      callback(e);\n      return;\n    }\n    callback(null, result);\n  }, 1);\n};\n\n/**\r\n * @param {string} filepath directory to list\r\n * @param {string|object} [options] optional options\r\n * @param {string} [options.encoding='utf8'] encoding to use for filenames, if `'buffer'`, returns `Buffer` objects\r\n * @param {boolean} [options.withFileTypes=false] if true, returns `fs.Dirent` objects\r\n * @returns {string[]|Buffer[]|fs.Dirent[]}\r\n */\nfs.readdirSync = (filepath, options) => {\n  const file = getTiFileFromPathLikeValue(filepath);\n  if (!file.exists()) {\n    throw noSuchFile('scandir', filepath);\n  }\n  if (!file.isDirectory()) {\n    throw notADirectory('scandir', filepath);\n  }\n  options = mergeDefaultOptions(options, {\n    encoding: 'utf-8',\n    withFileTypes: false\n  });\n  const listing = file.getDirectoryListing();\n  if (options.withFileTypes === true) {\n    // TODO: if options.withFileTypes === true, return fs.Dirent objects\n    oneTimeWarning('fs.readdir\\'s options.withFileTypes is unsupported by Titanium and strings will be returned');\n  } else if (options.encoding === 'buffer') {\n    return listing.map(name => Buffer.from(name));\n  }\n  return listing;\n};\n\n/**\r\n * @callback readFilePostOpenCallback\r\n * @param {Error} err - Error if one occurred\r\n * @param {Ti.Buffer} buffer\r\n */\n/**\r\n * @param {integer} fileDescriptor file descriptor\r\n * @param {readFilePostOpenCallback} callback async callback\r\n */\nfunction readFilePostOpen(fileDescriptor, callback) {\n  callback = maybeCallback(callback);\n  fs.fstat(fileDescriptor, (err, stats) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    const fileSize = stats.size;\n\n    // Create a Ti.Buffer to read into\n    const buffer = Ti.createBuffer({\n      length: fileSize\n    });\n\n    // Use Ti.Stream.readAll(sourceStream, buffer, callback) which spins off a separate thread to read in while loop!\n    const sourceStream = streamForDescriptor(fileDescriptor);\n    Ti.Stream.readAll(sourceStream, buffer, readAllObj => {\n      if (!readAllObj.success) {\n        callback(new Error(readAllObj.error));\n        return;\n      }\n      callback(null, buffer);\n    });\n  });\n}\n\n/**\r\n * @callback readFileCallback\r\n * @param {Error} err - Error if one occurred\r\n * @param {string|Buffer} data\r\n */\n/**\r\n * Asynchronously read entire contents of file\r\n * @param {string|Buffer|URL|integer} path filename or file descriptor\r\n * @param {object|string} [options] options\r\n * @param {string} [options.encoding=null] encoding to use\r\n * @param {string} [options.flag='r'] file system flag\r\n * @param {readFileCallback} callback async callback\r\n */\nfs.readFile = (path, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {\n      encoding: null,\n      flag: 'r'\n    };\n  } else {\n    options = mergeDefaultOptions(options, {\n      encoding: null,\n      flag: 'r'\n    });\n  }\n  callback = maybeCallback(callback);\n  const wasFileDescriptor = typeof path === 'number';\n  let fileDescriptor = path; // may be overriden later\n  /**\r\n   * @param {Error} err possible Error\r\n   * @param {Ti.Buffer} buffer Ti.Buffer instance\r\n   */\n  const handleBuffer = (err, buffer) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    // fs.closeSync if it was not originally a file descriptor\n    if (!wasFileDescriptor) {\n      fs.closeSync(fileDescriptor);\n    }\n\n    // TODO: trim buffer if we didn't read full size?\n\n    callback(null, encodeBuffer(options.encoding, buffer));\n  };\n  if (!wasFileDescriptor) {\n    fs.open(path, options.flag, (err, fd) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      fileDescriptor = fd;\n      readFilePostOpen(fd, handleBuffer);\n    });\n  } else {\n    readFilePostOpen(path, handleBuffer);\n  }\n};\n\n/**\r\n * Returns the contents of the path.\r\n * @param {string|Buffer|URL|integer} path path to file\r\n * @param {object|string} [options] options\r\n * @param {string} [options.encoding=null] encoding to use\r\n * @param {string} [options.flag='r'] file system flag\r\n * @returns {string|Buffer} string if encoding is specified, otherwise Buffer\r\n */\nfs.readFileSync = (path, options) => {\n  options = mergeDefaultOptions(options, {\n    encoding: null,\n    flag: 'r'\n  });\n  const wasFileDescriptor = typeof path === 'number';\n  const fileDescriptor = wasFileDescriptor ? path : fs.openSync(path, options.flag); // use default mode\n\n  const tiFileStream = streamForDescriptor(fileDescriptor);\n  // Just use our own API that reads full stream in\n  const buffer = Ti.Stream.readAll(tiFileStream);\n\n  // fs.closeSync if it was not originally a file descriptor\n  if (!wasFileDescriptor) {\n    fs.closeSync(fileDescriptor);\n  }\n\n  // TODO: trim buffer if we didn't read full size?\n\n  return encodeBuffer(options.encoding, buffer);\n};\n\n// TODO: fs.readlink(path[, options], callback)\n// TODO: fs.readlinkSync(path[, options])\n\n/**\r\n * @callback realpathCallback\r\n * @param {Error} err - Error if one occurred\r\n * @param {string|Buffer} resolvedPath the resolved path\r\n */\n/**\r\n * @param {string|Buffer|URL} filepath original filepath\r\n * @param {object} [options] optiosn object\r\n * @param {string} [options.encoding='utf8'] encoding used for returned object. If 'buffer\", we'll return a Buffer in palce of a string\r\n * @param {realpathCallback} callback async callback\r\n */\nfs.realpath = (filepath, options, callback) => {\n  callback = maybeCallback(callback || options);\n  options = mergeDefaultOptions(options, {\n    encoding: 'utf8'\n  });\n  setTimeout(() => {\n    // FIXME: This assumes no symlinks, which we really don't have full support for in our SDK anyways.\n    const result = path.normalize(filepath);\n    fs.exists(result, resultExists => {\n      if (resultExists) {\n        if (options.encoding === 'buffer') {\n          return callback(null, Buffer.from(result));\n        }\n        return callback(null, result);\n      }\n\n      // this path doesn't exist, try each segment until we find first that doesn't\n      const segments = result.split(path.sep); // FIXME: Drop last segment as we already know the full path doesn't exist?\n      let partialFilePath = '';\n      let index = 0;\n      // handle typical case of empty first segment so we don't need to do an async setTimeout to get to first real case\n      if (segments[index].length === 0) {\n        index++;\n      }\n      setTimeout(tryPath, 1);\n      function tryPath() {\n        if (index >= segments.length) {\n          // don't run past end of segments, throw error for resolved path\n          return callback(noSuchFile(result));\n        }\n\n        // grab next segment\n        const segment = segments[index++];\n        if (segment.length === 0) {\n          // if it's an empty segment...\n          // try again at next index\n          return setTimeout(tryPath, 1);\n        }\n\n        // normal case\n        partialFilePath += path.sep + segment;\n        // check if path up to this point exists...\n        fs.exists(partialFilePath, partialExists => {\n          if (!partialExists) {\n            // nope, throw the Error\n            return callback(noSuchFile('lstat', partialFilePath));\n          }\n          // try again at next depth of dir tree\n          setTimeout(tryPath, 1);\n        });\n      }\n    });\n  }, 1);\n};\nfs.realpath.native = (path, options, callback) => {\n  fs.realpath(path, options, callback);\n};\n\n/**\r\n * @param {string|Buffer|URL} filepath original filepath\r\n * @param {object} [options] options object\r\n * @param {string} [options.encoding='utf8'] encoding used for returned object. If 'buffer\", we'll return a Buffer in palce of a string\r\n * @returns {string|Buffer}\r\n */\nfs.realpathSync = (filepath, options) => {\n  options = mergeDefaultOptions(options, {\n    encoding: 'utf8'\n  });\n  // FIXME: This assumes no symlinks, which we really don't have full support for in our SDK anyways.\n  const result = path.normalize(filepath);\n  if (!fs.existsSync(result)) {\n    // this path doesn't exist, try each segment until we find first that doesn't\n    const segments = result.split(path.sep);\n    let partialFilePath = '';\n    for (const segment of segments) {\n      if (segment.length === 0) {\n        continue;\n      }\n      partialFilePath += path.sep + segment;\n      if (!fs.existsSync(partialFilePath)) {\n        throw noSuchFile('lstat', partialFilePath);\n      }\n    }\n  }\n  if (options.encoding === 'buffer') {\n    return Buffer.from(result);\n  }\n  return result;\n};\nfs.realpathSync.native = (path, options) => {\n  fs.realpathSync(path, options);\n};\n\n/**\r\n * @param {string|Buffer|URL} oldPath source filepath\r\n * @param {string|Buffer|URL} newPath destination filepath\r\n * @param {errorCallback} callback async callback\r\n */\nfs.rename = (oldPath, newPath, callback) => {\n  callback = maybeCallback(callback);\n  setTimeout(() => {\n    try {\n      fs.renameSync(oldPath, newPath);\n    } catch (e) {\n      callback(e);\n      return;\n    }\n    callback();\n  }, 1);\n};\n\n/**\r\n * @param {string|Buffer|URL} oldPath source filepath\r\n * @param {string|Buffer|URL} newPath destination filepath\r\n */\nfs.renameSync = (oldPath, newPath) => {\n  const tiFile = getTiFileFromPathLikeValue(oldPath);\n  // src doesn't actually exist?\n  if (!tiFile.exists()) {\n    const err = noSuchFile('rename', oldPath);\n    err.message = `${err.message} -> '${newPath}'`;\n    err.dest = newPath;\n    throw err;\n  }\n  const destFile = getTiFileFromPathLikeValue(newPath);\n  if (destFile.isDirectory()) {\n    // dest is a directory that already exists\n    const err = illegalOperationOnADirectory('rename', oldPath);\n    err.message = `${err.message} -> '${newPath}'`;\n    err.dest = newPath;\n    throw err;\n  }\n  let tempPath;\n  if (destFile.isFile()) {\n    // destination file exists, we should overwrite\n    // Our APIs will fail if we try, so first let's make a backup copy and delete the the original\n    tempPath = path.join(fs.mkdtempSync(path.join(Ti.Filesystem.tempDirectory, 'rename-')), path.basename(newPath));\n    destFile.move(tempPath);\n  }\n  let success = false;\n  try {\n    success = tiFile.move(newPath);\n  } finally {\n    if (tempPath) {\n      // we temporarily copied the existing destination to back it up...\n      if (success) {\n        // move worked, so we can wipe it away whenever...\n        fs.unlink(tempPath, _err => {});\n      } else {\n        // move it back, because we failed!\n        const tmpFile = getTiFileFromPathLikeValue(tempPath);\n        tmpFile.move(newPath);\n      }\n    }\n  }\n};\n\n/**\r\n * @param {string|Buffer|URL} path file path\r\n * @param {errorCallback} callback async callback\r\n */\nfs.rmdir = (path, callback) => {\n  callback = maybeCallback(callback);\n  setTimeout(() => {\n    try {\n      fs.rmdirSync(path);\n    } catch (e) {\n      callback(e);\n      return;\n    }\n    callback();\n  }, 1);\n};\n/**\r\n * @param {string|Buffer|URL} path file path\r\n */\nfs.rmdirSync = path => {\n  const tiFile = getTiFileFromPathLikeValue(path);\n  if (!tiFile.deleteDirectory(false)) {\n    // do not delete contents!\n    // we failed to delete, but why?\n    // does it exist?\n    if (!tiFile.exists()) {\n      throw noSuchFile('rmdir', path);\n    }\n    // is it a file?\n    if (tiFile.isFile()) {\n      throw notADirectory('rmdir', path);\n    }\n    // is it not empty?\n    const subFiles = tiFile.getDirectoryListing();\n    if (subFiles && subFiles.length > 0) {\n      throw directoryNotEmpty('rmdir', path);\n    }\n  }\n};\n\n/**\r\n * @param {string|Buffer|URL} path file path\r\n * @param {object} [options] options\r\n * @param {boolean} [options.bigint] whether stat values should be bigint\r\n * @param {statsCallback} callback async callback\r\n */\nfs.stat = (path, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = maybeCallback(callback);\n  setTimeout(() => {\n    callback(null, new fs.Stats(path));\n  }, 1);\n};\n/**\r\n * @param {string|Buffer|URL|integer} path filepath or file descriptor\r\n * @param {object} [_options] options\r\n * @param {boolean} [_options.bigint] whether stat values should be bigint\r\n * @returns {fs.Stats}\r\n */\nfs.statSync = (path, _options) => new fs.Stats(path);\nfs.symlink = (target, path, type, callback) => asyncUnsupportedNoop('fs', 'symlink', callback);\nfs.symlinkSync = unsupportedNoop('fs', 'symlinkSync');\n\n/**\r\n * @param {string} path file path\r\n * @param {integer} [len=0] bytes to trim to\r\n * @param {errorCallback} callback async callback\r\n */\nfs.truncate = (path, len, callback) => {\n  callback = maybeCallback(callback || len);\n  if (typeof len !== 'number') {\n    len = 0;\n  }\n  if (len <= 0) {\n    fs.writeFile(path, '', callback); // empty the file\n    return;\n  }\n\n  // we have to retain some of the file!\n  // yuck, so let's read what we need to retain, then overwrite file with it\n  fs.open(path, (err, fd) => {\n    if (err) {\n      return callback(err);\n    }\n    const buffer = Buffer.alloc(len);\n    fs.read(fd, buffer, 0, len, null, (err, bytesRead, buffer) => {\n      if (err) {\n        fs.closeSync(fd);\n        return callback(err);\n      }\n      fs.close(fd, err => {\n        if (err) {\n          return callback(err);\n        }\n        fs.writeFile(path, buffer, callback);\n      });\n    });\n  });\n};\n\n/**\r\n * @param {string} path file path\r\n * @param {integer} [len=0] bytes to trim to\r\n */\nfs.truncateSync = (path, len = 0) => {\n  if (len <= 0) {\n    // empty the file\n    fs.writeFileSync(path, '');\n    return;\n  }\n\n  // we have to retain some of the file!\n  // yuck, so let's read what we need to retain, then overwrite file with it\n  const fd = fs.openSync(path);\n  const buffer = Buffer.alloc(len);\n  fs.readSync(fd, buffer, 0, len, null);\n  fs.closeSync(fd);\n  fs.writeFileSync(path, buffer);\n};\n\n/**\r\n * @param {string|Buffer|URL} path file path\r\n * @param {errorCallback} callback async callback\r\n */\nfs.unlink = (path, callback) => {\n  callback = maybeCallback(callback);\n  setTimeout(() => {\n    try {\n      fs.unlinkSync(path);\n    } catch (err) {\n      callback(err);\n      return;\n    }\n    callback();\n  }, 1);\n};\n/**\r\n * @param {string|Buffer|URL} path file path\r\n * @returns {undefined}\r\n */\nfs.unlinkSync = path => {\n  const tiFile = getTiFileFromPathLikeValue(path);\n  if (!tiFile.deleteFile()) {\n    // we failed, but why?\n    if (!tiFile.exists()) {\n      throw noSuchFile('unlink', path);\n    }\n    if (tiFile.isDirectory()) {\n      throw illegalOperationOnADirectory('unlink', path);\n    }\n  }\n};\nfs.unwatchFile = unsupportedNoop('fs', 'unwatchFile');\nfs.utimes = (path, atime, mtime, callback) => asyncUnsupportedNoop('fs', 'utimes', callback);\nfs.utimesSync = unsupportedNoop('fs', 'utimesSync');\nfs.watch = unsupportedNoop('fs', 'watch');\nfs.watchFile = unsupportedNoop('fs', 'watchFile');\n\n/**\r\n * @param {string|Buffer|URL|integer} file file path or descriptor\r\n * @param {string|Buffer|TypedArray|DataView} data data to write\r\n * @param {object|string} [options] options, encoding if string\r\n * @param {string|null} [options.encoding='utf-8'] options\r\n * @param {object} [options.mode=0o666] options\r\n * @param {object} [options.flag='w'] options\r\n * @param {errorCallback} callback async callback\r\n */\nfs.writeFile = (file, data, options, callback) => {\n  callback = maybeCallback(callback || options);\n  options = mergeDefaultOptions(options, {\n    encoding: 'utf8',\n    mode: 0o666,\n    flag: 'w'\n  });\n\n  // Turn into file descriptor\n  const wasFileDescriptor = typeof file === 'number';\n  let fileDescriptor = file; // may be overriden later\n  const finish = err => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (wasFileDescriptor) {\n      callback();\n      return;\n    }\n\n    // fs.close if it was not originally a file descriptor\n    fs.close(fileDescriptor, callback);\n  };\n  if (!wasFileDescriptor) {\n    fs.open(file, options.flag, options.mode, (err, fd) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      fileDescriptor = fd;\n      fs.write(fileDescriptor, data, finish);\n    });\n  } else {\n    fs.write(fileDescriptor, data, finish);\n  }\n};\n\n/**\r\n * @param {string|Buffer|URL|integer} file file path or descriptor\r\n * @param {string|Buffer|TypedArray|DataView} data data to write\r\n * @param {object|string} [options] options, encoding if string\r\n * @param {string} [options.encoding='utf-8'] options\r\n * @param {object} [options.mode=0o666] options\r\n * @param {object} [options.flag='w'] options\r\n */\nfs.writeFileSync = (file, data, options) => {\n  options = mergeDefaultOptions(options, {\n    encoding: 'utf8',\n    mode: 0o666,\n    flag: 'w'\n  });\n\n  // Turn into file descriptor\n  const wasFileDescriptor = typeof file === 'number';\n  const fileDescriptor = wasFileDescriptor ? file : fs.openSync(file, options.flag, options.mode);\n\n  // if data is a string, make it a buffer first\n  if (!Buffer.isBuffer(data)) {\n    data = Buffer.from('' + data, options.encoding); // force data to be a string, handles case where it's undefined and writes 'undefined' to file!\n  }\n\n  fs.writeSync(fileDescriptor, data);\n\n  // close if user didn't give us file descriptor\n  if (!wasFileDescriptor) {\n    fs.closeSync(fileDescriptor);\n  }\n};\n\n/**\r\n * @callback writeTiFileStreamCallback\r\n * @param {Error} err - Error if one occurred\r\n * @param {integer} written - bytes written\r\n */\n\n/**\r\n * @param {Ti.Filesystem.FileStream} tiFileStream file stream\r\n * @param {Buffer} buffer buffer we're writing\r\n * @param {writeTiFileStreamCallback} callback async callback\r\n */\nfunction writeTiFileStream(tiFileStream, buffer, callback) {\n  callback = maybeCallback(callback);\n  Ti.Stream.write(tiFileStream, buffer.toTiBuffer(), writeObj => {\n    if (!writeObj.success) {\n      callback(new Error(writeObj.error));\n      return;\n    }\n    callback(null, writeObj.bytesProcessed);\n  });\n}\n\n/**\r\n * @param {integer} fd file descriptor\r\n * @param {string|Buffer} buffer contents to write: Buffer or string\r\n * @param {integer} [offset] offset within Buffer to write; OR offset from the beginning of the file where this data should be written (if string)\r\n * @param {string|integer} [length] length of bytes to write if Buffer; OR expected string encoding\r\n * @param {writeCallback|integer} [position] offset from the beginning of the file where this data should be written (if Buffer); OR async callback if string\r\n * @param {writeCallback} [callback] async callback (if Buffer)\r\n */\nfs.write = (fd, buffer, offset, length, position, callback) => {\n  const isBuffer = Buffer.isBuffer(buffer);\n  if (isBuffer) {\n    writeBuffer(fd, buffer, offset, length, position, callback);\n  } else {\n    writeString(fd, buffer, offset, length, position);\n  }\n};\n\n/**\r\n * @param {integer} fd file descriptor\r\n * @param {string|Buffer} buffer contents to write\r\n * @param {integer} [offset] offset from the beginning of the file where this data should be written\r\n * @param {string|integer} [length]  expected string encoding\r\n * @param {integer} [position] position\r\n * @returns {integer} number of bytes written\r\n */\nfs.writeSync = (fd, buffer, offset, length, position) => {\n  const isBuffer = Buffer.isBuffer(buffer);\n  if (isBuffer) {\n    return writeBufferSync(fd, buffer, offset, length);\n  }\n  return writeStringSync(fd, buffer, offset, length);\n};\n\n// TODO: Add FileHandle class to match Node's wrapper for file descriptors. Re-purpose our own wrapper?\n// TODO: Add the fs.promises API!\n\n// TODO: Define fs.Dirent class, which can simply wrap a Ti.Filesystem.File (and is very similar to fs.Stats!)\n\n// Helper functions\n// --------------------------------------------------------\n\n/**\r\n * Tracks the pairing of the number we use to represent the file externally, the filepath it's pointing at, and the stream pointing at it.\r\n */\nclass FileDescriptor {\n  constructor(number, path, stream) {\n    this.path = path;\n    this.number = number;\n    this.stream = stream;\n  }\n}\n\n/**\r\n * @param {Ti.IOStream} srcStream input stream we're reading from\r\n * @param {Ti.IOStream} destStream output stream we're writing to\r\n * @param {errorCallback} callback async callback\r\n */\nfunction pipe(srcStream, destStream, callback) {\n  {\n    // Android is probably better off with Ti.Stream.writeStream, less overhead back and forth the bridge\n    // Though Android does support the Ti.Stream.pump/Ti.Stream.write pattern using both APIs async\n    pipeViaWriteStream(srcStream, destStream, callback);\n    return;\n  }\n}\n\n/**\r\n * @param {Ti.IOStream} srcStream input stream we're reading from\r\n * @param {Ti.IOStream} destStream output stream we're writing to\r\n * @param {errorCallback} callback async callback\r\n */\nfunction pipeViaWriteStream(srcStream, destStream, callback) {\n  Ti.Stream.writeStream(srcStream, destStream, COPY_FILE_CHUNK_SIZE, result => {\n    if (!result.success) {\n      return callback(new Error(result.error));\n    }\n\n    // Android will only call this at the end or error, so we can safely assume we're done here.\n    // iOS will call per loop iteration, see https://jira.appcelerator.org/browse/TIMOB-27320\n    callback();\n  });\n}\n\n/**\r\n * @param {string|Buffer|URL} path file path\r\n * @param {Ti.Filesystem.FileStream} fileStream file stream\r\n * @returns {integer} file descriptor\r\n */\nfunction createFileDescriptor(path, fileStream) {\n  const pointer = fileDescriptorCount++; // increment global counter\n  const fd = new FileDescriptor(pointer, path, fileStream);\n  fileDescriptors.set(pointer, fd); // use it to refer to this file stream as the \"descriptor\"\n  return pointer;\n}\n\n/**\r\n * @param {integer} fd file descriptor\r\n * @returns {Ti.Filesystem.FileStream} matching stream\r\n */\nfunction streamForDescriptor(fd) {\n  const wrapper = fileDescriptors.get(fd);\n  return wrapper.stream;\n}\n\n/**\r\n * @param {integer} fd file descriptor\r\n * @returns {string} matching stream\r\n */\nfunction pathForFileDescriptor(fd) {\n  const wrapper = fileDescriptors.get(fd);\n  return wrapper.path;\n}\n\n/**\r\n * Used to merge the user-supplied options with the defaults for a function. Special cases a string to be encoding.\r\n * @param {*} options user-supplied options\r\n * @param {object} defaults defaults to use\r\n * @return {object}\r\n */\nfunction mergeDefaultOptions(options, defaults) {\n  if (options === null) {\n    return defaults;\n  }\n  const optionsType = typeof options;\n  switch (optionsType) {\n    case 'undefined':\n    case 'function':\n      return defaults;\n    case 'string':\n      // Use copy of defaults but with encoding set to the 'options' value!\n      const merged = Object.assign({}, defaults);\n      merged.encoding = options;\n      return merged;\n    case 'object':\n      return options;\n    default:\n      assertArgumentType(options, 'options', 'object');\n      return null;\n    // should never get reached\n  }\n}\n\n/**\r\n * Enforces that we have a valid callback function. Throws TypeError if not.\r\n * @param {*} cb possible callback function\r\n * @returns {Function}\r\n * @throws {TypeError}\r\n */\nfunction maybeCallback(cb) {\n  if (typeof cb === 'function') {\n    return cb;\n  }\n  const err = new TypeError(`Callback must be a function. Received ${cb}`);\n  err.code = 'ERR_INVALID_CALLBACK';\n  throw err;\n}\n\n/**\r\n * returns randomly generated characters of given length 1-16\r\n * @param {integer} length 1 - 16\r\n * @param {string} [_encoding='utf8'] encoding of the string generated\r\n * @returns {string}\r\n */\nfunction randomCharacters(length, _encoding = 'utf8') {\n  // FIXME: use the encoding specified!\n  return (Math.random().toString(36) + '00000000000000000').slice(2, length + 2);\n}\nfunction makeError(code, message, errno, syscall, path) {\n  const error = new Error(`${code}: ${message}, ${syscall} '${path}'`);\n  error.errno = errno;\n  error.syscall = syscall;\n  error.code = code;\n  error.path = path;\n  return error;\n}\n\n/**\r\n * @param {string} encoding what we're encoding to\r\n * @param {Ti.Buffer} tiBuffer Ti.Buffer instance\r\n * @returns {Buffer} node-compatible Buffer instance\r\n */\nfunction encodeBuffer(encoding, tiBuffer) {\n  switch (encoding) {\n    case 'buffer':\n    case null:\n    case undefined:\n      // In this case we're always reading a file into a Ti.Buffer\n      // Wrapping Ti.Buffer is super-slow and should really only be if we're going to write to it\n      // Go the faster path by converting to ArrayBuffer and wrapping that\n      // TODO: Explicitly release the blob after conversion?\n      return Buffer.from(tiBuffer.toBlob().toArrayBuffer());\n    default:\n      // here' were converting to a string based on encoding. Internally our faster Buffer impl still delegates to Ti.Buffer in most cases\n      // so I don't think there's much benefit from converting to ArrayBuffer first\n      return Buffer.from(tiBuffer).toString(encoding);\n  }\n}\n\n/**\r\n * @param {string|Buffer|URL} path file path\r\n * @return {Ti.Filesystem.File}\r\n */\nfunction getTiFileFromPathLikeValue(path) {\n  // This is a hack that is likely to work in most cases?\n  // Basically assumes Buffer is holding a utf-8 string filename/path\n  // Node just copies the bytes from the buffer as-is on the native side and adds a null terminator\n  if (Buffer.isBuffer(path)) {\n    path = path.toString(); // assumes utf-8 string\n  }\n  // FIXME: Handle URLs! We don't have an URL shim yet, so no way to handle those yet\n  assertArgumentType(path, 'path', 'string');\n  return Ti.Filesystem.getFile(path);\n}\n\n/**\r\n * @callback writeBufferCallback\r\n * @param {Error} err - Error if one occurred\r\n * @param {integer} written - bytes written\r\n * @param {Buffer} buffer - original Buffer being written\r\n */\n\n/**\r\n * @param {integer} fd file descriptor\r\n * @param {Buffer} buffer contents to write\r\n * @param {integer} [offset] offset within Buffer to write\r\n * @param {integer} [length] length of bytes to write if Buffer\r\n * @param {integer} [position] offset from the beginning of the file where this data should be written\r\n * @param {writeBufferCallback} callback async callback\r\n */\nfunction writeBuffer(fd, buffer, offset, length, position, callback) {\n  callback = maybeCallback(callback || position || length || offset);\n  if (typeof offset !== 'number') {\n    offset = 0;\n  }\n  if (typeof length !== 'number') {\n    length = buffer.length - offset;\n  }\n  if (typeof position !== 'number') {\n    position = null;\n  }\n  // ok now what?\n  const tiFileStream = streamForDescriptor(fd);\n  // Make use of the buffer slice that's specified by offset/length\n  if (offset !== 0 || length !== buffer.length) {\n    buffer = buffer.slice(offset, length);\n  }\n  // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow\n  writeTiFileStream(tiFileStream, buffer, (err, bytesProcessed) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    callback(null, bytesProcessed, buffer);\n  });\n}\n\n/**\r\n * @param {integer} fd file descriptor\r\n * @param {Buffer} buffer contents to write\r\n * @param {integer} [offset] offset within Buffer to write\r\n * @param {integer} [length] length of bytes to write if Buffer\r\n * @param {integer} [position] offset from the beginning of the file where this data should be written\r\n * @returns {integer} number of bytes written\r\n */\nfunction writeBufferSync(fd, buffer, offset, length, position) {\n  if (typeof offset !== 'number') {\n    offset = 0;\n  }\n  if (typeof length !== 'number') {\n    length = buffer.length - offset;\n  }\n  // ok now what?\n  const tiFileStream = streamForDescriptor(fd);\n  // Make use of the buffer slice that's specified by offset/length\n  if (offset !== 0 || length !== buffer.length) {\n    buffer = buffer.slice(offset, length);\n  }\n  // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow\n  return tiFileStream.write(buffer.toTiBuffer());\n}\n\n/**\r\n * @callback writeStringCallback\r\n * @param {Error} err - Error if one occurred\r\n * @param {integer} written - bytes written\r\n * @param {string} string - original string being written\r\n */\n\n/**\r\n * @param {integer} fd file descriptor\r\n * @param {string} string contents to write\r\n * @param {integer} [position] offset from the beginning of the file where this data should be written\r\n * @param {string} [encoding='utf8'] expected string encoding\r\n * @param {writeStringCallback} [callback] async callback\r\n */\nfunction writeString(fd, string, position, encoding, callback) {\n  callback = maybeCallback(callback || encoding || position);\n  // position could be: number, function (callback)\n  if (typeof position !== 'number') {\n    position = null;\n  }\n  // encoding could be: function (callback) or string\n  if (typeof encoding !== 'string') {\n    encoding = 'utf8';\n  }\n  const tiFileStream = streamForDescriptor(fd);\n  string += ''; // coerce to string\n  const buffer = Buffer.from(string, encoding);\n  // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow\n  writeTiFileStream(tiFileStream, buffer, (err, bytesProcessed) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    callback(null, bytesProcessed, string);\n  });\n}\n\n/**\r\n * @param {integer} fd file descriptor\r\n * @param {string} string contents to write\r\n * @param {integer} [position] offset from the beginning of the file where this data should be written\r\n * @param {string} [encoding='utf8'] expected string encoding\r\n * @returns {integer} number of bytes written\r\n */\nfunction writeStringSync(fd, string, position, encoding) {\n  if (typeof encoding !== 'string') {\n    encoding = 'utf8';\n  }\n  const tiFileStream = streamForDescriptor(fd);\n  string += ''; // coerce to string\n  const buffer = Buffer.from(string, encoding);\n  // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow\n  return tiFileStream.write(buffer.toTiBuffer());\n}\n\nfunction Stream(_opts) {\n  // FIXME: Can't call EventEmitter as a function!\n  this._eventsToListeners = {};\n  this._maxListeners = undefined;\n  // EventEmitter.call(this, opts);\n  // TODO: Provide more than an empty class?\n}\n\nObject.setPrototypeOf(Stream.prototype, EventEmitter.prototype);\nObject.setPrototypeOf(Stream, EventEmitter);\n// Use util.inherits?\n\nfunction Readable(options) {\n  if (!(this instanceof Readable)) {\n    return new Readable(options);\n  }\n\n  // TODO: readableState?\n\n  this.readable = true;\n  if (options) {\n    if (typeof options.read === 'function') {\n      this._read = options.read;\n    }\n    if (typeof options.destroy === 'function') {\n      this._destroy = options.destroy;\n    }\n  }\n  Stream.call(this);\n}\nutil.inherits(Readable, Stream);\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\nReadable.prototype._read = function (_n) {\n  throw new Error('method not implemented: _read()');\n};\nfunction Writable(options) {\n  const isDuplex = this instanceof Duplex;\n  if (!isDuplex && !(this instanceof Writable)) {\n    return new Writable(options);\n  }\n  this.writable = true;\n  if (options) {\n    if (typeof options.write === 'function') {\n      this._write = options.write;\n    }\n    if (typeof options.writev === 'function') {\n      this._writev = options.writev;\n    }\n    if (typeof options.destroy === 'function') {\n      this._destroy = options.destroy;\n    }\n    if (typeof options.final === 'function') {\n      this._final = options.final;\n    }\n  }\n  Stream.call(this);\n}\nutil.inherits(Writable, Stream);\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) {\n    return new Duplex(options);\n  }\n  Readable.call(this, options);\n  Writable.call(this, options);\n  // TODO: Provide more than an empty class!\n  this.allowHalfOpen = true;\n  if (options) {\n    if (options.readable === false) {\n      this.readable = false;\n    }\n    if (options.writable === false) {\n      this.writable = false;\n    }\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      // this.once('end', onend);\n    }\n  }\n}\n\nutil.inherits(Duplex, Readable);\n// Copy Writable methods to Duplex (basically the odd double-inheritance)\nconst writableMethods = Object.keys(Writable.prototype);\nfor (let i = 0; i < writableMethods.length; i++) {\n  const method = writableMethods;\n  if (!Duplex.prototype[method]) {\n    Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\nfunction Transform(options) {\n  if (!(this instanceof Transform)) {\n    return new Transform(options);\n  }\n  Duplex.call(this, options);\n  // TODO: Provide more than an empty class!\n  if (options) {\n    if (typeof options.transform === 'function') {\n      this._transform = options.transform;\n    }\n    if (typeof options.flush === 'function') {\n      this._flush = options.flush;\n    }\n  } // When the writable side finishes, then flush out anything remaining.\n\n  // this.on('prefinish', prefinish);\n}\n\nutil.inherits(Transform, Duplex);\nStream.Stream = Stream; // legacy compat\nStream.Transform = Transform;\nStream.Readable = Readable;\nStream.Writable = Writable;\nStream.Duplex = Duplex;\n\n// Load all the node compatible core modules\nregister('path', path);\nregister('os', OS);\nregister('tty', tty);\nregister('util', util);\nregister('assert', assert);\nregister('events', EventEmitter);\nregister('buffer', BufferModule);\nregister('string_decoder', StringDecoder$1);\nregister('fs', fs);\nregister('stream', Stream);\n\n// Register require('buffer').Buffer as global\nglobal.Buffer = BufferModule.Buffer;\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n *\r\n * Description:\r\n * This script loads all JavaScript files ending with the name \"*.bootstrap.js\" and then executes them.\r\n * The main intention of this feature is to allow JavaScript files to kick-off functionality or\r\n * display UI to the end-user before the \"app.js\" gets loaded. This feature is the CommonJS\r\n * equivalent to Titanium's Android module onAppCreate() or iOS module load() features.\r\n *\r\n * Use-Cases:\r\n * - Automatically kick-off analytics functionality on app startup.\r\n * - Ensure \"Google Play Services\" is installed/updated on app startup on Android.\r\n */\n\n/**\r\n * Attempts to load all bootstraps from a \"bootstrap.json\" file created by the app build system.\r\n * This is an optional feature and is the fastest method of acquiring boostraps configured for the app.\r\n * This JSON file, if provided, must be in the same directory as this script.\r\n * @returns {string[]}\r\n * Returns an array of require() compatible strings if bootstraps were successfully loaded from JSON.\r\n * Returns an empty array if JSON file was found, but no bootstraps were configured for the app.\r\n * Returns null if JSON file was not found.\r\n */\nfunction fetchScriptsFromJson() {\n  const JSON_FILE_NAME = 'bootstrap.json';\n  try {\n    const jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, `ti.internal/${JSON_FILE_NAME}`);\n    if (jsonFile.exists()) {\n      const settings = JSON.parse(jsonFile.read().text);\n      if (Array.isArray(settings.scripts)) {\n        return settings.scripts;\n      }\n      return [];\n    }\n  } catch (error) {\n    Ti.API.error(`Failed to read \"${JSON_FILE_NAME}\". Reason: ${error.message}`);\n  }\n  return null;\n}\n\n/**\r\n * Recursively searches the \"Resources\" directory for all \"*.bootstrap.js\" files.\r\n * @returns {Array.<string>}\r\n * Returns an array of require() compatible strings for each bootstrap found in the search.\r\n * Returns an empty array if no bootstrap files were found.\r\n */\nfunction fetchScriptsFromResourcesDirectory() {\n  const resourceDirectory = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory);\n  const resourceDirectoryPathLength = resourceDirectory.nativePath.length;\n  const bootstrapScripts = [];\n  function loadFrom(file) {\n    if (file) {\n      if (file.isDirectory()) {\n        // This is a directory. Recursively look for bootstrap files under it.\n        const fileNameArray = file.getDirectoryListing();\n        if (fileNameArray) {\n          for (let index = 0; index < fileNameArray.length; index++) {\n            loadFrom(Ti.Filesystem.getFile(file.nativePath, fileNameArray[index]));\n          }\n        }\n      } else if (file.name.search(/.bootstrap.js$/) >= 0) {\n        // This is a bootstrap file.\n        // Convert its path to something loadable via require() and add it to the array.\n        let bootstrapPath = file.nativePath;\n        bootstrapPath = bootstrapPath.substr(resourceDirectoryPathLength, bootstrapPath.length - resourceDirectoryPathLength - '.js'.length);\n        bootstrapScripts.push(bootstrapPath);\n      }\n    }\n  }\n  loadFrom(resourceDirectory);\n  return bootstrapScripts;\n}\n\n/**\r\n * Non-blocking function which loads and executes all bootstrap scripts configured for the app.\r\n * @param {function} finished Callback to be invoked once all bootstraps have finished executing. Cannot be null.\r\n */\nfunction loadAsync(finished) {\n  // Acquire an array of all bootstrap scripts included with the app.\n  // - For best performance, attempt to fetch scripts via an optional JSON file created by the build system.\n  // - If JSON file not found (will return null), then search \"Resources\" directory for bootstrap files.\n  let bootstrapScripts = fetchScriptsFromJson();\n  if (!bootstrapScripts) {\n    bootstrapScripts = fetchScriptsFromResourcesDirectory();\n  }\n\n  // Do not continue if no bootstraps were found.\n  if (!bootstrapScripts || bootstrapScripts.length <= 0) {\n    finished();\n    return;\n  }\n\n  // Sort the bootstraps so that they'll be loaded in a consistent order between platforms.\n  bootstrapScripts.sort();\n\n  // Loads all bootstrap scripts found.\n  function loadBootstrapScripts(finished) {\n    let bootstrapIndex = 0;\n    function doLoad() {\n      // Attempt to load all bootstrap scripts.\n      while (bootstrapIndex < bootstrapScripts.length) {\n        // Load the next bootstrap.\n        const fileName = bootstrapScripts[bootstrapIndex];\n        const bootstrap = require(fileName); // eslint-disable-line security/detect-non-literal-require\n\n        // Invoke the bootstrap's execute() method if it has one. (This is optional.)\n        // We must wait for the given callback to be invoked before loading the next script.\n        // Note: This is expected to be used to display UI to the end-user.\n        if (bootstrap.execute) {\n          bootstrap.execute(onBootstrapExecutionFinished);\n          return;\n        }\n\n        // We're done with the current bootstrap. Time to load the next one.\n        bootstrapIndex++;\n      }\n\n      // Invoke given callback to inform caller that all loading is done.\n      finished();\n    }\n    function onBootstrapExecutionFinished() {\n      // Last bootstrap has finished execution. Time to load the next one.\n      // Note: Add a tiny delay so whatever UI the last bootstrap loaded has time to close.\n      bootstrapIndex++;\n      setTimeout(() => doLoad(), 1);\n    }\n    doLoad();\n  }\n\n  // We've finished loading/executing all bootstrap scripts.\n  // Inform caller by invoking the callback given to loadAsync().\n  loadBootstrapScripts(finished);\n}\n\n/**\r\n * Appcelerator Titanium Mobile\r\n * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.\r\n * Licensed under the terms of the Apache Public License\r\n * Please see the LICENSE included with this distribution for details.\r\n *\r\n * This script is loaded on app startup on all platforms. It is used to do the following:\r\n * - Provide consistent startup behavior between platforms, such as logging Titanium version.\r\n * - Load Titanium's core JavaScript extensions shared by all platforms.\r\n * - Provide \"*.bootstrap.js\" script support. (Similar to native module onAppCreate()/load() support.)\r\n * - Load the app developer's main \"app.js\" script after doing all of the above.\r\n */\n\n// Log the app name, app version, and Titanium version on startup.\nTi.API.info(`${Ti.App.name} ${Ti.App.version} (Powered by Titanium ${\"12.3.0\"}.${\"51c7c98afd\"})`);\nloadAsync(function () {\n  // We've finished loading/executing all bootstrap scripts.\n  // We can now proceed to run the main \"app.js\" script.\n  require('./app');\n\n  // This event is to be fired after \"app.js\" execution. Reasons:\n  // - Allow system to queue startup related events until \"app.js\" has had a chance to add listeners.\n  // - For Alloy apps, we now know that Alloy has been initialized and its globals were added.\n  Ti.App.fireEvent('started');\n});\n"}